{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nenum ReentrancyStatus {\n    NOT_ENTERED,\n    ENTERED\n}\n\n/**\n * @notice The `Status` enum represents the possible statuses of a trading strategy.\n * @dev This enum defines three status options that describe the state of a strategy:\n *      - ACTIVE: The strategy is currently active and operational.\n *      - CANCELLED: The strategy has been cancelled and is no longer in effect.\n *      - COMPLETED: The strategy has been successfully completed.\n */\nenum Status {\n    ACTIVE, // The strategy is currently active.\n    CANCELLED, // The strategy has been cancelled.\n    COMPLETED // The strategy has been successfully completed.\n}\n\n/**\n * @notice The `FloorLegType` enum defines the types of floor price legs for trading strategies.\n * @dev This enum enumerates three possible types of floor price legs that can be associated with a strategy:\n *      - NO_TYPE: No specific floor price leg is defined.\n *      - LIMIT_PRICE: The floor price is set as a specific limit price.\n *      - DECREASE_BY: The floor price is determined by decreasing the current price by a certain amount.\n */\nenum FloorLegType {\n    NO_TYPE, // No specific floor price leg is defined.\n    LIMIT_PRICE, // The floor price is set as a specific limit price.\n    DECREASE_BY // The floor price is determined by decreasing the current price by a certain amount.\n}\n/**\n * @notice The `BuyLegType` enum defines the types of buy legs for trading strategies.\n * @dev This enum enumerates two possible types of buy legs that can be associated with a strategy:\n *      - NO_TYPE: No specific buy leg is defined.\n *      - LIMIT_PRICE: The buy leg is set as a specific limit price.\n */\nenum BuyLegType {\n    NO_TYPE, // No specific buy leg is defined.\n    LIMIT_PRICE // The buy leg is set as a specific limit price.\n}\n\n/**\n * @notice The `SellLegType` enum defines the types of sell legs for trading strategies.\n * @dev This enum enumerates three possible types of sell legs that can be associated with a strategy:\n *      - NO_TYPE: No specific sell leg is defined.\n *      - LIMIT_PRICE: The sell leg is set as a specific limit price.\n *      - INCREASE_BY: The sell leg is determined by increasing the current price by a certain amount.\n */\nenum SellLegType {\n    NO_TYPE, // No specific sell leg is defined.\n    LIMIT_PRICE, // The sell leg is set as a specific limit price.\n    INCREASE_BY // The sell leg is determined by increasing the current price by a certain amount.\n}\n\n/**\n * @notice The `DIP_SPIKE` enum defines the types of dip and spike conditions for trading strategies.\n * @dev This enum enumerates five possible types of dip and spike conditions that can be associated with a strategy:\n *      - NO_SPIKE: No specific dip or spike condition is defined.\n *      - DECREASE_BY: The condition is based on a decrease in price by a certain percentage.\n *      - INCREASE_BY: The condition is based on an increase in price by a certain percentage.\n *      - FIXED_INCREASE: The condition is based on a fixed increase in price.\n *      - FIXED_DECREASE: The condition is based on a fixed decrease in price.\n */\nenum DIP_SPIKE {\n    NO_SPIKE, // No specific dip or spike condition is defined.\n    DECREASE_BY, // The condition is based on a decrease in price by a certain percentage.\n    INCREASE_BY, // The condition is based on an increase in price by a certain percentage.\n    FIXED_INCREASE, // The condition is based on a fixed increase in price.\n    FIXED_DECREASE // The condition is based on a fixed decrease in price.\n}\n\n/**\n * @notice The `DCA_UNIT` enum defines the units for Dollar-Cost Averaging (DCA) in trading strategies.\n * @dev This enum enumerates three possible units for DCA that can be associated with a strategy:\n *      - NO_UNIT: No specific DCA unit is defined.\n *      - PERCENTAGE: DCA is specified as a percentage of assets.\n *      - FIXED: DCA is specified as a fixed amount.\n */\nenum DCA_UNIT {\n    NO_UNIT, // No specific DCA unit is defined.\n    PERCENTAGE, // DCA is specified as a percentage of assets.\n    FIXED // DCA is specified as a fixed amount.\n}\n\n/**\n * @notice The `TimeUnit` enum defines the units of time for time-related settings in trading strategies.\n * @dev This enum enumerates three possible time units that can be used in trading strategies:\n *      - NO_UNIT: No specific time unit is defined.\n *      - HOURS: Time is measured in hours.\n *      - DAYS: Time is measured in days.\n */\nenum TimeUnit {\n    NO_UNIT, // No specific time unit is defined.\n    HOURS, // Time is measured in hours.\n    DAYS // Time is measured in days.\n}\n\n/**\n * @notice The `StrategyParametersInput` struct defines the parameters that configure a trading strategy.\n * @dev These parameters dictate the behavior of the strategy, including trading details, conditions, and actions.\n */\n\nstruct StrategyParametersInput {\n    // @param _investToken The address of the investment token.\n    address _investToken;\n    // @param _investAmount The amount of investment token to be used.\n    uint256 _investAmount;\n    // @param _stableToken The address of the stable token.\n    address _stableToken;\n    // @param _stableAmount The amount of stable token to be used.\n    uint256 _stableAmount;\n    // @param _impact The impact tolerance for the strategy.\n    uint256 _impact;\n    // @param _floorType The type of floor price (if floor is set).\n    FloorLegType _floorType;\n    // @param _floorValue The value of the floor price (if floor is set).\n    uint256 _floorValue;\n    // @param _liquidateOnFloor A flag to trigger liquidation when the floor price is reached (if floor is set)..\n    bool _liquidateOnFloor;\n    // @param _cancelOnFloor A flag to cancel the strategy when the floor price is reached (if floor is set).\n    bool _cancelOnFloor;\n    // @param _minimumLoss The minimum loss required for floor percentage to satisfy.\n    uint256 _minimumLoss;\n    // @param _buyType The type of buy action (if buy is set).\n    BuyLegType _buyType;\n    // @param _buyValue The value of the buy action (if buy is set).\n    uint256 _buyValue;\n    // @param _buyTwapTime The time interval for TWAP buying (if buy is set).\n    uint256 _buyTwapTime;\n    // @param _buyTwapTimeUnit The unit of time for TWAP buying .\n    TimeUnit _buyTwapTimeUnit;\n    // @param _btdValue The value for buying the dip (if buy is set).\n    uint256 _btdValue;\n    // @param _btdType The type of buy the dip action (if buy is set).\n    DIP_SPIKE _btdType;\n    // @param _buyDCAUnit The unit for buy DCA (Dollar-Cost Averaging) for stable amount (if buy is set).\n    DCA_UNIT _buyDCAUnit;\n    // @param _buyDCAValue The value for buy DCA.\n    uint256 _buyDCAValue;\n    // @param _sellType The type of sell action (if sell is set).\n    SellLegType _sellType;\n    // @param _sellValue The value of the sell action (if sell is set).\n    uint256 _sellValue;\n    // @param if sell DCA is selected, _highSellValue is used to trigger complete sell when the high sell value is reached (if sell is set).\n    uint256 _highSellValue;\n    // @param _minimumProfit The minimum profit to be generated during sell if sell profit percentage is set\n    uint256 _minimumProfit;\n    // @param _strValue The value of the str if it is set to true (if sell is set).\n    uint256 _strValue;\n    // @param _strType The type of str.\n    DIP_SPIKE _strType;\n    // @param _sellDCAUnit The unit for sell DCA (Dollar-Cost Averaging) for the invest amount (if sell is set).\n    DCA_UNIT _sellDCAUnit;\n    // @param _sellDCAValue The value for sell DCA.\n    uint256 _sellDCAValue;\n    // @param _sellTwapTime The time interval for TWAP selling (if sell is set).\n    uint256 _sellTwapTime;\n    //  @param _sellTwapTimeUnit The unit of time for TWAP selling (if sell is set).\n    TimeUnit _sellTwapTimeUnit;\n    // @param _completeOnSell A flag to complete the strategy on selling (if sell is set).\n    bool _completeOnSell;\n    // @param _current_price_sell The current price indicator is selected for sell\n    bool _current_price_sell;\n    // @param _current_price The current price indicator is selected for buy\n    bool _current_price_buy;\n}\n\n/**\n * @notice The `StrategyParameters` struct defines the parameters that configure a trading strategy.\n * @dev These parameters dictate the behavior of the strategy, including trading details, conditions, and actions.\n */\n\nstruct StrategyParameters {\n    // @param _investToken The address of the investment token.\n    address _investToken;\n    // @param _investAmount The amount of investment token to be used.\n    uint256 _investAmount;\n    // @param _stableToken The address of the stable token.\n    address _stableToken;\n    // @param _stableAmount The amount of stable token to be used.\n    uint256 _stableAmount;\n    // @param _impact The impact tolerance for the strategy.\n    uint256 _impact;\n    // @param _floorType The type of floor price (if floor is set).\n    FloorLegType _floorType;\n    // @param _floorValue The value of the floor price (if floor is set).\n    uint256 _floorValue;\n    // @param _liquidateOnFloor A flag to trigger liquidation when the floor price is reached (if floor is set)..\n    bool _liquidateOnFloor;\n    // @param _cancelOnFloor A flag to cancel the strategy when the floor price is reached (if floor is set).\n    bool _cancelOnFloor;\n    // @param _minimumLoss The minimum loss required for floor percentage to satisfy.\n    uint256 _minimumLoss;\n    // @param _buyType The type of buy action (if buy is set).\n    BuyLegType _buyType;\n    // @param _buyValue The value of the buy action (if buy is set).\n    uint256 _buyValue;\n    // @param _buyTwapTime The time interval for TWAP buying (if buy is set).\n    uint256 _buyTwapTime;\n    // @param _buyTwapTimeUnit The unit of time for TWAP buying .\n    TimeUnit _buyTwapTimeUnit;\n    // @param _btdValue The value for buying the dip (if buy is set).\n    uint256 _btdValue;\n    // @param _btdType The type of buy the dip action (if buy is set).\n    DIP_SPIKE _btdType;\n    // @param _buyDCAUnit The unit for buy DCA (Dollar-Cost Averaging) for stable amount (if buy is set).\n    DCA_UNIT _buyDCAUnit;\n    // @param _buyDCAValue The value for buy DCA.\n    uint256 _buyDCAValue;\n    // @param _sellType The type of sell action (if sell is set).\n    SellLegType _sellType;\n    // @param _sellValue The value of the sell action (if sell is set).\n    uint256 _sellValue;\n    // @param if sell DCA is selected, _highSellValue is used to trigger complete sell when the high sell value is reached (if sell is set).\n    uint256 _highSellValue;\n    // @param _minimumProfit The minimum profit to be generated during sell if sell profit percentage is set\n    uint256 _minimumProfit;\n    // @param _strValue The value of the str if it is set to true (if sell is set).\n    uint256 _strValue;\n    // @param _strType The type of str.\n    DIP_SPIKE _strType;\n    // @param _sellDCAUnit The unit for sell DCA (Dollar-Cost Averaging) for the invest amount (if sell is set).\n    DCA_UNIT _sellDCAUnit;\n    // @param _sellDCAValue The value for sell DCA.\n    uint256 _sellDCAValue;\n    // @param _sellTwapTime The time interval for TWAP selling (if sell is set).\n    uint256 _sellTwapTime;\n    //  @param _sellTwapTimeUnit The unit of time for TWAP selling (if sell is set).\n    TimeUnit _sellTwapTimeUnit;\n    // @param _completeOnSell A flag to complete the strategy on selling (if sell is set).\n    bool _completeOnSell;\n    // @param _current_price_sell The current price indicator is selected for sell\n    bool _current_price_sell;\n    // @param _current_price The current price indicator is selected for buy\n    bool _current_price_buy;\n    // @param This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain.\n    uint256[50] __gap;\n}\n\n/**\n * @notice The `Strategy` struct defines the characteristics and status of a trading strategy.\n * @dev This struct encapsulates important data related to a trading strategy, including user ownership,\n *      strategy parameters, execution times, financial metrics, and its current status.\n * it is mostly used for internal computation\n */\n\nstruct Strategy {\n    //  @param user The address of the strategy owner.\n    address user;\n    // @param parameters The parameters that configure the behavior of the strategy\n    // as passed by the user and defined above\n    StrategyParameters parameters;\n    // to store invest amount to be sold when dca is chosen for percentage.\n    uint256 sellPercentageAmount;\n    // to store stable amount to be given when dca is chosen for percentage.\n    uint256 buyPercentageAmount;\n    // the invest amount based on which sellPercentageAmount is calculated\n    uint256 sellPercentageTotalAmount;\n    // the stable amount based on which buyPercentageAmount is calculated\n    uint256 buyPercentageTotalAmount;\n    //  @param sellTwapExecutedAt The timestamp of the last executed TWAP (Time-Weighted Average Price) sell.\n    //  if sell twap is set for the sell. Otherwise it remains 0\n    uint256 sellTwapExecutedAt;\n    //  @param buyTwapExecutedAt The timestamp of the last executed TWAP buy.\n    //  if buy Twap is set for btd. Otherwise it remains 0.\n    uint256 buyTwapExecutedAt;\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 investRoundIdForBTD;\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 stableRoundIdForBTD;\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 investRoundIdForSTR;\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 stableRoundIdForSTR;\n    // @param investPrice The price at which investment is made.\n    //While creating strategy it is set to the current price\n    uint256 investPrice;\n    //  @param profit The current profit generated by the strategy.\n    uint256 profit;\n    //  @param budget The available budget for the strategy.\n    // it is set at the starting of the strategy\n    uint256 budget;\n    // @param status The current status of the strategy.\n    Status status;\n    // @param This empty reserved space is put in place to allow future versions to add new variables without shifting down storage in the inheritance chain.\n    uint256[50] __gap;\n}\n/**\n * @notice AppStorage is the central storage structure for this contract, holding essential data.\n * @dev This struct contains critical information used by the contract for operation.\n * It stores data such as function selectors, supported interfaces, the contract owner, strategy details,\n * Chainlink feed information, and more.\n */\n\nstruct AppStorage {\n    // maps function selectors to the facets that execute the functions.\n    // and maps the selectors to their position in the selectorSlots array.\n    // func selector => address facet, selector position\n    mapping(bytes4 => bytes32) facets;\n    // array of slots of function selectors.\n    // each slot holds 8 function selectors.\n    mapping(uint256 => bytes32) selectorSlots;\n    // The number of function selectors in selectorSlots\n    uint16 selectorCount;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address owner;\n    // next id to use for strategies\n    uint256 nextStrategyId;\n    // array of strategies\n    mapping(uint256 => Strategy) strategies;\n    // chainlink feeds - asset => USD feed\n    mapping(address => address) feeds;\n    // account => nonce\n    mapping(address => uint256) nonces;\n    // reentrancy status\n    ReentrancyStatus reentrancyStatus;\n    // sequencer uptime feed\n    address sequencerUptimeFeed;\n    // max stale period\n    uint256 maxStalePeriod;\n}\n\n/**\n * @title Swap\n * @dev A struct representing a swap or trade operation on a decentralized exchange (DEX).\n *  @param dex: The address of the DEX where the swap is to be executed.\n *  @param callData: Encoded data containing instructions for the swap on the specified DEX.\n */\nstruct Swap {\n    address dex;\n    bytes callData;\n}\n\n// Struct representing the parameters to update in a strategy\nstruct UpdateStruct {\n    uint256 sellValue;\n    uint256 buyValue;\n    uint256 strValue;\n    uint256 btdValue;\n    uint256 floorValue;\n    uint256 highSellValue;\n    uint256 buyTwapTime;\n    TimeUnit buyTwapTimeUnit;\n    uint256 buyDCAValue;\n    uint256 sellDCAValue;\n    uint256 sellTwapTime;\n    TimeUnit sellTwapTimeUnit;\n    bool toggleCompleteOnSell;\n    bool toggleLiquidateOnFloor;\n    bool toggleCancelOnFloor;\n    uint256 impact;\n    bool current_price_sell;\n    bool current_price_buy;\n    uint256 minimumLoss;\n    uint256 minimumProfit;\n}\n\n// struct for information regarding which token is added in the strategy and which deleted\nstruct TokensTransaction {\n    uint256 tokenSubstracted;\n    uint256 tokenAdded;\n    uint256 stableAmount;\n    uint256 investAmount;\n}\n"
    },
    "contracts/facets/StrategyFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { AppStorage, Strategy, StrategyParametersInput, SellLegType, BuyLegType, FloorLegType, DCA_UNIT, DIP_SPIKE, TimeUnit, Status, UpdateStruct } from \"../AppStorage.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { InvalidImpact, InvalidInvestToken, InvalidStableToken, TokensMustDiffer, AlreadyCancelled, AtLeastOneOptionRequired, InvalidBuyValue, InvalidBuyType, InvalidFloorValue, InvalidFloorType, InvalidSellType, InvalidSellValue, InvalidStableAmount, BuyAndSellAtMisorder, InvalidInvestAmount, FloorValueGreaterThanBuyValue, FloorValueGreaterThanSellValue, BothBuyTwapAndBTD, BuyDCAWithoutBuy, BuyTwapTimeInvalid, BuyTwapTimeUnitNotSelected, BothSellTwapAndSTR, SellDCAWithoutSell, SellTwapTimeUnitNotSelected, SellTwapTimeInvalid, SellTwapOrStrWithoutSellDCAUnit, SellDCAUnitWithoutSellDCAValue, StrWithoutStrType, BTDWithoutBTDType, BuyDCAWithoutBuyDCAUnit, BuyDCAUnitWithoutBuyDCAValue, InvalidHighSellValue, SellDCAValueRangeIsNotValid, BuyDCAValueRangeIsNotValid, DCAValueShouldBeLessThanIntitialAmount, OrphandStrategy, BuyNeverExecute, InvalidSigner, InvalidNonce, StrategyIsNotActive, BuyNotSet, SellNotSelected, PercentageNotInRange, BuyTwapNotSelected, SellTwapNotSelected, FloorNotSet } from \"../utils/GenericErrors.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\nimport { LibSignature } from \"../libraries/LibSignature.sol\";\nimport { LibUtil } from \"../libraries/LibUtil.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nerror BothStableAndInvestAmountProvided();\nerror OnlyOwnerCanCancelStrategies();\nerror NoAmountProvided();\nerror HighSellValueIsChosenWithoutSeLLDCA();\nerror OnlyOwnerCanUpdateStrategies();\nerror NothingToUpdate();\nerror SellDCANotSet();\nerror BuyDCANotSet();\nerror STRIsNotSet();\nerror BTDIsNotSet();\nerror InvestAmountMustBeProvided();\nerror FloorPercentageNotSet();\nerror SellPercentageNotSet();\nerror StrValueGreaterThan100();\nerror BtdValueGreaterThan100();\nerror BuySellCurrentPrice();\nerror TypeChosenWithoutValue();\nerror DCAValueWithoutDCA();\n\n/**\n * @title StrategyFacet\n * @notice This contract handles the creation, retrieval, and cancellation of strategies.\n * Strategies define specific trade execution conditions and actions.\n * @dev StrategyFacet is one of the facets of the system, dedicated to strategy management.\n */\ncontract StrategyFacet is Modifiers {\n    /**\n     * @notice The `Permit` struct is used to hold the parameters for the permit function.\n     * @param token The address of the token to spend.\n     * @param owner The address of the owner of the token.\n     * @param spender The address of the spender of the token.\n     * @param value The amount of the token to spend.\n     * @param deadline The deadline for the permit.\n     * @param v The v parameter of the permit signature.\n     * @param r The r parameter of the permit signature.\n     * @param s The s parameter of the permit signature.\n     */\n    struct Permit {\n        address token;\n        address owner;\n        address spender;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\n     * please look at AppStorage.sol for more detail\n     */\n    AppStorage internal s;\n\n    /**\n     * @notice Emitted when a new trading strategy is created.\n     * @param strategyId The unique ID of the strategy.\n     * @param user address of the user whose  for whose strategy is created\n     * @param parameter The strategy parameter including settings for buying and selling.\n     * @param investRoundId Round ID for the invest token price when the strategy is created.\n     * @param stableRoundId Round ID for the stable token price when the strategy is created.\n     * @param budget total budget of the user in the stable token\n     * @param price price of the invest token w.r.t. the stable when strategy was created\n     */\n\n    event StrategyCreated(\n        uint256 indexed strategyId,\n        address user,\n        StrategyParametersInput parameter,\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        uint256 budget,\n        uint256 price\n    );\n\n    /**\n     * @notice Emitted when a trade execution strategy is cancelled.\n     * @param strategyId The unique ID of the cancelled strategy.\n     * @param investTokenPrice The price of the invest token in USD.\n     * @param stableTokenPrice The price of the stable token in USD.\n     */\n    event StrategyCancelled(uint256 indexed strategyId, uint256 investTokenPrice, uint256 stableTokenPrice);\n\n    /**\n     * @notice Emitted when a strategy is updated.\n     * @param strategyId The unique ID of the strategy.\n     * @param updateStruct updated parameters of the strategy\n     */\n    event StrategyUpdated(uint256 indexed strategyId, StrategyParametersInput updateStruct);\n\n    /**\n     * @notice Cancel a trade execution strategy.\n     * @dev This function allows users to cancel a trade execution strategy based on its unique ID.\n     *      When cancelled, the strategy's status is updated to \"CANCELLED.\"\n     * @param id The unique ID of the strategy to cancel.\n     */\n    function cancelStrategy(uint256 id) external nonReentrant {\n        _cancelStrategy(msg.sender, id);\n    }\n\n    /**\n     * @notice Cancel a trade execution strategy on behalf of another user.\n     * @dev This function allows users to cancel a trade execution strategy based on its unique ID.\n     *      When cancelled, the strategy's status is updated to \"CANCELLED.\"\n     * @param id The unique ID of the strategy to cancel.\n     */\n    function cancelStrategyOnBehalf(\n        uint256 id,\n        uint256 nonce,\n        bytes memory signature,\n        address account\n    ) external nonReentrant {\n        if (s.nonces[account] != nonce) {\n            revert InvalidNonce();\n        }\n\n        bytes32 messageHash = getMessageHashToCancel(id, nonce, account);\n        bytes32 ethSignedMessageHash = LibSignature.getEthSignedMessageHash(messageHash);\n        address signer = LibSignature.recoverSigner(ethSignedMessageHash, signature);\n        s.nonces[account] = s.nonces[account] + 1;\n\n        if (signer != account) {\n            revert InvalidSigner();\n        }\n\n        _cancelStrategy(account, id);\n    }\n\n    /**\n     * @notice Cancel a trade execution strategy.\n     * @dev This function allows users to cancel a trade execution strategy based on its unique ID.\n     *      When cancelled, the strategy's status is updated to \"CANCELLED.\"\n     * @param user The address of the user who created the strategy.\n     * @param id The unique ID of the strategy to cancel.\n     */\n    function _cancelStrategy(address user, uint256 id) internal {\n        Strategy storage strategy = s.strategies[id];\n        if (user != strategy.user) {\n            revert OnlyOwnerCanCancelStrategies();\n        }\n\n        if (strategy.status == Status.CANCELLED) {\n            revert AlreadyCancelled();\n        }\n\n        strategy.status = Status.CANCELLED;\n        uint256 investPrice = LibPrice.getUSDPrice(strategy.parameters._investToken);\n        uint256 stablePrice = LibPrice.getUSDPrice(strategy.parameters._stableToken);\n        emit StrategyCancelled(id, investPrice, stablePrice);\n    }\n\n    /**\n     * @notice Get the next available strategy ID.\n     * @dev This function returns the unique ID that will be assigned to the next created strategy.\n     * @return The next available strategy ID.\n     */\n    function nextStrategyId() external view returns (uint256) {\n        return s.nextStrategyId;\n    }\n\n    /**\n     * @notice Create a new trade execution strategy based on the provided parameters.\n     * @dev This function validates the input parameters to ensure they satisfy the criteria for creating a strategy.\n     *      If the parameters are valid, a new strategy is created and an event is emitted to indicate the successful creation.\n     *      If the parameters do not meet the criteria, an error is thrown.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     */\n    function createStrategy(StrategyParametersInput memory _parameter) public nonReentrant {\n        _createStrategy(_parameter, msg.sender);\n    }\n\n    /**\n     * @notice Create a new trade execution strategy based on the provided parameters on behalf of another user.\n     * @dev This function validates the input parameters to ensure they satisfy the criteria for creating a strategy.\n     *      If the parameters are valid, a new strategy is created and an event is emitted to indicate the successful creation.\n     *      If the parameters do not meet the criteria, an error is thrown.\n     * @param permits The array of `Permit` structs containing the parameters for the permit function.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     * @param account The address of the user who created the strategy.\n     * @param nonce The nonce of the user who created the strategy.\n     * @param signature The signature of the user who created the strategy.\n     */\n    function createStrategyOnBehalf(\n        Permit[] memory permits,\n        StrategyParametersInput memory _parameter,\n        address account,\n        uint256 nonce,\n        bytes memory signature\n    ) public nonReentrant {\n        for (uint256 i = 0; i < permits.length; i++) {\n            IERC20Permit(permits[i].token).permit(\n                permits[i].owner,\n                permits[i].spender,\n                permits[i].value,\n                permits[i].deadline,\n                permits[i].v,\n                permits[i].r,\n                permits[i].s\n            );\n        }\n\n        if (s.nonces[account] != nonce) {\n            revert InvalidNonce();\n        }\n\n        bytes32 messageHash = getMessageHashToCreate(_parameter, nonce, account);\n        bytes32 ethSignedMessageHash = LibSignature.getEthSignedMessageHash(messageHash);\n        address signer = LibSignature.recoverSigner(ethSignedMessageHash, signature);\n        s.nonces[account] = s.nonces[account] + 1;\n\n        if (signer != account) {\n            revert InvalidSigner();\n        }\n\n        _createStrategy(_parameter, account);\n    }\n\n    /**\n     * @notice Get the message hash for a given strategy to create it.\n     * @dev This function returns the message hash that must be signed by the user in order to create a strategy on behalf of another user.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     * @param nonce The nonce of the user who created the strategy.\n     * @param account The address of the user who created the strategy.\n     * @return The message hash for the given strategy.\n     */\n    function getMessageHashToCreate(\n        StrategyParametersInput memory _parameter,\n        uint256 nonce,\n        address account\n    ) public view returns (bytes32) {\n        return keccak256(abi.encode(account, nonce, _parameter, LibUtil.getChainID()));\n    }\n\n    /**\n     * @notice Get the message hash for a given strategy to cancel.\n     * @dev This function returns the message hash that must be signed by the user in order to cancel a strategy on behalf of another user.\n     * @param id The strategy id\n     * @param nonce The nonce of the user who created the strategy.\n     * @param account The address of the user who created the strategy.\n     * @return The message hash for the given strategy.\n     */\n    function getMessageHashToCancel(uint256 id, uint256 nonce, address account) public view returns (bytes32) {\n        return keccak256(abi.encode(account, nonce, id, LibUtil.getChainID()));\n    }\n\n    /**\n     * @notice Retrieve the details of a trade execution strategy.\n     * @dev This function allows users to query and retrieve information about a trade execution strategy\n     *      based on its unique ID.\n     * @param id The unique ID of the strategy to retrieve.\n     * @return A `Strategy` struct containing details of the specified strategy.\n     */\n    function getStrategy(uint256 id) external view returns (Strategy memory) {\n        return s.strategies[id];\n    }\n\n    /**\n     * @notice Create a new trade execution strategy based on the provided parameters.\n     * @dev This function validates the input parameters to ensure they satisfy the criteria for creating a strategy.\n     *      If the parameters are valid, a new strategy is created and an event is emitted to indicate the successful creation.\n     *      If the parameters do not meet the criteria, an error is thrown.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     * @param user The address of the user who created the strategy.\n     */\n    function _createStrategy(StrategyParametersInput memory _parameter, address user) internal {\n        if (_parameter._investToken == address(0)) {\n            revert InvalidInvestToken();\n        }\n\n        if (_parameter._stableToken == address(0)) {\n            revert InvalidStableToken();\n        }\n\n        if (_parameter._investToken == _parameter._stableToken) {\n            revert TokensMustDiffer();\n        }\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            _parameter._investToken,\n            _parameter._stableToken\n        );\n\n        if (_parameter._current_price_buy == true) {\n            _parameter._buyType = BuyLegType.LIMIT_PRICE;\n            _parameter._buyValue = price + (price * _parameter._impact) / LibTrade.MAX_PERCENTAGE;\n        }\n        if (_parameter._current_price_sell == true) {\n            _parameter._sellType = SellLegType.LIMIT_PRICE;\n            _parameter._sellValue = price - ((price * _parameter._impact) / LibTrade.MAX_PERCENTAGE);\n        }\n\n        if (_parameter._current_price_buy == true && _parameter._current_price_sell == true) {\n            if (_parameter._investAmount != 0) {\n                _parameter._buyValue = _parameter._sellValue - 1;\n            } else {\n                _parameter._sellValue = _parameter._buyValue + 1;\n            }\n        }\n\n        if ((_parameter._floorValue == 0 && _parameter._sellValue == 0 && _parameter._buyValue == 0)) {\n            revert AtLeastOneOptionRequired();\n        }\n\n        if (_parameter._buyValue > 0 && _parameter._buyTwapTime > 0 && _parameter._btdValue > 0) {\n            revert BothBuyTwapAndBTD();\n        }\n\n        if ((_parameter._buyTwapTime > 0 || _parameter._btdValue > 0) && _parameter._buyValue == 0) {\n            revert BuyDCAWithoutBuy();\n        }\n\n        if (_parameter._buyTwapTime > 0 && _parameter._buyTwapTimeUnit == TimeUnit.NO_UNIT) {\n            revert BuyTwapTimeUnitNotSelected();\n        }\n\n        if (_parameter._sellTwapTime > 0 && _parameter._strValue > 0) {\n            revert BothSellTwapAndSTR();\n        }\n\n        if ((_parameter._sellTwapTime > 0 || _parameter._strValue > 0) && _parameter._sellValue == 0) {\n            revert SellDCAWithoutSell();\n        }\n        if (_parameter._sellTwapTime > 0 && _parameter._sellTwapTimeUnit == TimeUnit.NO_UNIT) {\n            revert SellTwapTimeUnitNotSelected();\n        }\n\n        if ((_parameter._sellTwapTime > 0 || _parameter._strValue > 0) && _parameter._sellDCAUnit == DCA_UNIT.NO_UNIT) {\n            revert SellTwapOrStrWithoutSellDCAUnit();\n        }\n\n        if (_parameter._sellDCAUnit != DCA_UNIT.NO_UNIT && _parameter._sellDCAValue == 0) {\n            revert SellDCAUnitWithoutSellDCAValue();\n        }\n\n        if (_parameter._strValue > 0 && _parameter._strType == DIP_SPIKE.NO_SPIKE) {\n            revert StrWithoutStrType();\n        }\n\n        if (\n            _parameter._strValue > 0 &&\n            _parameter._strType == DIP_SPIKE.DECREASE_BY &&\n            _parameter._strValue > LibTrade.MAX_PERCENTAGE\n        ) {\n            revert StrValueGreaterThan100();\n        }\n\n        if (_parameter._btdValue > 0 && _parameter._btdType == DIP_SPIKE.NO_SPIKE) {\n            revert BTDWithoutBTDType();\n        }\n\n        if (\n            _parameter._btdValue > 0 &&\n            _parameter._btdType == DIP_SPIKE.DECREASE_BY &&\n            _parameter._btdValue > LibTrade.MAX_PERCENTAGE\n        ) {\n            revert BtdValueGreaterThan100();\n        }\n\n        if ((_parameter._btdValue > 0 || _parameter._buyTwapTime > 0) && _parameter._buyDCAUnit == DCA_UNIT.NO_UNIT) {\n            revert BuyDCAWithoutBuyDCAUnit();\n        }\n\n        if (_parameter._buyDCAUnit != DCA_UNIT.NO_UNIT && _parameter._buyDCAValue == 0) {\n            revert BuyDCAUnitWithoutBuyDCAValue();\n        }\n\n        if (_parameter._buyValue > 0 && _parameter._buyType == BuyLegType.NO_TYPE) {\n            revert InvalidBuyType();\n        }\n\n        // Check if floor is chosen\n        if (_parameter._floorValue > 0 && _parameter._floorType == FloorLegType.NO_TYPE) {\n            revert InvalidFloorType();\n        }\n\n        if (_parameter._highSellValue != 0) {\n            if (!(_parameter._strValue > 0 || _parameter._sellTwapTime > 0)) {\n                revert HighSellValueIsChosenWithoutSeLLDCA();\n            }\n        }\n\n        if (_parameter._sellValue > 0 || _parameter._strValue > 0 || _parameter._sellTwapTime > 0) {\n            if (_parameter._sellType == SellLegType.NO_TYPE) {\n                revert InvalidSellType();\n            }\n            if (_parameter._sellValue == 0) {\n                revert InvalidSellValue();\n            }\n            if (_parameter._highSellValue != 0 && _parameter._sellValue > _parameter._highSellValue) {\n                revert InvalidHighSellValue();\n            }\n        }\n\n        // Check if both buy and sell are chosen\n        if (_parameter._buyValue > 0 && (_parameter._sellValue > 0 || _parameter._floorValue > 0)) {\n            if (_parameter._stableAmount == 0 && _parameter._investAmount == 0) {\n                revert NoAmountProvided();\n            }\n            if (_parameter._buyValue >= _parameter._sellValue && _parameter._sellType == SellLegType.LIMIT_PRICE) {\n                revert BuyAndSellAtMisorder();\n            }\n        }\n        // Check if only buy is chosen\n        if (_parameter._buyValue > 0 && _parameter._sellValue == 0 && _parameter._floorValue == 0) {\n            if (_parameter._stableAmount == 0) {\n                revert InvalidStableAmount();\n            }\n            if (_parameter._investAmount > 0) {\n                revert OrphandStrategy();\n            }\n        }\n\n        if (_parameter._buyValue == 0 && _parameter._sellValue > 0 && _parameter._floorValue > 0) {\n            if (_parameter._stableAmount > 0) {\n                revert OrphandStrategy();\n            }\n        }\n\n        if (\n            (_parameter._sellValue > 0 || _parameter._floorValue > 0) &&\n            _parameter._investAmount == 0 &&\n            _parameter._buyValue == 0\n        ) {\n            revert InvestAmountMustBeProvided();\n        }\n        if (\n            (_parameter._sellValue > 0 || _parameter._floorValue > 0) &&\n            _parameter._investAmount > 0 &&\n            (_parameter._completeOnSell || _parameter._cancelOnFloor) &&\n            _parameter._buyValue > 0\n        ) // Check if only sell is chosen\n        {\n            revert BuyNeverExecute();\n        }\n\n        // Check if floor and sell are chosen\n        if (\n            _parameter._floorValue > 0 &&\n            _parameter._sellValue > 0 &&\n            _parameter._sellType == SellLegType.LIMIT_PRICE &&\n            _parameter._floorType == FloorLegType.LIMIT_PRICE\n        ) {\n            if (_parameter._floorValue >= _parameter._sellValue) {\n                revert FloorValueGreaterThanSellValue();\n            }\n        }\n\n        if (_parameter._floorValue > 0 && _parameter._floorType == FloorLegType.DECREASE_BY) {\n            if (_parameter._floorValue > LibTrade.MAX_PERCENTAGE) {\n                revert PercentageNotInRange();\n            }\n        }\n\n        // Check if floor and buy are chosen\n        if (\n            _parameter._floorValue > 0 && _parameter._buyValue > 0 && _parameter._floorType == FloorLegType.LIMIT_PRICE\n        ) {\n            if (_parameter._floorValue >= _parameter._buyValue) {\n                revert FloorValueGreaterThanBuyValue();\n            }\n        }\n\n        if (_parameter._impact > LibTrade.MAX_PERCENTAGE || _parameter._impact == 0) {\n            revert InvalidImpact();\n        }\n\n        if (\n            (_parameter._sellTwapTime > 0 || _parameter._strValue > 0) && _parameter._sellDCAUnit == DCA_UNIT.PERCENTAGE\n        ) {\n            if (_parameter._sellDCAValue <= 0 || _parameter._sellDCAValue > LibTrade.MAX_PERCENTAGE) {\n                revert SellDCAValueRangeIsNotValid();\n            }\n        }\n\n        if (\n            ((_parameter._sellTwapTime > 0 || _parameter._strValue > 0) && _parameter._sellDCAUnit == DCA_UNIT.FIXED) &&\n            _parameter._investAmount > 0 &&\n            (_parameter._sellDCAValue > _parameter._investAmount)\n        ) {\n            revert DCAValueShouldBeLessThanIntitialAmount();\n        }\n\n        if (\n            (_parameter._buyTwapTime > 0 || _parameter._btdValue > 0) &&\n            (_parameter._buyDCAUnit == DCA_UNIT.FIXED) &&\n            _parameter._stableAmount > 0 &&\n            (_parameter._buyDCAValue > _parameter._stableAmount)\n        ) {\n            revert DCAValueShouldBeLessThanIntitialAmount();\n        }\n\n        if (\n            (_parameter._buyTwapTime > 0 || _parameter._btdValue > 0) && _parameter._buyDCAUnit == DCA_UNIT.PERCENTAGE\n        ) {\n            if (_parameter._buyDCAValue <= 0 || _parameter._buyDCAValue > LibTrade.MAX_PERCENTAGE) {\n                revert BuyDCAValueRangeIsNotValid();\n            }\n        }\n\n        if (_parameter._minimumProfit > 0 && _parameter._sellType != SellLegType.INCREASE_BY) {\n            revert SellPercentageNotSet();\n        }\n\n        if (_parameter._minimumLoss > 0 && _parameter._floorType != FloorLegType.DECREASE_BY) {\n            revert FloorPercentageNotSet();\n        }\n\n        if (_parameter._btdType != DIP_SPIKE.NO_SPIKE && _parameter._btdValue == 0) {\n            revert TypeChosenWithoutValue();\n        }\n\n        if (_parameter._strType != DIP_SPIKE.NO_SPIKE && _parameter._strValue == 0) {\n            revert TypeChosenWithoutValue();\n        }\n\n        if (_parameter._buyTwapTimeUnit != TimeUnit.NO_UNIT && _parameter._buyTwapTime == 0) {\n            revert TypeChosenWithoutValue();\n        }\n\n        if (_parameter._sellTwapTimeUnit != TimeUnit.NO_UNIT && _parameter._sellTwapTime == 0) {\n            revert TypeChosenWithoutValue();\n        }\n\n        if (_parameter._floorType != FloorLegType.NO_TYPE && _parameter._floorValue == 0) {\n            revert TypeChosenWithoutValue();\n        }\n\n        if (_parameter._sellType != SellLegType.NO_TYPE && _parameter._sellValue == 0) {\n            revert TypeChosenWithoutValue();\n        }\n\n        if (_parameter._buyType != BuyLegType.NO_TYPE && _parameter._buyValue == 0) {\n            revert TypeChosenWithoutValue();\n        }\n\n        if ((_parameter._strValue == 0 && _parameter._sellTwapTime == 0) && _parameter._sellDCAValue > 0) {\n            revert DCAValueWithoutDCA();\n        }\n\n        if ((_parameter._btdValue == 0 && _parameter._buyTwapTime == 0) && _parameter._buyDCAValue > 0) {\n            revert DCAValueWithoutDCA();\n        }\n\n        uint256 decimals = 10 ** IERC20Metadata(_parameter._investToken).decimals();\n\n        if (_parameter._investAmount > 0 && _parameter._stableAmount > 0) {\n            revert BothStableAndInvestAmountProvided();\n        }\n        uint256 budget = 0;\n\n        if (_parameter._investAmount > 0) {\n            budget = ((_parameter._investAmount * price) / decimals);\n        }\n\n        if (_parameter._stableAmount > 0) {\n            budget = _parameter._stableAmount;\n        }\n        uint256 investPrice = 0;\n        if (_parameter._investAmount > 0) {\n            investPrice = price;\n        }\n        uint256 percentageAmountForSell = 0;\n        if (_parameter._sellDCAUnit == DCA_UNIT.PERCENTAGE) {\n            percentageAmountForSell = (_parameter._sellDCAValue * _parameter._investAmount) / LibTrade.MAX_PERCENTAGE;\n        }\n        uint256 percentageAmountForBuy = 0;\n        if (_parameter._buyDCAUnit == DCA_UNIT.PERCENTAGE) {\n            percentageAmountForBuy = (_parameter._buyDCAValue * _parameter._stableAmount) / LibTrade.MAX_PERCENTAGE;\n        }\n\n        s.strategies[s.nextStrategyId].user = user;\n        s.strategies[s.nextStrategyId].sellTwapExecutedAt = 0;\n        s.strategies[s.nextStrategyId].buyTwapExecutedAt = 0;\n        s.strategies[s.nextStrategyId].investRoundIdForBTD = investRoundId;\n        s.strategies[s.nextStrategyId].stableRoundIdForBTD = stableRoundId;\n        s.strategies[s.nextStrategyId].investRoundIdForSTR = investRoundId;\n        s.strategies[s.nextStrategyId].stableRoundIdForSTR = stableRoundId;\n        s.strategies[s.nextStrategyId].investPrice = investPrice;\n        s.strategies[s.nextStrategyId].profit = 0;\n        s.strategies[s.nextStrategyId].sellPercentageAmount = percentageAmountForSell;\n        s.strategies[s.nextStrategyId].sellPercentageTotalAmount = percentageAmountForSell > 0\n            ? _parameter._investAmount\n            : 0;\n        s.strategies[s.nextStrategyId].buyPercentageAmount = percentageAmountForBuy;\n        s.strategies[s.nextStrategyId].buyPercentageTotalAmount = percentageAmountForBuy > 0\n            ? _parameter._stableAmount\n            : 0;\n        s.strategies[s.nextStrategyId].budget = budget;\n        s.strategies[s.nextStrategyId].status = Status.ACTIVE;\n\n        s.strategies[s.nextStrategyId].parameters._investToken = _parameter._investToken;\n        s.strategies[s.nextStrategyId].parameters._stableToken = _parameter._stableToken;\n        s.strategies[s.nextStrategyId].parameters._investAmount = _parameter._investAmount;\n        s.strategies[s.nextStrategyId].parameters._stableAmount = _parameter._stableAmount;\n        s.strategies[s.nextStrategyId].parameters._impact = _parameter._impact;\n        s.strategies[s.nextStrategyId].parameters._floorType = _parameter._floorType;\n        s.strategies[s.nextStrategyId].parameters._floorValue = _parameter._floorValue;\n        s.strategies[s.nextStrategyId].parameters._liquidateOnFloor = _parameter._liquidateOnFloor;\n        s.strategies[s.nextStrategyId].parameters._cancelOnFloor = _parameter._cancelOnFloor;\n        s.strategies[s.nextStrategyId].parameters._minimumLoss = _parameter._minimumLoss;\n        s.strategies[s.nextStrategyId].parameters._buyType = _parameter._buyType;\n        s.strategies[s.nextStrategyId].parameters._buyValue = _parameter._buyValue;\n        s.strategies[s.nextStrategyId].parameters._buyTwapTime = _parameter._buyTwapTime;\n        s.strategies[s.nextStrategyId].parameters._buyTwapTimeUnit = _parameter._buyTwapTimeUnit;\n        s.strategies[s.nextStrategyId].parameters._btdValue = _parameter._btdValue;\n        s.strategies[s.nextStrategyId].parameters._btdType = _parameter._btdType;\n        s.strategies[s.nextStrategyId].parameters._buyDCAUnit = _parameter._buyDCAUnit;\n        s.strategies[s.nextStrategyId].parameters._buyDCAValue = _parameter._buyDCAValue;\n        s.strategies[s.nextStrategyId].parameters._sellType = _parameter._sellType;\n        s.strategies[s.nextStrategyId].parameters._sellValue = _parameter._sellValue;\n        s.strategies[s.nextStrategyId].parameters._highSellValue = _parameter._highSellValue;\n        s.strategies[s.nextStrategyId].parameters._minimumProfit = _parameter._minimumProfit;\n        s.strategies[s.nextStrategyId].parameters._strValue = _parameter._strValue;\n        s.strategies[s.nextStrategyId].parameters._strType = _parameter._strType;\n        s.strategies[s.nextStrategyId].parameters._sellDCAUnit = _parameter._sellDCAUnit;\n        s.strategies[s.nextStrategyId].parameters._sellDCAValue = _parameter._sellDCAValue;\n        s.strategies[s.nextStrategyId].parameters._sellTwapTime = _parameter._sellTwapTime;\n        s.strategies[s.nextStrategyId].parameters._sellTwapTimeUnit = _parameter._sellTwapTimeUnit;\n        s.strategies[s.nextStrategyId].parameters._completeOnSell = _parameter._completeOnSell;\n        s.strategies[s.nextStrategyId].parameters._current_price_sell = _parameter._current_price_sell;\n        s.strategies[s.nextStrategyId].parameters._current_price_buy = _parameter._current_price_buy;\n\n        s.nextStrategyId++;\n\n        emit StrategyCreated((s.nextStrategyId - 1), user, _parameter, investRoundId, stableRoundId, budget, price);\n    }\n\n    /**\n     * @dev Update an existing strategy with new parameters.\n     * @param strategyId The unique identifier of the strategy to update.\n     * @param updateStruct A struct containing the updated parameters for the strategy.\n     */\n    function updateStrategy(uint256 strategyId, UpdateStruct calldata updateStruct) external nonReentrant {\n        _updateStrategy(msg.sender, strategyId, updateStruct);\n    }\n\n    /**\n     * @notice Get the message hash for a given strategy to update it.\n     * @dev This function returns the message hash that must be signed by the user in order to update a strategy on behalf of another user.\n     * @param id The strategy id\n     * @param updateStruct updated parameters of the strategy\n     * @param nonce The nonce of the user who created the strategy.\n     * @param account The address of the user who created the strategy.\n     * @return The message hash for the given strategy.\n     */\n    function getMessageHashToUpdate(\n        uint256 id,\n        UpdateStruct calldata updateStruct,\n        uint256 nonce,\n        address account\n    ) public view returns (bytes32) {\n        return keccak256(abi.encode(account, nonce, id, updateStruct, LibUtil.getChainID()));\n    }\n\n    /**\n     * @dev Update an existing strategy with new parameters on behalf of another user.\n     * @param strategyId The unique identifier of the strategy to update.\n     * @param updateStruct A struct containing the updated parameters for the strategy.\n     * @param account The address of the user who created the strategy.\n     * @param nonce The nonce of the user who created the strategy.\n     * @param signature The signature of the user who created the strategy.\n     */\n    function updateStrategyOnBehalf(\n        uint256 strategyId,\n        UpdateStruct calldata updateStruct,\n        address account,\n        uint256 nonce,\n        bytes memory signature\n    ) external nonReentrant {\n        if (s.nonces[account] != nonce) {\n            revert InvalidNonce();\n        }\n\n        bytes32 messageHash = getMessageHashToUpdate(strategyId, updateStruct, nonce, account);\n        bytes32 ethSignedMessageHash = LibSignature.getEthSignedMessageHash(messageHash);\n        address signer = LibSignature.recoverSigner(ethSignedMessageHash, signature);\n        s.nonces[account] = s.nonces[account] + 1;\n\n        if (signer != account) {\n            revert InvalidSigner();\n        }\n\n        _updateStrategy(signer, strategyId, updateStruct);\n    }\n\n    /**\n     * @dev Update an existing strategy with new parameters.\n     * @param account The address of the user who created the strategy.\n     * @param strategyId The unique identifier of the strategy to update.\n     * @param updateStruct A struct containing the updated parameters for the strategy.\n     */\n    function _updateStrategy(address account, uint256 strategyId, UpdateStruct calldata updateStruct) internal {\n        if (\n            updateStruct.sellValue == 0 &&\n            updateStruct.buyValue == 0 &&\n            updateStruct.floorValue == 0 &&\n            updateStruct.highSellValue == 0 &&\n            updateStruct.buyTwapTime == 0 &&\n            updateStruct.buyTwapTimeUnit == TimeUnit.NO_UNIT &&\n            updateStruct.buyDCAValue == 0 &&\n            updateStruct.sellDCAValue == 0 &&\n            updateStruct.strValue == 0 &&\n            updateStruct.btdValue == 0 &&\n            updateStruct.sellTwapTime == 0 &&\n            updateStruct.sellTwapTimeUnit == TimeUnit.NO_UNIT &&\n            updateStruct.toggleCompleteOnSell == false &&\n            updateStruct.toggleLiquidateOnFloor == false &&\n            updateStruct.toggleCancelOnFloor == false &&\n            updateStruct.impact == 0 &&\n            updateStruct.minimumProfit == 0 &&\n            updateStruct.minimumLoss == 0 &&\n            updateStruct.current_price_buy == false &&\n            updateStruct.current_price_sell == false\n        ) {\n            revert NothingToUpdate();\n        }\n        Strategy storage strategy = s.strategies[strategyId];\n        if (strategy.user != account) {\n            revert OnlyOwnerCanUpdateStrategies();\n        }\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        if (updateStruct.sellValue > 0 && strategy.parameters._sellValue == 0) {\n            revert SellNotSelected();\n        }\n        if (updateStruct.buyValue > 0 && (strategy.parameters._buyValue == 0)) {\n            revert BuyNotSet();\n        }\n        if (updateStruct.floorValue > 0 && strategy.parameters._floorValue == 0) {\n            revert FloorNotSet();\n        }\n\n        if (\n            (updateStruct.highSellValue > 0 || updateStruct.sellDCAValue > 0) &&\n            (strategy.parameters._strValue == 0 && strategy.parameters._sellTwapTime == 0)\n        ) {\n            revert SellDCANotSet();\n        }\n\n        if (strategy.parameters._strValue == 0 && updateStruct.strValue > 0) {\n            revert STRIsNotSet();\n        }\n\n        if (\n            updateStruct.strValue > LibTrade.MAX_PERCENTAGE && (strategy.parameters._strType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            revert PercentageNotInRange();\n        } else if (\n            updateStruct.strValue > 0 &&\n            (strategy.parameters._strType == DIP_SPIKE.INCREASE_BY ||\n                strategy.parameters._strType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            strategy.parameters._strValue = updateStruct.strValue;\n        }\n        if (\n            updateStruct.strValue > 0 &&\n            (strategy.parameters._strType == DIP_SPIKE.FIXED_DECREASE ||\n                strategy.parameters._strType == DIP_SPIKE.FIXED_INCREASE)\n        ) {\n            strategy.parameters._strValue = updateStruct.strValue;\n        }\n\n        if (strategy.parameters._btdValue == 0 && updateStruct.btdValue > 0) {\n            revert BTDIsNotSet();\n        }\n\n        if (\n            updateStruct.btdValue > LibTrade.MAX_PERCENTAGE && (strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            revert PercentageNotInRange();\n        } else if (\n            updateStruct.btdValue > 0 &&\n            (strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY ||\n                strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            strategy.parameters._btdValue = updateStruct.btdValue;\n        }\n        if (\n            updateStruct.btdValue > 0 &&\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE ||\n                strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE)\n        ) {\n            strategy.parameters._btdValue = updateStruct.btdValue;\n        }\n\n        if (\n            updateStruct.buyDCAValue > 0 &&\n            (strategy.parameters._btdValue == 0 || strategy.parameters._buyTwapTime == 0)\n        ) {\n            revert BuyDCANotSet();\n        }\n        if (\n            (updateStruct.buyTwapTime > 0 || updateStruct.buyTwapTimeUnit != TimeUnit.NO_UNIT) &&\n            strategy.parameters._buyTwapTime == 0\n        ) {\n            revert BuyTwapNotSelected();\n        }\n        if (\n            (updateStruct.sellTwapTime > 0 || updateStruct.sellTwapTimeUnit != TimeUnit.NO_UNIT) &&\n            strategy.parameters._sellTwapTime == 0\n        ) {\n            revert SellTwapNotSelected();\n        }\n        if (updateStruct.impact > LibTrade.MAX_PERCENTAGE) {\n            revert InvalidImpact();\n        }\n\n        if (updateStruct.impact > 0) {\n            strategy.parameters._impact = updateStruct.impact;\n        }\n\n        (uint256 price, , ) = LibPrice.getPrice(strategy.parameters._investToken, strategy.parameters._stableToken);\n        if (updateStruct.current_price_buy == true) {\n            if (strategy.parameters._buyValue > 0) {\n                strategy.parameters._buyValue =\n                    price +\n                    ((price * strategy.parameters._impact) / LibTrade.MAX_PERCENTAGE);\n            } else {\n                revert BuyNotSet();\n            }\n        }\n\n        if (updateStruct.current_price_sell == true) {\n            if (strategy.parameters._sellValue > 0 && strategy.parameters._sellType == SellLegType.LIMIT_PRICE) {\n                strategy.parameters._sellValue =\n                    price -\n                    ((price * strategy.parameters._impact) / LibTrade.MAX_PERCENTAGE);\n            } else {\n                revert SellNotSelected();\n            }\n        }\n\n        if (updateStruct.current_price_buy == true && updateStruct.current_price_sell == true) {\n            revert BuySellCurrentPrice();\n        }\n\n        if (\n            updateStruct.floorValue > 0 &&\n            updateStruct.buyValue > 0 &&\n            strategy.parameters._floorType == FloorLegType.LIMIT_PRICE &&\n            strategy.parameters._buyValue > 0 &&\n            updateStruct.floorValue >= updateStruct.buyValue\n        ) {\n            revert FloorValueGreaterThanBuyValue();\n        }\n\n        if (\n            updateStruct.floorValue > 0 &&\n            strategy.parameters._floorType == FloorLegType.LIMIT_PRICE &&\n            strategy.parameters._buyValue > 0 &&\n            updateStruct.floorValue >= strategy.parameters._buyValue\n        ) {\n            revert FloorValueGreaterThanBuyValue();\n        }\n\n        if (updateStruct.floorValue > 0 && strategy.parameters._floorType == FloorLegType.DECREASE_BY) {\n            if (updateStruct.floorValue > LibTrade.MAX_PERCENTAGE) {\n                revert PercentageNotInRange();\n            } else {\n                strategy.parameters._floorValue = updateStruct.floorValue;\n            }\n        }\n\n        if (\n            updateStruct.floorValue > 0 &&\n            updateStruct.sellValue > 0 &&\n            strategy.parameters._floorType == FloorLegType.LIMIT_PRICE &&\n            strategy.parameters._sellValue > 0 &&\n            strategy.parameters._sellType == SellLegType.LIMIT_PRICE &&\n            updateStruct.floorValue >= updateStruct.sellValue\n        ) {\n            revert FloorValueGreaterThanSellValue();\n        }\n\n        if (\n            updateStruct.sellValue > 0 &&\n            strategy.parameters._floorType == FloorLegType.LIMIT_PRICE &&\n            strategy.parameters._sellValue > 0 &&\n            strategy.parameters._sellType == SellLegType.LIMIT_PRICE &&\n            strategy.parameters._floorValue >= updateStruct.sellValue\n        ) {\n            revert FloorValueGreaterThanSellValue();\n        }\n\n        if (\n            updateStruct.floorValue > 0 &&\n            strategy.parameters._floorType == FloorLegType.LIMIT_PRICE &&\n            strategy.parameters._sellValue > 0 &&\n            strategy.parameters._sellType == SellLegType.LIMIT_PRICE &&\n            updateStruct.floorValue >= strategy.parameters._sellValue\n        ) {\n            revert FloorValueGreaterThanSellValue();\n        }\n\n        if (\n            updateStruct.buyValue > 0 &&\n            updateStruct.sellValue > 0 &&\n            strategy.parameters._buyValue > 0 &&\n            strategy.parameters._sellValue > 0 &&\n            strategy.parameters._sellType == SellLegType.LIMIT_PRICE &&\n            updateStruct.buyValue >= updateStruct.sellValue\n        ) {\n            revert BuyAndSellAtMisorder();\n        }\n\n        if (\n            updateStruct.buyValue > 0 &&\n            strategy.parameters._sellType == SellLegType.LIMIT_PRICE &&\n            strategy.parameters._buyType == BuyLegType.LIMIT_PRICE &&\n            updateStruct.buyValue >= strategy.parameters._sellValue\n        ) {\n            revert BuyAndSellAtMisorder();\n        }\n\n        if (\n            updateStruct.sellValue > 0 &&\n            strategy.parameters._buyValue > 0 &&\n            strategy.parameters._sellValue > 0 &&\n            strategy.parameters._sellType == SellLegType.LIMIT_PRICE &&\n            strategy.parameters._buyValue >= updateStruct.sellValue\n        ) {\n            revert BuyAndSellAtMisorder();\n        }\n\n        if (\n            strategy.parameters._floorValue > 0 &&\n            strategy.parameters._floorType == FloorLegType.LIMIT_PRICE &&\n            updateStruct.floorValue > 0\n        ) {\n            strategy.parameters._floorValue = updateStruct.floorValue;\n        }\n\n        if (strategy.parameters._buyValue > 0 && updateStruct.buyValue > 0) {\n            strategy.parameters._buyValue = updateStruct.buyValue;\n        }\n\n        if (strategy.parameters._sellValue > 0 && updateStruct.sellValue > 0) {\n            strategy.parameters._sellValue = updateStruct.sellValue;\n        }\n\n        if (\n            (strategy.parameters._buyTwapTime > 0 || strategy.parameters._btdValue > 0) &&\n            strategy.parameters._buyDCAUnit == DCA_UNIT.PERCENTAGE\n        ) {\n            if (updateStruct.buyDCAValue <= 0 || updateStruct.buyDCAValue > LibTrade.MAX_PERCENTAGE) {\n                revert BuyDCAValueRangeIsNotValid();\n            }\n        }\n\n        if (\n            ((strategy.parameters._buyTwapTime > 0 || strategy.parameters._btdValue > 0) &&\n                strategy.parameters._buyDCAUnit == DCA_UNIT.FIXED) &&\n            strategy.parameters._stableAmount > 0 &&\n            (updateStruct.buyDCAValue > strategy.parameters._stableAmount)\n        ) {\n            revert DCAValueShouldBeLessThanIntitialAmount();\n        }\n\n        if (\n            (strategy.parameters._btdValue > 0 || strategy.parameters._buyTwapTime > 0) && updateStruct.buyDCAValue > 0\n        ) {\n            strategy.parameters._buyDCAValue = updateStruct.buyDCAValue;\n        }\n\n        if (\n            (strategy.parameters._sellTwapTime > 0 || strategy.parameters._strValue > 0) &&\n            strategy.parameters._sellDCAUnit == DCA_UNIT.PERCENTAGE\n        ) {\n            if (updateStruct.sellDCAValue <= 0 || updateStruct.sellDCAValue > LibTrade.MAX_PERCENTAGE) {\n                revert SellDCAValueRangeIsNotValid();\n            }\n        }\n\n        if (\n            ((strategy.parameters._sellTwapTime > 0 || strategy.parameters._strValue > 0) &&\n                strategy.parameters._sellDCAUnit == DCA_UNIT.FIXED) &&\n            strategy.parameters._investAmount > 0 &&\n            (updateStruct.sellDCAValue > strategy.parameters._investAmount)\n        ) {\n            revert DCAValueShouldBeLessThanIntitialAmount();\n        }\n\n        if (updateStruct.minimumLoss > 0 && strategy.parameters._floorType != FloorLegType.DECREASE_BY) {\n            revert FloorPercentageNotSet();\n        }\n\n        if (updateStruct.minimumProfit > 0 && strategy.parameters._sellType != SellLegType.INCREASE_BY) {\n            revert SellPercentageNotSet();\n        }\n\n        if (updateStruct.minimumLoss > 0) {\n            strategy.parameters._minimumLoss = updateStruct.minimumLoss;\n        }\n\n        if (updateStruct.minimumProfit > 0) {\n            strategy.parameters._minimumProfit = updateStruct.minimumProfit;\n        }\n\n        if (\n            (strategy.parameters._strValue > 0 || strategy.parameters._sellTwapTime > 0) &&\n            updateStruct.sellDCAValue > 0\n        ) {\n            strategy.parameters._sellDCAValue = updateStruct.sellDCAValue;\n        }\n\n        if (\n            strategy.parameters._buyTwapTime > 0 &&\n            (updateStruct.buyTwapTime != strategy.parameters._buyTwapTime ||\n                updateStruct.buyTwapTimeUnit != strategy.parameters._buyTwapTimeUnit)\n        ) {\n            strategy.parameters._buyTwapTime = updateStruct.buyTwapTime;\n\n            if (updateStruct.buyTwapTimeUnit != TimeUnit.NO_UNIT) {\n                strategy.parameters._buyTwapTimeUnit = updateStruct.buyTwapTimeUnit;\n            }\n        }\n\n        if (\n            strategy.parameters._sellTwapTime > 0 &&\n            (updateStruct.sellTwapTime != strategy.parameters._sellTwapTime ||\n                updateStruct.sellTwapTimeUnit != strategy.parameters._sellTwapTimeUnit)\n        ) {\n            if (updateStruct.sellTwapTime > 0) {\n                strategy.parameters._sellTwapTime = updateStruct.sellTwapTime;\n            }\n            if (\n                updateStruct.sellTwapTimeUnit != strategy.parameters._sellTwapTimeUnit &&\n                updateStruct.sellTwapTimeUnit != TimeUnit.NO_UNIT\n            ) {\n                strategy.parameters._sellTwapTimeUnit = updateStruct.sellTwapTimeUnit;\n            }\n        }\n\n        if (updateStruct.toggleCompleteOnSell) {\n            strategy.parameters._completeOnSell = !strategy.parameters._completeOnSell;\n        }\n        if (updateStruct.toggleLiquidateOnFloor) {\n            strategy.parameters._liquidateOnFloor = !strategy.parameters._liquidateOnFloor;\n        }\n        if (updateStruct.toggleCancelOnFloor) {\n            strategy.parameters._cancelOnFloor = !strategy.parameters._cancelOnFloor;\n        }\n\n        if (updateStruct.highSellValue != 0) {\n            if ((strategy.parameters._strValue == 0 && strategy.parameters._sellTwapTime == 0)) {\n                revert HighSellValueIsChosenWithoutSeLLDCA();\n            }\n        }\n\n        if (strategy.parameters._strValue > 0 || strategy.parameters._sellTwapTime > 0) {\n            if (updateStruct.highSellValue != 0 && strategy.parameters._sellValue > updateStruct.highSellValue) {\n                revert InvalidHighSellValue();\n            }\n        }\n\n        if (updateStruct.highSellValue != 0) {\n            strategy.parameters._highSellValue = updateStruct.highSellValue;\n        }\n\n        if (updateStruct.buyDCAValue > 0) {\n            strategy.buyPercentageAmount =\n                (strategy.parameters._buyDCAValue * strategy.buyPercentageTotalAmount) /\n                LibTrade.MAX_PERCENTAGE;\n        }\n\n        if (updateStruct.sellDCAValue > 0) {\n            strategy.sellPercentageAmount =\n                (strategy.parameters._sellDCAValue * strategy.sellPercentageTotalAmount) /\n                LibTrade.MAX_PERCENTAGE;\n        }\n\n        StrategyParametersInput memory parameters = StrategyParametersInput({\n            _investToken: strategy.parameters._investToken,\n            _stableToken: strategy.parameters._stableToken,\n            _investAmount: strategy.parameters._investAmount,\n            _stableAmount: strategy.parameters._stableAmount,\n            _impact: strategy.parameters._impact,\n            _floorType: strategy.parameters._floorType,\n            _floorValue: strategy.parameters._floorValue,\n            _liquidateOnFloor: strategy.parameters._liquidateOnFloor,\n            _cancelOnFloor: strategy.parameters._cancelOnFloor,\n            _minimumLoss: strategy.parameters._minimumLoss,\n            _buyType: strategy.parameters._buyType,\n            _buyValue: strategy.parameters._buyValue,\n            _buyTwapTime: strategy.parameters._buyTwapTime,\n            _buyTwapTimeUnit: strategy.parameters._buyTwapTimeUnit,\n            _btdValue: strategy.parameters._btdValue,\n            _btdType: strategy.parameters._btdType,\n            _buyDCAUnit: strategy.parameters._buyDCAUnit,\n            _buyDCAValue: strategy.parameters._buyDCAValue,\n            _sellType: strategy.parameters._sellType,\n            _sellValue: strategy.parameters._sellValue,\n            _highSellValue: strategy.parameters._highSellValue,\n            _minimumProfit: strategy.parameters._minimumProfit,\n            _strValue: strategy.parameters._strValue,\n            _strType: strategy.parameters._strType,\n            _sellDCAUnit: strategy.parameters._sellDCAUnit,\n            _sellDCAValue: strategy.parameters._sellDCAValue,\n            _sellTwapTime: strategy.parameters._sellTwapTime,\n            _sellTwapTimeUnit: strategy.parameters._sellTwapTimeUnit,\n            _completeOnSell: strategy.parameters._completeOnSell,\n            _current_price_sell: strategy.parameters._current_price_sell,\n            _current_price_buy: strategy.parameters._current_price_buy\n        });\n\n        emit StrategyUpdated(strategyId, parameters);\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/libraries/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    // -------------------------\n    /**\n     * @notice Slice a portion of a bytes array.\n     * @param _bytes The input bytes array.\n     * @param _start The starting index of the slice.\n     * @param _length The length of the slice.\n     * @return tempBytes A new bytes array containing the sliced data.\n     */\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) revert SliceOverflow();\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Convert a portion of a bytes array to an address.\n     * @param _bytes The input bytes array.\n     * @param _start The starting index of the address data.\n     * @return tempAddress The address extracted from the bytes array.\n     */\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        if (_bytes.length < _start + 20) {\n            revert AddressOutOfBounds();\n        }\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\n    /**\n     * @notice Convert a uint256 to its hexadecimal representation as a string.\n     * @param value The uint256 value to convert.\n     * @param length The desired length of the hexadecimal string.\n     * @return A string containing the hexadecimal representation of the uint256 value.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    function diamondStorage() internal pure returns (AppStorage storage s) {\n        assembly {\n            s.slot := 0\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        AppStorage storage s = diamondStorage();\n        address previousOwner = s.owner;\n        s.owner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        AppStorage storage s = diamondStorage();\n        uint256 originalSelectorCount = s.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            s.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        AppStorage storage s = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"LibDiamondCut: Can't add function that already exists\"\n                );\n                // add facet for selector\n                s.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot =\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    s.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"LibDiamondCut: Can't replace function with same function\"\n                );\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                s.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = s.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = s.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\n                    );\n                    // only useful if immutable functions exist\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"LibDiamondCut: Can't remove immutable function\"\n                    );\n                    // replace selector with last selector in s.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        s.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.facets[lastSelector]);\n                    }\n                    delete s.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete s.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport { LibDiamond } from \"./LibDiamond.sol\";\nimport { InvalidPrice, FeedNotFound } from \"../utils/GenericErrors.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\nerror SequencerDown();\nerror GracePeriodNotOver();\nerror PriceExpired();\n\n/**\n * @title LibPrice\n * @dev This library provides functions for fetching and manipulating asset prices.\n */\nlibrary LibPrice {\n    address constant USD_QUOTE = 0x0000000000000000000000000000000000000348;\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n\n    /**\n     * @notice Get the current price and round IDs of an asset relative to a unit.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The current price of the asset in terms of the unit.\n     * @return investRoundId The round ID of the asset's price feed.\n     * @return stableRoundId The round ID of the unit's price feed.\n     */\n    function getPrice(address asset, address unit) internal view returns (uint256 price, uint80, uint80) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        AggregatorV2V3Interface sequencerUptimeFeed = AggregatorV2V3Interface(s.sequencerUptimeFeed);\n\n        if (address(sequencerUptimeFeed) != address(0)) {\n            (\n                ,\n                /*uint80 roundID*/ int256 answer,\n                uint256 startedAt /*uint256 updatedAt*/ /*uint80 answeredInRound*/,\n                ,\n\n            ) = sequencerUptimeFeed.latestRoundData();\n\n            // Answer == 0: Sequencer is up\n            // Answer == 1: Sequencer is down\n            bool isSequencerUp = answer == 0;\n            if (!isSequencerUp) {\n                revert SequencerDown();\n            }\n\n            // Make sure the grace period has passed after the\n            // sequencer is back up.\n            uint256 timeSinceUp = block.timestamp - startedAt;\n            if (timeSinceUp <= GRACE_PERIOD_TIME) {\n                revert GracePeriodNotOver();\n            }\n        }\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (uint80 investRoundId, int256 assetPrice, , uint256 investUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[asset])\n            .latestRoundData();\n        (uint80 stableRoundId, int256 unitPrice, , uint256 stableUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[unit])\n            .latestRoundData();\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        if (\n            block.timestamp - investUpdatedAt > s.maxStalePeriod || block.timestamp - stableUpdatedAt > s.maxStalePeriod\n        ) {\n            revert PriceExpired();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return (price, investRoundId, stableRoundId);\n    }\n\n    /**\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\n     * @param investRoundId The round ID of the asset's price feed.\n     * @param stableRoundId The round ID of the unit's price feed.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\n     */\n    function getRoundData(\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        address asset,\n        address unit\n    ) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(investRoundId);\n        (, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).getRoundData(stableRoundId);\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        uint256 price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return price;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @return price The price of the asset in USD\n     */\n    function getUSDPrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0)) {\n            revert FeedNotFound();\n        }\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\n        if (assetPrice == 0) {\n            revert InvalidPrice();\n        }\n        return uint256(assetPrice);\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @param roundId the round for which price is required.\n     * @return price The price of the asset based on round Id\n     */\n    function getPriceBasedOnRoundId(address asset, uint80 roundId) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0)) {\n            revert FeedNotFound();\n        }\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(roundId);\n        if (assetPrice == 0) {\n            revert InvalidPrice();\n        }\n        return uint256(assetPrice);\n    }\n}\n"
    },
    "contracts/libraries/LibSignature.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\n/**\n * @title LibSignature\n * @dev This library provides utility functions for signature verification.\n */\nlibrary LibSignature {\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"invalid signature length\");\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n\n    function getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n    }\n}\n"
    },
    "contracts/libraries/LibTrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { HighImpact } from \"../utils/GenericErrors.sol\";\n\n/**\n * @title LibTrade\n * @dev This library provides functions for calculating exchange rates and validating slippage.\n */\nlibrary LibTrade {\n    uint256 public constant MAX_PERCENTAGE = 10000;\n\n    /**\n    @dev Calculate exchange rate given input and output amounts\n    @param fromAsset Address of the asset that was used to swap\n    @param fromAmount Amount of the asset that was used to swap\n    @param toAmount Amount of the asset that was received from swap\n    @return uint256 Returns the exchange rate in toAsset unit\n     */\n    function calculateExchangeRate(\n        address fromAsset,\n        uint256 fromAmount,\n        uint256 toAmount\n    ) internal view returns (uint256) {\n        IERC20Metadata _fromToken = IERC20Metadata(fromAsset);\n        uint256 fromDecimals = _fromToken.decimals();\n        return ((toAmount * (10 ** fromDecimals)) / fromAmount);\n    }\n\n    /**\n     * @notice Validate the Impact of a swap.\n     * @param exchangeRate The calculated exchange rate for the swap.\n     * @param price The reference price for the swap.\n     * @param maxImpact The maximum allowed Impact percentage.\n     * @param isBuy A flag indicating if it's a buy operation (true) or not (false).\n     * @return uint256 Returns the calculated Impact percentage.\n     */\n    function validateImpact(\n        uint256 exchangeRate,\n        uint256 price,\n        uint256 maxImpact,\n        bool isBuy\n    ) internal pure returns (uint256) {\n        uint256 impact = (price * MAX_PERCENTAGE) / exchangeRate;\n\n        if (isBuy && impact < MAX_PERCENTAGE && MAX_PERCENTAGE - impact > maxImpact) revert HighImpact();\n        if (!isBuy && impact > MAX_PERCENTAGE && impact - MAX_PERCENTAGE > maxImpact) revert HighImpact();\n        uint256 impactValue;\n        if (isBuy && impact < MAX_PERCENTAGE) {\n            impactValue = MAX_PERCENTAGE - impact;\n        } else if (!isBuy && impact > MAX_PERCENTAGE) {\n            impactValue = impact - MAX_PERCENTAGE;\n        }\n        return impactValue;\n    }\n}\n"
    },
    "contracts/libraries/LibUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"./LibBytes.sol\";\n\n/**\n * @title LibUtil\n * @dev This library provides utility functions for working with revert messages.\n */\nlibrary LibUtil {\n    using LibBytes for bytes;\n\n    /**\n     * @notice Get a revert message from transaction result data.\n     * @param _res The transaction result data to extract the revert message from.\n     * @return string The revert message or a \"Transaction reverted silently\" message if none is found.\n     */\n    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /**\n     * @notice Used the get the ID of the current chain.\n     * @return id The chain ID\n     */\n    function getChainID() internal view returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n}\n"
    },
    "contracts/utils/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nerror NoSwapFromZeroBalance();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror SwapFailed();\nerror TransferFailed();\nerror InvalidExchangeRate(uint256 required, uint256 actual);\nerror InvalidPrice();\nerror InvalidImpact();\nerror HighImpact();\nerror InvalidInvestToken();\nerror InvalidStableToken();\nerror TokensMustDiffer();\nerror AtLeastOneOptionRequired();\nerror InvalidInvestAmount();\nerror FloorValueZero();\nerror InvalidSellType();\nerror InvalidSellValue();\nerror BuyAndSellAtMisorder();\nerror InvalidStableAmount();\nerror InvalidBuyType();\nerror InvalidBuyValue();\nerror InvalidFloorValue();\nerror InvalidFloorType();\nerror InvalidSellTypeDCA();\nerror FloorValueGreaterThanBuyValue();\nerror FloorValueGreaterThanSellValue();\nerror BothBuyTwapAndBTD();\nerror BuyDCAWithoutBuy();\nerror BuyTwapTimeInvalid();\nerror BuyTwapTimeUnitNotSelected();\nerror BothSellTwapAndSTR();\nerror SellDCAWithoutSell();\nerror SellTwapTimeUnitNotSelected();\nerror SellTwapTimeInvalid();\nerror SellTwapOrStrWithoutSellDCAUnit();\nerror SellDCAUnitWithoutSellDCAValue();\nerror StrWithoutStrType();\nerror BTDWithoutBTDType();\nerror BuyDCAWithoutBuyDCAUnit();\nerror BuyDCAUnitWithoutBuyDCAValue();\nerror InvalidHighSellValue();\nerror SellDCAValueRangeIsNotValid();\nerror DCAValueShouldBeLessThanIntitialAmount();\nerror BuyDCAValueRangeIsNotValid();\nerror OrphandStrategy();\nerror BuyNeverExecute();\nerror FloorGreaterThanPrice();\nerror FeedNotFound();\nerror WrongPreviousIDs();\nerror RoundDataDoesNotMatch();\nerror StrategyIsNotActive();\nerror InvalidNonce();\nerror InvalidSigner();\nerror AlreadyCancelled();\nerror BuyNotSet();\nerror SellNotSelected();\nerror PercentageNotInRange();\nerror BuyTwapNotSelected();\nerror SellTwapNotSelected();\nerror FloorNotSet();\nerror ReentrancyGuardReentrantCall();\nerror PriceNotInRange();\n"
    },
    "contracts/utils/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { AppStorage, FloorLegType, BuyLegType, SellLegType, TimeUnit, DIP_SPIKE, DCA_UNIT, ReentrancyStatus } from \"../AppStorage.sol\";\nimport { ReentrancyGuardReentrantCall } from \"./GenericErrors.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\nabstract contract Modifiers {\n    /// @notice 100% = 100000 -> 2 decimals\n\n    modifier onlyOwner() {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        require(msg.sender == s.owner, \"Modifiers: Must be contract owner\");\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        // On the first call to nonReentrant, s.reentrancyStatus will be ReentrancyStatus.NOT_ENTERED\n        if (s.reentrancyStatus == ReentrancyStatus.ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        s.reentrancyStatus = ReentrancyStatus.ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        s.reentrancyStatus = ReentrancyStatus.NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        return s.reentrancyStatus == ReentrancyStatus.ENTERED;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
