{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "contracts/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nenum ReentrancyStatus {\n    NOT_ENTERED,\n    ENTERED\n}\n\n/**\n * @notice The `Status` enum represents the possible statuses of a trading strategy.\n * @dev This enum defines three status options that describe the state of a strategy:\n *      - ACTIVE: The strategy is currently active and operational.\n *      - CANCELLED: The strategy has been cancelled and is no longer in effect.\n *      - COMPLETED: The strategy has been successfully completed.\n */\nenum Status {\n    ACTIVE, // The strategy is currently active.\n    CANCELLED, // The strategy has been cancelled.\n    COMPLETED // The strategy has been successfully completed.\n}\n\n/**\n * @notice The `FloorLegType` enum defines the types of floor price legs for trading strategies.\n * @dev This enum enumerates three possible types of floor price legs that can be associated with a strategy:\n *      - NO_TYPE: No specific floor price leg is defined.\n *      - LIMIT_PRICE: The floor price is set as a specific limit price.\n *      - DECREASE_BY: The floor price is determined by decreasing the current price by a certain amount.\n */\nenum FloorLegType {\n    NO_TYPE, // No specific floor price leg is defined.\n    LIMIT_PRICE, // The floor price is set as a specific limit price.\n    DECREASE_BY // The floor price is determined by decreasing the current price by a certain amount.\n}\n/**\n * @notice The `BuyLegType` enum defines the types of buy legs for trading strategies.\n * @dev This enum enumerates two possible types of buy legs that can be associated with a strategy:\n *      - NO_TYPE: No specific buy leg is defined.\n *      - LIMIT_PRICE: The buy leg is set as a specific limit price.\n */\nenum BuyLegType {\n    NO_TYPE, // No specific buy leg is defined.\n    LIMIT_PRICE // The buy leg is set as a specific limit price.\n}\n\n/**\n * @notice The `SellLegType` enum defines the types of sell legs for trading strategies.\n * @dev This enum enumerates three possible types of sell legs that can be associated with a strategy:\n *      - NO_TYPE: No specific sell leg is defined.\n *      - LIMIT_PRICE: The sell leg is set as a specific limit price.\n *      - INCREASE_BY: The sell leg is determined by increasing the current price by a certain amount.\n */\nenum SellLegType {\n    NO_TYPE, // No specific sell leg is defined.\n    LIMIT_PRICE, // The sell leg is set as a specific limit price.\n    INCREASE_BY // The sell leg is determined by increasing the current price by a certain amount.\n}\n\n/**\n * @notice The `DIP_SPIKE` enum defines the types of dip and spike conditions for trading strategies.\n * @dev This enum enumerates five possible types of dip and spike conditions that can be associated with a strategy:\n *      - NO_SPIKE: No specific dip or spike condition is defined.\n *      - DECREASE_BY: The condition is based on a decrease in price by a certain percentage.\n *      - INCREASE_BY: The condition is based on an increase in price by a certain percentage.\n *      - FIXED_INCREASE: The condition is based on a fixed increase in price.\n *      - FIXED_DECREASE: The condition is based on a fixed decrease in price.\n */\nenum DIP_SPIKE {\n    NO_SPIKE, // No specific dip or spike condition is defined.\n    DECREASE_BY, // The condition is based on a decrease in price by a certain percentage.\n    INCREASE_BY, // The condition is based on an increase in price by a certain percentage.\n    FIXED_INCREASE, // The condition is based on a fixed increase in price.\n    FIXED_DECREASE // The condition is based on a fixed decrease in price.\n}\n\n/**\n * @notice The `DCA_UNIT` enum defines the units for Dollar-Cost Averaging (DCA) in trading strategies.\n * @dev This enum enumerates three possible units for DCA that can be associated with a strategy:\n *      - NO_UNIT: No specific DCA unit is defined.\n *      - PERCENTAGE: DCA is specified as a percentage of assets.\n *      - FIXED: DCA is specified as a fixed amount.\n */\nenum DCA_UNIT {\n    NO_UNIT, // No specific DCA unit is defined.\n    PERCENTAGE, // DCA is specified as a percentage of assets.\n    FIXED // DCA is specified as a fixed amount.\n}\n\n/**\n * @notice The `TimeUnit` enum defines the units of time for time-related settings in trading strategies.\n * @dev This enum enumerates three possible time units that can be used in trading strategies:\n *      - NO_UNIT: No specific time unit is defined.\n *      - HOURS: Time is measured in hours.\n *      - DAYS: Time is measured in days.\n */\nenum TimeUnit {\n    NO_UNIT, // No specific time unit is defined.\n    HOURS, // Time is measured in hours.\n    DAYS // Time is measured in days.\n}\n\n/**\n * @notice The `StrategyParameters` struct defines the parameters that configure a trading strategy.\n * @dev These parameters dictate the behavior of the strategy, including trading details, conditions, and actions.\n */\n\nstruct StrategyParameters {\n    // @param _investToken The address of the investment token.\n    address _investToken;\n    // @param _investAmount The amount of investment token to be used.\n    uint256 _investAmount;\n    // @param _stableToken The address of the stable token.\n    address _stableToken;\n    // @param _stableAmount The amount of stable token to be used.\n    uint256 _stableAmount;\n    // @param _impact The impact tolerance for the strategy.\n    uint256 _impact;\n    // @param _floorType The type of floor price (if floor is set).\n    FloorLegType _floorType;\n    // @param _floorValue The value of the floor price (if floor is set).\n    uint256 _floorValue;\n    // @param _liquidateOnFloor A flag to trigger liquidation when the floor price is reached (if floor is set)..\n    bool _liquidateOnFloor;\n    // @param _cancelOnFloor A flag to cancel the strategy when the floor price is reached (if floor is set).\n    bool _cancelOnFloor;\n    // @param _minimumLoss The minimum loss required for floor percentage to satisfy.\n    uint256 _minimumLoss;\n    // @param _buyType The type of buy action (if buy is set).\n    BuyLegType _buyType;\n    // @param _buyValue The value of the buy action (if buy is set).\n    uint256 _buyValue;\n    // @param _buyTwapTime The time interval for TWAP buying (if buy is set).\n    uint256 _buyTwapTime;\n    // @param _buyTwapTimeUnit The unit of time for TWAP buying .\n    TimeUnit _buyTwapTimeUnit;\n    // @param _btdValue The value for buying the dip (if buy is set).\n    uint256 _btdValue;\n    // @param _btdType The type of buy the dip action (if buy is set).\n    DIP_SPIKE _btdType;\n    // @param _buyDCAUnit The unit for buy DCA (Dollar-Cost Averaging) for stable amount (if buy is set).\n    DCA_UNIT _buyDCAUnit;\n    // @param _buyDCAValue The value for buy DCA.\n    uint256 _buyDCAValue;\n    // @param _sellType The type of sell action (if sell is set).\n    SellLegType _sellType;\n    // @param _sellValue The value of the sell action (if sell is set).\n    uint256 _sellValue;\n    // @param if sell DCA is selected, _highSellValue is used to trigger complete sell when the high sell value is reached (if sell is set).\n    uint256 _highSellValue;\n    // @param _minimumProfit The minimum profit to be generated during sell if sell profit percentage is set\n    uint256 _minimumProfit;\n    // @param _strValue The value of the str if it is set to true (if sell is set).\n    uint256 _strValue;\n    // @param _strType The type of str.\n    DIP_SPIKE _strType;\n    // @param _sellDCAUnit The unit for sell DCA (Dollar-Cost Averaging) for the invest amount (if sell is set).\n    DCA_UNIT _sellDCAUnit;\n    // @param _sellDCAValue The value for sell DCA.\n    uint256 _sellDCAValue;\n    // @param _sellTwapTime The time interval for TWAP selling (if sell is set).\n    uint256 _sellTwapTime;\n    //  @param _sellTwapTimeUnit The unit of time for TWAP selling (if sell is set).\n    TimeUnit _sellTwapTimeUnit;\n    // @param _completeOnSell A flag to complete the strategy on selling (if sell is set).\n    bool _completeOnSell;\n    // @param _current_price_sell The current price indicator is selected for sell\n    bool _current_price_sell;\n    // @param _current_price The current price indicator is selected for buy\n    bool _current_price_buy;\n}\n\n/**\n * @notice The `Strategy` struct defines the characteristics and status of a trading strategy.\n * @dev This struct encapsulates important data related to a trading strategy, including user ownership,\n *      strategy parameters, execution times, financial metrics, and its current status.\n * it is mostly used for internal computation\n */\n\nstruct Strategy {\n    //  @param user The address of the strategy owner.\n    address user;\n    // @param parameters The parameters that configure the behavior of the strategy\n    // as passed by the user and defined above\n    StrategyParameters parameters;\n    // to store invest amount to be sold when dca is chosen for percentage.\n    uint256 sellPercentageAmount;\n    // to store stable amount to be given when dca is chosen for percentage.\n    uint256 buyPercentageAmount;\n    // the invest amount based on which sellPercentageAmount is calculated\n    uint256 sellPercentageTotalAmount;\n    // the stable amount based on which buyPercentageAmount is calculated\n    uint256 buyPercentageTotalAmount;\n    //  @param sellTwapExecutedAt The timestamp of the last executed TWAP (Time-Weighted Average Price) sell.\n    //  if sell twap is set for the sell. Otherwise it remains 0\n    uint256 sellTwapExecutedAt;\n    //  @param buyTwapExecutedAt The timestamp of the last executed TWAP buy.\n    //  if buy Twap is set for btd. Otherwise it remains 0.\n    uint256 buyTwapExecutedAt;\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 investRoundIdForBTD;\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 stableRoundIdForBTD;\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 investRoundIdForSTR;\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 stableRoundIdForSTR;\n    // @param investPrice The price at which investment is made.\n    //While creating strategy it is set to the current price\n    uint256 investPrice;\n    //  @param profit The current profit generated by the strategy.\n    uint256 profit;\n    //  @param budget The available budget for the strategy.\n    // it is set at the starting of the strategy\n    uint256 budget;\n    // @param status The current status of the strategy.\n    Status status;\n}\n/**\n * @notice AppStorage is the central storage structure for this contract, holding essential data.\n * @dev This struct contains critical information used by the contract for operation.\n * It stores data such as function selectors, supported interfaces, the contract owner, strategy details,\n * Chainlink feed information, and more.\n */\n\nstruct AppStorage {\n    // maps function selectors to the facets that execute the functions.\n    // and maps the selectors to their position in the selectorSlots array.\n    // func selector => address facet, selector position\n    mapping(bytes4 => bytes32) facets;\n    // array of slots of function selectors.\n    // each slot holds 8 function selectors.\n    mapping(uint256 => bytes32) selectorSlots;\n    // The number of function selectors in selectorSlots\n    uint16 selectorCount;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address owner;\n    // next id to use for strategies\n    uint256 nextStrategyId;\n    // array of strategies\n    mapping(uint256 => Strategy) strategies;\n    // chainlink feeds - asset => USD feed\n    mapping(address => address) feeds;\n    // account => nonce\n    mapping(address => uint256) nonces;\n    // reentrancy status\n    ReentrancyStatus reentrancyStatus;\n    // sequencer uptime feed\n    address sequencerUptimeFeed;\n    // max stale period\n    uint256 maxStalePeriod;\n}\n\n/**\n * @title Swap\n * @dev A struct representing a swap or trade operation on a decentralized exchange (DEX).\n *  @param dex: The address of the DEX where the swap is to be executed.\n *  @param callData: Encoded data containing instructions for the swap on the specified DEX.\n */\nstruct Swap {\n    address dex;\n    bytes callData;\n}\n\n// Struct representing the parameters to update in a strategy\nstruct UpdateStruct {\n    uint256 sellValue;\n    uint256 buyValue;\n    uint256 strValue;\n    uint256 btdValue;\n    uint256 floorValue;\n    uint256 highSellValue;\n    uint256 buyTwapTime;\n    TimeUnit buyTwapTimeUnit;\n    uint256 buyDCAValue;\n    uint256 sellDCAValue;\n    uint256 sellTwapTime;\n    TimeUnit sellTwapTimeUnit;\n    bool toggleCompleteOnSell;\n    bool toggleLiquidateOnFloor;\n    bool toggleCancelOnFloor;\n    uint256 impact;\n    bool current_price_sell;\n    bool current_price_buy;\n    uint256 minimumLoss;\n    uint256 minimumProfit;\n}\n\n// struct for information regarding which token is added in the strategy and which deleted\nstruct TokensTransaction {\n    uint256 tokenSubstracted;\n    uint256 tokenAdded;\n    uint256 stableAmount;\n    uint256 investAmount;\n}\n"
    },
    "contracts/facets/BuyFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { AppStorage, Strategy, Status, DCA_UNIT, DIP_SPIKE, SellLegType, BuyLegType, FloorLegType, Swap, TokensTransaction } from \"../AppStorage.sol\";\nimport { LibSwap } from \"../libraries/LibSwap.sol\";\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, FloorGreaterThanPrice, WrongPreviousIDs, RoundDataDoesNotMatch, StrategyIsNotActive, BuyNotSet, BuyTwapNotSelected, PriceNotInRange } from \"../utils/GenericErrors.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport { LibTime } from \"../libraries/LibTime.sol\";\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\n\nerror BuyDCAIsSet();\nerror ExpectedTimeNotElapsed();\nerror BTDNotSelected();\nerror PriceIsGreaterThanBuyValue();\nerror PriceDippedBelowFloorValue();\nerror MinimumLossDetected();\n\n/**\n * @title TransferObject\n * @notice This struct represents an object used for transferring information related to a swap operation.\n * @dev The TransferObject struct is designed to encapsulate essential information related to a swap, facilitating the transfer of tokens.\n *\n * Struct Fields:\n * @param value: the quantity or value associated with the transfer.\n * @param dexSwap: A Swap enum indicating the type of decentralized exchange used for the swap operation.\n * @param price: the price of the invest token with respect to the stable token.\n * @param buyValue: the value associated with a buy operation within the strategy object.\n */\n\nstruct TransferObject {\n    uint256 value;\n    Swap dexSwap;\n    uint256 price;\n    uint256 buyValue;\n}\n\n/**\n * @title RoundIds\n * @notice This struct stores round Id for the transaction of invest and stable tokens.\n * Struct Fields:\n * @param investRoundId: the round Id of the invest token.\n * @param stableRoundId: the round Id of the stable token\n */\nstruct RoundIds {\n    uint80 investRoundId;\n    uint80 stableRoundId;\n}\n\n/**\n * @title BuyFacet\n * @notice This facet contains functions responsible for evaluating conditions necessary for executing buy actions.\n * @dev BuyFacet specializes in verifying conditions related to limit price buys and Dollar-Cost Averaging (DCA) buys,\n *      ensuring that the necessary criteria are met before executing a buy action.\n */\n\ncontract BuyFacet is Modifiers {\n    /**\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\n     * please look at AppStorage.sol for more detail\n     */\n    AppStorage internal s;\n\n    /**\n     * @notice Emitted when a buy action is executed for a trading strategy.\n     * @param strategyId The unique ID of the strategy where the buy action was executed.\n     * @param impact The allowable price impact percentage for the buy action.\n     * @param tokens tokens substracted and added into the users wallet\n     * @param investPrice the average price at which invest tokens were bought.\n     *@param stablePriceInUSD price of stable token in USD\n     */\n\n    event BuyExecuted(\n        uint256 indexed strategyId,\n        uint256 impact,\n        TokensTransaction tokens,\n        uint256 investPrice,\n        uint256 stablePriceInUSD\n    );\n\n    /**\n     * @notice Emitted when a Buy on Time-Weighted Average Price (TWAP) action is executed for a trading strategy using a specific DEX, call data, buy value, and execution time.\n     * @param strategyId The unique ID of the strategy where the Buy on TWAP action was executed.\n     * @param impact The allowable price impact percentage for the buy action.\n     * @param tokens tokens substracted and added into the users wallet\n     * @param investPrice the average price at which invest tokens were bought.\n     *@param stablePriceInUSD price of stable token in USD\n     */\n    event BuyTwapExecuted(\n        uint256 indexed strategyId,\n        uint256 impact,\n        TokensTransaction tokens,\n        uint256 investPrice,\n        uint256 stablePriceInUSD\n    );\n    /**\n     * @notice Emitted when a Buy The Dip (BTD) action is executed for a trading strategy using a specific DEX, call data, buy value, and execution time.\n     * @param strategyId The unique ID of the strategy where the BTD action was executed.\n     * @param impact The allowable price impact percentage for the buy action.\n     * @param tokens tokens substracted and added into the users wallet\n     * @param investPrice the average price at which invest tokens were bought.\n     * @param rounds the round Ids of invest and stable tokens.\n     */\n    event BTDExecuted(\n        uint256 indexed strategyId,\n        uint256 impact,\n        TokensTransaction tokens,\n        uint256 investPrice,\n        RoundIds rounds\n    );\n\n    /**\n     * @notice Emitted when a trade execution strategy is completed.\n     * @param strategyId The unique ID of the completed strategy.\n     * @param investTokenPrice The price of the invest token in USD.\n     * @param stableTokenPrice The price of the stable token in USD.\n     */\n    event StrategyCompleted(uint256 indexed strategyId, uint256 investTokenPrice, uint256 stableTokenPrice);\n\n    /**\n     * @notice Executes a buy action for a trading strategy based on specified conditions.\n     * @dev The function validates strategy parameters, executes the buy action, and updates the strategy state.\n     * @param strategyId The unique ID of the strategy for which the buy action is executed.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n    function executeBuy(uint256 strategyId, Swap calldata swap) external nonReentrant {\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        if (strategy.parameters._buyValue == 0) {\n            revert BuyNotSet();\n        }\n        if (strategy.parameters._btdValue > 0 || strategy.parameters._buyTwapTime > 0) {\n            revert BuyDCAIsSet();\n        }\n        if (strategy.parameters._stableAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n        (uint256 price, , ) = LibPrice.getPrice(strategy.parameters._investToken, strategy.parameters._stableToken);\n\n        uint256 value = executionBuyAmount(true, strategyId);\n\n        transferBuy(strategyId, TransferObject(value, swap, price, strategy.parameters._buyValue), strategy);\n\n        if (strategy.parameters._sellValue == 0 && strategy.parameters._floorValue == 0) {\n            strategy.status = Status.COMPLETED;\n            uint256 investPrice = LibPrice.getUSDPrice(strategy.parameters._investToken);\n            uint256 stablePrice = LibPrice.getUSDPrice(strategy.parameters._stableToken);\n            emit StrategyCompleted(strategyId, investPrice, stablePrice);\n        }\n    }\n\n    /**\n     * @notice Executes a Buy on Time-Weighted Average Price (TWAP) action for a trading strategy.\n     * @param strategyId The unique ID of the strategy to execute the Buy on TWAP action.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n    function executeBuyTwap(uint256 strategyId, Swap calldata swap) external nonReentrant {\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        if (strategy.parameters._buyTwapTime == 0) {\n            revert BuyTwapNotSelected();\n        }\n        if (strategy.parameters._stableAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        (uint256 price, , ) = LibPrice.getPrice(strategy.parameters._investToken, strategy.parameters._stableToken);\n\n        uint256 timeToExecute = LibTime.convertToSeconds(\n            strategy.parameters._buyTwapTime,\n            strategy.parameters._buyTwapTimeUnit\n        );\n\n        bool execute = LibTime.getTimeDifference(block.timestamp, strategy.buyTwapExecutedAt, timeToExecute);\n\n        if (!execute) {\n            revert ExpectedTimeNotElapsed();\n        }\n\n        uint256 value = executionBuyAmount(false, strategyId);\n\n        transferBuy(strategyId, TransferObject(value, swap, price, strategy.parameters._buyValue), strategy);\n        strategy.buyTwapExecutedAt = block.timestamp;\n        if (\n            strategy.parameters._sellValue == 0 &&\n            strategy.parameters._floorValue == 0 &&\n            strategy.parameters._stableAmount == 0\n        ) {\n            strategy.status = Status.COMPLETED;\n            uint256 investPrice = LibPrice.getUSDPrice(strategy.parameters._investToken);\n            uint256 stablePrice = LibPrice.getUSDPrice(strategy.parameters._stableToken);\n            emit StrategyCompleted(strategyId, investPrice, stablePrice);\n        }\n    }\n\n    /**\n     * @notice Executes a Buy-The-Dip (BTD) trading strategy action within a specified price range.\n     * This function allows the strategy to buy the invest token when its price decreases to a certain target value, following a specified DIP strategy type.\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\n     * @param fromInvestRoundId The starting invest round ID for monitoring price fluctuations.\n     * @param toInvestRoundId The ending invest round ID for monitoring price fluctuations.\n     * @param fromStableRoundId The starting stable round ID for monitoring price fluctuations.\n     * @param toStableRoundId The ending stable round ID for monitoring price fluctuations.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n\n    function executeBTD(\n        uint256 strategyId,\n        uint80 fromInvestRoundId,\n        uint80 fromStableRoundId,\n        uint80 toInvestRoundId,\n        uint80 toStableRoundId,\n        Swap calldata swap\n    ) external nonReentrant {\n        Strategy storage strategy = s.strategies[strategyId];\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        if (strategy.parameters._btdValue == 0) {\n            revert BTDNotSelected();\n        }\n        if (strategy.parameters._stableAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        checkRoundPrices(strategyId, price, fromInvestRoundId, fromStableRoundId, toInvestRoundId, toStableRoundId);\n\n        strategy.investRoundIdForBTD = investRoundId;\n        strategy.stableRoundIdForBTD = stableRoundId;\n\n        uint256 value = executionBuyAmount(false, strategyId);\n\n        transferBuy(strategyId, TransferObject(value, swap, price, strategy.parameters._buyValue), strategy);\n        if (\n            strategy.parameters._sellValue == 0 &&\n            strategy.parameters._floorValue == 0 &&\n            strategy.parameters._stableAmount == 0\n        ) {\n            strategy.status = Status.COMPLETED;\n            uint256 investPrice = LibPrice.getUSDPrice(strategy.parameters._investToken);\n            uint256 stablePrice = LibPrice.getUSDPrice(strategy.parameters._stableToken);\n            emit StrategyCompleted(strategyId, investPrice, stablePrice);\n        }\n    }\n\n    /**\n     * @notice Calculate the effective value for a buy action in a trading strategy.\n     * @param stableAmount Boolean flag indicating whether to consider the entire stable token amount.\n     * @param strategyId The unique ID of the strategy for which to calculate the buy value.\n     * @return The calculated buy value based on the specified parameters.\n     */\n    function executionBuyAmount(bool stableAmount, uint256 strategyId) public view returns (uint256) {\n        uint256 amount;\n        Strategy memory strategy = s.strategies[strategyId];\n        if (stableAmount) {\n            amount = strategy.parameters._stableAmount;\n        } else if (strategy.parameters._buyDCAUnit == DCA_UNIT.FIXED) {\n            amount = (strategy.parameters._stableAmount > strategy.parameters._buyDCAValue)\n                ? strategy.parameters._buyDCAValue\n                : strategy.parameters._stableAmount;\n        } else if (strategy.parameters._buyDCAUnit == DCA_UNIT.PERCENTAGE) {\n            amount = (strategy.parameters._stableAmount > strategy.buyPercentageAmount)\n                ? strategy.buyPercentageAmount\n                : strategy.parameters._stableAmount;\n        }\n\n        return amount;\n    }\n\n    /**\n     * @notice Internal function to execute a \"Buy\" action within a specified price range.\n     * @dev This function transfers assets from stable tokens to investment tokens on a DEX.\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\n     * @param transferObject The TransferBuy struct containing the parameters for executing the buy action.\n     * @param strategy The Strategy struct containing the parameters for the trading strategy.\n     */\n    function transferBuy(uint256 strategyId, TransferObject memory transferObject, Strategy storage strategy) internal {\n        if (transferObject.price > transferObject.buyValue) {\n            revert PriceIsGreaterThanBuyValue();\n        }\n\n        LibSwap.SwapData memory swap = LibSwap.SwapData(\n            transferObject.dexSwap.dex,\n            strategy.parameters._stableToken,\n            strategy.parameters._investToken,\n            transferObject.value,\n            transferObject.dexSwap.callData,\n            strategy.user\n        );\n\n        uint256 toTokenAmount = LibSwap.swap(swap);\n\n        uint256 rate = LibTrade.calculateExchangeRate(\n            strategy.parameters._investToken,\n            toTokenAmount,\n            transferObject.value\n        );\n\n        if (rate > transferObject.buyValue) {\n            revert InvalidExchangeRate(transferObject.buyValue, rate);\n        }\n\n        if (strategy.parameters._floorValue > 0) {\n            if (strategy.parameters._floorType == FloorLegType.LIMIT_PRICE && strategy.parameters._floorValue >= rate) {\n                revert FloorGreaterThanPrice();\n            } else if (strategy.parameters._floorType == FloorLegType.DECREASE_BY) {\n                uint256 currentInvestmentValue = (strategy.parameters._investAmount * transferObject.price) /\n                    10 ** IERC20Metadata(strategy.parameters._investToken).decimals();\n                uint256 totalInvested = (strategy.parameters._investAmount * strategy.investPrice) /\n                    10 ** IERC20Metadata(strategy.parameters._investToken).decimals();\n\n                if (totalInvested > currentInvestmentValue) {\n                    //how much loss in %\n                    uint256 lossPercentage = ((totalInvested - currentInvestmentValue) * LibTrade.MAX_PERCENTAGE) /\n                        totalInvested;\n                    if (lossPercentage >= strategy.parameters._floorValue) {\n                        if (\n                            strategy.parameters._minimumLoss > 0 &&\n                            totalInvested - currentInvestmentValue >= strategy.parameters._minimumLoss\n                        ) {\n                            revert MinimumLossDetected();\n                        } else {\n                            revert PriceDippedBelowFloorValue();\n                        }\n                    }\n                }\n            }\n        }\n\n        strategy.parameters._stableAmount -= transferObject.value;\n        uint256 previousValue = strategy.parameters._investAmount * strategy.investPrice;\n        strategy.parameters._investAmount = strategy.parameters._investAmount + toTokenAmount;\n\n        strategy.investPrice =\n            (previousValue + (toTokenAmount * rate)) /\n            strategy.parameters._investAmount;\n\n        uint256 impact = LibTrade.validateImpact(rate, transferObject.price, strategy.parameters._impact, true);\n        uint256 stablePrice = LibPrice.getUSDPrice(strategy.parameters._stableToken);\n\n        if (strategy.parameters._sellDCAUnit == DCA_UNIT.PERCENTAGE) {\n            strategy.sellPercentageAmount =\n                (strategy.parameters._sellDCAValue * strategy.parameters._investAmount) /\n                LibTrade.MAX_PERCENTAGE;\n            strategy.sellPercentageTotalAmount = strategy.parameters._investAmount;\n        }\n\n        if (\n            strategy.parameters._buyValue > 0 &&\n            strategy.parameters._btdValue == 0 &&\n            strategy.parameters._buyTwapTime == 0\n        ) {\n            emit BuyExecuted(\n                strategyId,\n                impact,\n                TokensTransaction({\n                    tokenSubstracted: transferObject.value,\n                    tokenAdded: toTokenAmount,\n                    stableAmount: strategy.parameters._stableAmount,\n                    investAmount: strategy.parameters._investAmount\n                }),\n                strategy.investPrice,\n                stablePrice\n            );\n        } else if (strategy.parameters._btdValue > 0) {\n            emit BTDExecuted(\n                strategyId,\n                impact,\n                TokensTransaction({\n                    tokenSubstracted: transferObject.value,\n                    tokenAdded: toTokenAmount,\n                    stableAmount: strategy.parameters._stableAmount,\n                    investAmount: strategy.parameters._investAmount\n                }),\n                strategy.investPrice,\n                RoundIds({ investRoundId: strategy.investRoundIdForBTD, stableRoundId: strategy.stableRoundIdForBTD })\n            );\n        } else if (strategy.parameters._buyTwapTime > 0) {\n            emit BuyTwapExecuted(\n                strategyId,\n                impact,\n                TokensTransaction({\n                    tokenSubstracted: transferObject.value,\n                    tokenAdded: toTokenAmount,\n                    stableAmount: strategy.parameters._stableAmount,\n                    investAmount: strategy.parameters._investAmount\n                }),\n                strategy.investPrice,\n                stablePrice\n            );\n        }\n    }\n\n    /**\n     * @notice Internal function to check if there is a data mismatch between price rounds for a strategy.\n     * @dev This function ensures that the price fluctuations between specified rounds adhere to strategy parameters.\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\n     * @param fromInvestRoundId The round ID for the investment token's price data to start checking from.\n     * @param fromStableRoundId The round ID for the stable token's price data to start checking from.\n     * @param toInvestRoundId The round ID for the investment token's price data to check up to.\n     * @param toStableRoundId The round ID for the stable token's price data to check up to.\n     */\n    function checkRoundPrices(\n        uint256 strategyId,\n        uint256 price,\n        uint80 fromInvestRoundId,\n        uint80 fromStableRoundId,\n        uint80 toInvestRoundId,\n        uint80 toStableRoundId\n    ) internal view {\n        Strategy memory strategy = s.strategies[strategyId];\n\n        if (toInvestRoundId < fromInvestRoundId || toStableRoundId < fromStableRoundId) {\n            revert WrongPreviousIDs();\n        }\n\n        if (\n            strategy.investRoundIdForBTD > fromInvestRoundId ||\n            strategy.investRoundIdForBTD > toInvestRoundId ||\n            strategy.stableRoundIdForBTD > fromStableRoundId ||\n            strategy.stableRoundIdForBTD > toStableRoundId\n        ) {\n            revert WrongPreviousIDs();\n        }\n\n        uint256 fromPrice = LibPrice.getRoundData(\n            fromInvestRoundId,\n            fromStableRoundId,\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n        uint256 toPrice = LibPrice.getRoundData(\n            toInvestRoundId,\n            toStableRoundId,\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        if (\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE ||\n                strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY)\n        ) {\n            if (price < toPrice) {\n                revert PriceNotInRange();\n            }\n        }\n        if (\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE ||\n                strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            if (price > toPrice) {\n                revert PriceNotInRange();\n            }\n        }\n\n        uint256 btdValue = strategy.parameters._btdValue;\n        uint256 fromToPriceDifference;\n        uint256 toFromPriceDifference;\n\n        if (\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE ||\n                strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY)\n        ) {\n            if (toPrice < fromPrice) {\n                revert RoundDataDoesNotMatch();\n            } else {\n                toFromPriceDifference = toPrice - fromPrice;\n            }\n        }\n        if (\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE ||\n                strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            if (toPrice > fromPrice) {\n                revert RoundDataDoesNotMatch();\n            } else {\n                fromToPriceDifference = fromPrice - toPrice;\n            }\n        }\n\n        if ((strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE) && (btdValue > toFromPriceDifference)) {\n            revert RoundDataDoesNotMatch();\n        } else if ((strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE) && (btdValue > fromToPriceDifference)) {\n            revert RoundDataDoesNotMatch();\n        } else if (\n            (strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY) &&\n            (btdValue > ((toFromPriceDifference * 10000) / fromPrice))\n        ) {\n            revert RoundDataDoesNotMatch();\n        } else if (\n            (strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY) &&\n            (btdValue > ((fromToPriceDifference * 10000) / fromPrice))\n        ) {\n            revert RoundDataDoesNotMatch();\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/libraries/LibAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferFailed } from \"../utils/GenericErrors.sol\";\n\n/**\n * @title LibAsset\n * @dev This library provides functions for interacting with ERC20 assets.\n */\nlibrary LibAsset {\n    uint256 private constant MAX_UINT = type(uint256).max;\n\n    /**\n     * @notice Approves a specified amount of an asset for a spender if the current allowance is insufficient.\n     * @param asset The address of the asset.\n     * @param spender The address of the spender.\n     * @param amount The amount to approve.\n     */\n    function maxApprove(address asset, address spender, uint256 amount) internal {\n        if (IERC20(asset).allowance(address(this), spender) < amount) {\n            SafeERC20.safeApprove(IERC20(asset), spender, 0);\n            SafeERC20.safeApprove(IERC20(asset), spender, amount);\n        }\n    }\n\n    /**\n     * @notice Transfers a specified amount of an asset from one address to another.\n     * @param asset The address of the asset.\n     * @param from The sender's address.\n     * @param to The recipient's address.\n     * @param amount The amount to transfer.\n     */\n    function transferFrom(address asset, address from, address to, uint256 amount) internal {\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\n        SafeERC20.safeTransferFrom(IERC20(asset), from, to, amount);\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\n            revert TransferFailed();\n        }\n    }\n\n    /**\n     * @notice Transfers a specified amount of an asset to a recipient.\n     * @param asset The address of the asset.\n     * @param to The recipient's address.\n     * @param amount The amount to transfer.\n     */\n    function transfer(address asset, address to, uint256 amount) internal {\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\n        SafeERC20.safeTransfer(IERC20(asset), to, amount);\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\n            revert TransferFailed();\n        }\n    }\n\n    /**\n     * @notice Retrieves the balance of a specified asset for a given account.\n     * @param asset The address of the asset.\n     * @param account The account for which to check the balance.\n     * @return The balance of the asset for the specified account.\n     */\n    function balanceOf(address asset, address account) internal view returns (uint256) {\n        return IERC20(asset).balanceOf(account);\n    }\n}\n"
    },
    "contracts/libraries/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    // -------------------------\n    /**\n     * @notice Slice a portion of a bytes array.\n     * @param _bytes The input bytes array.\n     * @param _start The starting index of the slice.\n     * @param _length The length of the slice.\n     * @return tempBytes A new bytes array containing the sliced data.\n     */\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) revert SliceOverflow();\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Convert a portion of a bytes array to an address.\n     * @param _bytes The input bytes array.\n     * @param _start The starting index of the address data.\n     * @return tempAddress The address extracted from the bytes array.\n     */\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        if (_bytes.length < _start + 20) {\n            revert AddressOutOfBounds();\n        }\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\n    /**\n     * @notice Convert a uint256 to its hexadecimal representation as a string.\n     * @param value The uint256 value to convert.\n     * @param length The desired length of the hexadecimal string.\n     * @return A string containing the hexadecimal representation of the uint256 value.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    function diamondStorage() internal pure returns (AppStorage storage s) {\n        assembly {\n            s.slot := 0\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        AppStorage storage s = diamondStorage();\n        address previousOwner = s.owner;\n        s.owner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        AppStorage storage s = diamondStorage();\n        uint256 originalSelectorCount = s.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            s.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        AppStorage storage s = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"LibDiamondCut: Can't add function that already exists\"\n                );\n                // add facet for selector\n                s.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot =\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    s.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"LibDiamondCut: Can't replace function with same function\"\n                );\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                s.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = s.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = s.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\n                    );\n                    // only useful if immutable functions exist\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"LibDiamondCut: Can't remove immutable function\"\n                    );\n                    // replace selector with last selector in s.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        s.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.facets[lastSelector]);\n                    }\n                    delete s.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete s.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport { LibDiamond } from \"./LibDiamond.sol\";\nimport { InvalidPrice, FeedNotFound } from \"../utils/GenericErrors.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\nerror SequencerDown();\nerror GracePeriodNotOver();\nerror PriceExpired();\n\n/**\n * @title LibPrice\n * @dev This library provides functions for fetching and manipulating asset prices.\n */\nlibrary LibPrice {\n    address constant USD_QUOTE = 0x0000000000000000000000000000000000000348;\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n\n    /**\n     * @notice Get the current price and round IDs of an asset relative to a unit.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The current price of the asset in terms of the unit.\n     * @return investRoundId The round ID of the asset's price feed.\n     * @return stableRoundId The round ID of the unit's price feed.\n     */\n    function getPrice(address asset, address unit) internal view returns (uint256 price, uint80, uint80) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        AggregatorV2V3Interface sequencerUptimeFeed = AggregatorV2V3Interface(s.sequencerUptimeFeed);\n\n        if (address(sequencerUptimeFeed) != address(0)) {\n            (\n                ,\n                /*uint80 roundID*/ int256 answer,\n                uint256 startedAt /*uint256 updatedAt*/ /*uint80 answeredInRound*/,\n                ,\n\n            ) = sequencerUptimeFeed.latestRoundData();\n\n            // Answer == 0: Sequencer is up\n            // Answer == 1: Sequencer is down\n            bool isSequencerUp = answer == 0;\n            if (!isSequencerUp) {\n                revert SequencerDown();\n            }\n\n            // Make sure the grace period has passed after the\n            // sequencer is back up.\n            uint256 timeSinceUp = block.timestamp - startedAt;\n            if (timeSinceUp <= GRACE_PERIOD_TIME) {\n                revert GracePeriodNotOver();\n            }\n        }\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (uint80 investRoundId, int256 assetPrice, , uint256 investUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[asset])\n            .latestRoundData();\n        (uint80 stableRoundId, int256 unitPrice, , uint256 stableUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[unit])\n            .latestRoundData();\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        if (\n            block.timestamp - investUpdatedAt > s.maxStalePeriod || block.timestamp - stableUpdatedAt > s.maxStalePeriod\n        ) {\n            revert PriceExpired();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return (price, investRoundId, stableRoundId);\n    }\n\n    /**\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\n     * @param investRoundId The round ID of the asset's price feed.\n     * @param stableRoundId The round ID of the unit's price feed.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\n     */\n    function getRoundData(\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        address asset,\n        address unit\n    ) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(investRoundId);\n        (, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).getRoundData(stableRoundId);\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        uint256 price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return price;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @return price The price of the asset in USD\n     */\n    function getUSDPrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0)) {\n            revert FeedNotFound();\n        }\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\n        if (assetPrice == 0) {\n            revert InvalidPrice();\n        }\n        return uint256(assetPrice);\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @param roundId the round for which price is required.\n     * @return price The price of the asset based on round Id\n     */\n    function getPriceBasedOnRoundId(address asset, uint80 roundId) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0)) {\n            revert FeedNotFound();\n        }\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(roundId);\n        if (assetPrice == 0) {\n            revert InvalidPrice();\n        }\n        return uint256(assetPrice);\n    }\n}\n"
    },
    "contracts/libraries/LibSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibAsset } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\nimport { NoSwapFromZeroBalance, InsufficientBalance, SwapFailed } from \"../utils/GenericErrors.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title LibSwap\n * @dev This library provides functions for executing asset swaps.\n */\nlibrary LibSwap {\n    struct SwapData {\n        address callTo; // The address of the contract or dex to execute the swap on.\n        address fromAsset; // The address of the asset to swap from.\n        address toAsset; // The address of the asset to receive.\n        uint256 fromAmount; // The amount of the 'fromAsset' to swap.\n        bytes callData; // The call data for the swap.\n        address user; // The user initiating the swap.\n    }\n\n    /**\n     * @notice Emitted when an asset swap has been executed successfully.\n     * @param dex The address of the contract or dex used for the swap.\n     * @param fromAsset The address of the asset swapped from.\n     * @param toAsset The address of the asset received in the swap.\n     * @param fromAmount The amount of 'fromAsset' that was swapped.\n     * @param receivedAmount The amount of 'toAsset' received in the swap.\n     * @param account The address of the user account that initiated the swap.\n     */\n\n    event AssetSwapped(\n        address dex,\n        address fromAsset,\n        address toAsset,\n        uint256 fromAmount,\n        uint256 receivedAmount,\n        address account\n    );\n\n    /**\n     * @notice Execute an asset swap from one asset to another using the provided swap data.\n     * @param _swap The swap data containing all necessary information for the swap.\n     * @return The amount of 'toAsset' received in the swap.\n     * @dev This function transfers 'fromAsset' from the user to this contract, executes the swap,\n     * and transfers the received 'toAsset' back to the user.\n     */\n    function swap(SwapData memory _swap) internal returns (uint256) {\n        uint256 fromAmount = _swap.fromAmount;\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\n\n        LibAsset.transferFrom(_swap.fromAsset, _swap.user, address(this), fromAmount);\n\n        uint256 initialReceivingAssetBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\n\n        LibAsset.maxApprove(_swap.fromAsset, _swap.callTo, _swap.fromAmount);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swap.callTo.call(_swap.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        uint256 newBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\n        uint256 receivedAmount = newBalance - initialReceivingAssetBalance;\n\n        if (receivedAmount == 0) {\n            revert SwapFailed();\n        }\n\n        LibAsset.transfer(_swap.toAsset, _swap.user, receivedAmount);\n\n        emit AssetSwapped(_swap.callTo, _swap.fromAsset, _swap.toAsset, _swap.fromAmount, receivedAmount, _swap.user);\n\n        return receivedAmount;\n    }\n}\n"
    },
    "contracts/libraries/LibTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { TimeUnit } from \"../AppStorage.sol\";\n\nerror InvalidUnit();\n\n/**\n * @title LibTime\n * @dev This library provides functions for time-related calculations.\n */\nlibrary LibTime {\n    /**\n     * @notice Convert a given time value to seconds based on the specified time unit.\n     * @param time The time value to convert.\n     * @param unit The time unit (e.g., TimeUnit.HOURS, TimeUnit.DAYS).\n     * @return The time value converted to seconds.\n     * @dev Reverts with `InvalidUnit` error if an unsupported time unit is provided.\n     */\n    function convertToSeconds(uint256 time, TimeUnit unit) internal pure returns (uint256) {\n        if (unit == TimeUnit.HOURS) {\n            return time * 3600;\n        } else if (unit == TimeUnit.DAYS) {\n            return time * 86400;\n        } else {\n            revert InvalidUnit();\n        }\n    }\n\n    /**\n     * @notice Check if a time difference condition is met.\n     * @param presentTime The current time.\n     * @param executionTime The execution time to consider (0 for immediate execution).\n     * @param targetTime The target time for comparison.\n     * @return A boolean indicating whether the time difference condition is met.\n     */\n\n    function getTimeDifference(\n        uint256 presentTime,\n        uint256 executionTime,\n        uint256 targetTime\n    ) internal pure returns (bool) {\n        if (executionTime == 0) {\n            return true;\n        }\n        bool timeDifference = targetTime <= presentTime - executionTime ? true : false;\n        return timeDifference;\n    }\n}\n"
    },
    "contracts/libraries/LibTrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { HighImpact } from \"../utils/GenericErrors.sol\";\n\n/**\n * @title LibTrade\n * @dev This library provides functions for calculating exchange rates and validating slippage.\n */\nlibrary LibTrade {\n    uint256 public constant MAX_PERCENTAGE = 10000;\n\n    /**\n    @dev Calculate exchange rate given input and output amounts\n    @param fromAsset Address of the asset that was used to swap\n    @param fromAmount Amount of the asset that was used to swap\n    @param toAmount Amount of the asset that was received from swap\n    @return uint256 Returns the exchange rate in toAsset unit\n     */\n    function calculateExchangeRate(\n        address fromAsset,\n        uint256 fromAmount,\n        uint256 toAmount\n    ) internal view returns (uint256) {\n        IERC20Metadata _fromToken = IERC20Metadata(fromAsset);\n        uint256 fromDecimals = _fromToken.decimals();\n        return ((toAmount * (10 ** fromDecimals)) / fromAmount);\n    }\n\n    /**\n     * @notice Validate the Impact of a swap.\n     * @param exchangeRate The calculated exchange rate for the swap.\n     * @param price The reference price for the swap.\n     * @param maxImpact The maximum allowed Impact percentage.\n     * @param isBuy A flag indicating if it's a buy operation (true) or not (false).\n     * @return uint256 Returns the calculated Impact percentage.\n     */\n    function validateImpact(\n        uint256 exchangeRate,\n        uint256 price,\n        uint256 maxImpact,\n        bool isBuy\n    ) internal pure returns (uint256) {\n        uint256 impact = (price * MAX_PERCENTAGE) / exchangeRate;\n\n        if (isBuy && impact < MAX_PERCENTAGE && MAX_PERCENTAGE - impact > maxImpact) revert HighImpact();\n        if (!isBuy && impact > MAX_PERCENTAGE && impact - MAX_PERCENTAGE > maxImpact) revert HighImpact();\n        uint256 impactValue;\n        if (isBuy && impact < MAX_PERCENTAGE) {\n            impactValue = MAX_PERCENTAGE - impact;\n        } else if (!isBuy && impact > MAX_PERCENTAGE) {\n            impactValue = impact - MAX_PERCENTAGE;\n        }\n        return impactValue;\n    }\n}\n"
    },
    "contracts/libraries/LibUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"./LibBytes.sol\";\n\n/**\n * @title LibUtil\n * @dev This library provides utility functions for working with revert messages.\n */\nlibrary LibUtil {\n    using LibBytes for bytes;\n\n    /**\n     * @notice Get a revert message from transaction result data.\n     * @param _res The transaction result data to extract the revert message from.\n     * @return string The revert message or a \"Transaction reverted silently\" message if none is found.\n     */\n    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /**\n     * @notice Used the get the ID of the current chain.\n     * @return id The chain ID\n     */\n    function getChainID() internal view returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n}\n"
    },
    "contracts/utils/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nerror NoSwapFromZeroBalance();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror SwapFailed();\nerror TransferFailed();\nerror InvalidExchangeRate(uint256 required, uint256 actual);\nerror InvalidPrice();\nerror InvalidImpact();\nerror HighImpact();\nerror InvalidInvestToken();\nerror InvalidStableToken();\nerror TokensMustDiffer();\nerror AtLeastOneOptionRequired();\nerror InvalidInvestAmount();\nerror FloorValueZero();\nerror InvalidSellType();\nerror InvalidSellValue();\nerror BuyAndSellAtMisorder();\nerror InvalidStableAmount();\nerror InvalidBuyType();\nerror InvalidBuyValue();\nerror InvalidFloorValue();\nerror InvalidFloorType();\nerror InvalidSellTypeDCA();\nerror FloorValueGreaterThanBuyValue();\nerror FloorValueGreaterThanSellValue();\nerror BothBuyTwapAndBTD();\nerror BuyDCAWithoutBuy();\nerror BuyTwapTimeInvalid();\nerror BuyTwapTimeUnitNotSelected();\nerror BothSellTwapAndSTR();\nerror SellDCAWithoutSell();\nerror SellTwapTimeUnitNotSelected();\nerror SellTwapTimeInvalid();\nerror SellTwapOrStrWithoutSellDCAUnit();\nerror SellDCAUnitWithoutSellDCAValue();\nerror StrWithoutStrType();\nerror BTDWithoutBTDType();\nerror BuyDCAWithoutBuyDCAUnit();\nerror BuyDCAUnitWithoutBuyDCAValue();\nerror InvalidHighSellValue();\nerror SellDCAValueRangeIsNotValid();\nerror DCAValueShouldBeLessThanIntitialAmount();\nerror BuyDCAValueRangeIsNotValid();\nerror OrphandStrategy();\nerror BuyNeverExecute();\nerror FloorGreaterThanPrice();\nerror FeedNotFound();\nerror WrongPreviousIDs();\nerror RoundDataDoesNotMatch();\nerror StrategyIsNotActive();\nerror InvalidNonce();\nerror InvalidSigner();\nerror AlreadyCancelled();\nerror BuyNotSet();\nerror SellNotSelected();\nerror PercentageNotInRange();\nerror BuyTwapNotSelected();\nerror SellTwapNotSelected();\nerror FloorNotSet();\nerror ReentrancyGuardReentrantCall();\nerror PriceNotInRange();\n"
    },
    "contracts/utils/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { AppStorage, FloorLegType, BuyLegType, SellLegType, TimeUnit, DIP_SPIKE, DCA_UNIT, ReentrancyStatus } from \"../AppStorage.sol\";\nimport { ReentrancyGuardReentrantCall } from \"./GenericErrors.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\nabstract contract Modifiers {\n    /// @notice 100% = 100000 -> 2 decimals\n\n    modifier onlyOwner() {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        require(msg.sender == s.owner, \"Modifiers: Must be contract owner\");\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        // On the first call to nonReentrant, s.reentrancyStatus will be ReentrancyStatus.NOT_ENTERED\n        if (s.reentrancyStatus == ReentrancyStatus.ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        s.reentrancyStatus = ReentrancyStatus.ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        s.reentrancyStatus = ReentrancyStatus.NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        return s.reentrancyStatus == ReentrancyStatus.ENTERED;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
