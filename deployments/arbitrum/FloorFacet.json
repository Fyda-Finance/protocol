{
  "address": "0x0e375d97C9C695b51f19b64DF71940dB2Cb68626",
  "abi": [
    {
      "inputs": [],
      "name": "FeedNotFound",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "FloorNotSet",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "GracePeriodNotOver",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "HighImpact",
      "type": "error"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "required",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "actual",
          "type": "uint256"
        }
      ],
      "name": "InvalidExchangeRate",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidPrice",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MinimumLossRequired",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoSwapFromZeroBalance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PriceExpired",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "PriceIsGreaterThanFloorValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ReentrancyGuardReentrantCall",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SequencerDown",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SliceOutOfBounds",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SliceOverflow",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "StrategyIsNotActive",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "SwapFailed",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "TransferFailed",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "dex",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "fromAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "toAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fromAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "receivedAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "AssetSwapped",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "strategyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "impact",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "tokenSubstracted",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenAdded",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "stableAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "investAmount",
              "type": "uint256"
            }
          ],
          "indexed": false,
          "internalType": "struct TokensTransaction",
          "name": "tokens",
          "type": "tuple"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stablePriceInUSD",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investPrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "profit",
          "type": "uint256"
        }
      ],
      "name": "FloorExecuted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "uint256",
          "name": "strategyId",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investTokenPrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "stableTokenPrice",
          "type": "uint256"
        }
      ],
      "name": "StrategyCancelled",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "strategyId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "dex",
              "type": "address"
            },
            {
              "internalType": "bytes",
              "name": "callData",
              "type": "bytes"
            }
          ],
          "internalType": "struct Swap",
          "name": "dexSwap",
          "type": "tuple"
        }
      ],
      "name": "executeFloor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6687338ca71b747bea9d9cd2d6f946b3a96e16067342ba540a8b67c712e05fd9",
  "receipt": {
    "to": null,
    "from": "0x1223a30278B980A2b04c51C56E045a0D9E976851",
    "contractAddress": "0x0e375d97C9C695b51f19b64DF71940dB2Cb68626",
    "transactionIndex": 1,
    "gasUsed": "25484090",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7ddd6759be1e294c38b2addd95234a3147875faa998db50fd0ff6309d95d63a4",
    "transactionHash": "0x6687338ca71b747bea9d9cd2d6f946b3a96e16067342ba540a8b67c712e05fd9",
    "logs": [],
    "blockNumber": 159783679,
    "cumulativeGasUsed": "25484090",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "ebfde796c2155f1121103a9310ece588",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"FeedNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FloorNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"GracePeriodNotOver\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"HighImpact\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"}],\"name\":\"InvalidExchangeRate\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidPrice\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinimumLossRequired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoSwapFromZeroBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceExpired\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"PriceIsGreaterThanFloorValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ReentrancyGuardReentrantCall\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SequencerDown\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOutOfBounds\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SliceOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"StrategyIsNotActive\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SwapFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"TransferFailed\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"dex\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"fromAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"toAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fromAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AssetSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"impact\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"tokenSubstracted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAdded\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"stableAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"investAmount\",\"type\":\"uint256\"}],\"indexed\":false,\"internalType\":\"struct TokensTransaction\",\"name\":\"tokens\",\"type\":\"tuple\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stablePriceInUSD\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profit\",\"type\":\"uint256\"}],\"name\":\"FloorExecuted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investTokenPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"stableTokenPrice\",\"type\":\"uint256\"}],\"name\":\"StrategyCancelled\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"dex\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"callData\",\"type\":\"bytes\"}],\"internalType\":\"struct Swap\",\"name\":\"dexSwap\",\"type\":\"tuple\"}],\"name\":\"executeFloor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"FloorFacet specializes in verifying floor price conditions, handling liquidation actions when the floor price is reached,      ensuring that the necessary criteria are met before taking any actions and also cancelling the strategy if provided.\",\"events\":{\"AssetSwapped(address,address,address,uint256,uint256,address)\":{\"params\":{\"account\":\"The address of the user account that initiated the swap.\",\"dex\":\"The address of the contract or dex used for the swap.\",\"fromAmount\":\"The amount of 'fromAsset' that was swapped.\",\"fromAsset\":\"The address of the asset swapped from.\",\"receivedAmount\":\"The amount of 'toAsset' received in the swap.\",\"toAsset\":\"The address of the asset received in the swap.\"}},\"FloorExecuted(uint256,uint256,(uint256,uint256,uint256,uint256),uint256,uint256,uint256)\":{\"params\":{\"impact\":\"The allowable price impact percentage for the buy action.\",\"investPrice\":\"the average price at which invest tokens were bought.\",\"profit\":\"it is the profit made by the strategy.\",\"stablePriceInUSD\":\"price of stable token in USD\",\"strategyId\":\"The unique ID of the strategy where the floor execution is initiated.\",\"tokens\":\"tokens substracted and added into the users wallet\"}},\"StrategyCancelled(uint256,uint256,uint256)\":{\"params\":{\"investTokenPrice\":\"The price of the invest token in USD.\",\"stableTokenPrice\":\"The price of the stable token in USD.\",\"strategyId\":\"The unique ID of the cancelled strategy.\"}}},\"kind\":\"dev\",\"methods\":{\"executeFloor(uint256,(address,bytes))\":{\"details\":\"This function performs a floor price check and, if the strategy's parameters meet the required conditions,      it may execute a liquidation of assets. Liquidation occurs if the strategy's floor price is reached and      liquidation is enabled in the strategy parameters.\",\"params\":{\"dexSwap\":\"The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\",\"strategyId\":\"The unique ID of the strategy to execute the floor check for.\"}}},\"title\":\"FloorFacet\",\"version\":1},\"userdoc\":{\"events\":{\"AssetSwapped(address,address,address,uint256,uint256,address)\":{\"notice\":\"Emitted when an asset swap has been executed successfully.\"},\"FloorExecuted(uint256,uint256,(uint256,uint256,uint256,uint256),uint256,uint256,uint256)\":{\"notice\":\"Emitted when a floor execution is initiated for a trading strategy.\"},\"StrategyCancelled(uint256,uint256,uint256)\":{\"notice\":\"Emitted when a trade execution strategy is cancelled.\"}},\"kind\":\"user\",\"methods\":{\"executeFloor(uint256,(address,bytes))\":{\"notice\":\"Execute a floor price check and potential liquidation for a trading strategy.\"}},\"notice\":\"This facet contains functions responsible for evaluating conditions related to the floor price and liquidation events.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/facets/FloorFacet.sol\":\"FloorFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@chainlink/contracts/src/v0.8/Denominations.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\nlibrary Denominations {\\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\\n\\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\\n  address public constant USD = address(840);\\n  address public constant GBP = address(826);\\n  address public constant EUR = address(978);\\n  address public constant JPY = address(392);\\n  address public constant KRW = address(410);\\n  address public constant CNY = address(156);\\n  address public constant AUD = address(36);\\n  address public constant CAD = address(124);\\n  address public constant CHF = address(756);\\n  address public constant ARS = address(32);\\n  address public constant PHP = address(608);\\n  address public constant NZD = address(554);\\n  address public constant SGD = address(702);\\n  address public constant NGN = address(566);\\n  address public constant ZAR = address(710);\\n  address public constant RUB = address(643);\\n  address public constant INR = address(356);\\n  address public constant BRL = address(986);\\n}\\n\",\"keccak256\":\"0xee406990d671c95993762c3ee15c77987ee35c3682357c419ff73747a728fc4d\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorInterface {\\n  function latestAnswer() external view returns (int256);\\n\\n  function latestTimestamp() external view returns (uint256);\\n\\n  function latestRound() external view returns (uint256);\\n\\n  function getAnswer(uint256 roundId) external view returns (int256);\\n\\n  function getTimestamp(uint256 roundId) external view returns (uint256);\\n\\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\\n\\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\\n}\\n\",\"keccak256\":\"0xb496651006b9a2a07920ffe116928b11e2a6458e21361cecca51409522488ca7\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"./AggregatorInterface.sol\\\";\\nimport \\\"./AggregatorV3Interface.sol\\\";\\n\\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\\n\",\"keccak256\":\"0x4a7757ff7bbafe044cd49c2a45c7c18ec50eff7c7af6869face5e1e9cda976f2\",\"license\":\"MIT\"},\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\ninterface AggregatorV3Interface {\\n  function decimals() external view returns (uint8);\\n\\n  function description() external view returns (string memory);\\n\\n  function version() external view returns (uint256);\\n\\n  function getRoundData(uint80 _roundId)\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n\\n  function latestRoundData()\\n    external\\n    view\\n    returns (\\n      uint80 roundId,\\n      int256 answer,\\n      uint256 startedAt,\\n      uint256 updatedAt,\\n      uint80 answeredInRound\\n    );\\n}\\n\",\"keccak256\":\"0x6e6e4b0835904509406b070ee173b5bc8f677c19421b76be38aea3b1b3d30846\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"contracts/AppStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nenum ReentrancyStatus {\\n    NOT_ENTERED,\\n    ENTERED\\n}\\n\\n/**\\n * @notice The `Status` enum represents the possible statuses of a trading strategy.\\n * @dev This enum defines three status options that describe the state of a strategy:\\n *      - ACTIVE: The strategy is currently active and operational.\\n *      - CANCELLED: The strategy has been cancelled and is no longer in effect.\\n *      - COMPLETED: The strategy has been successfully completed.\\n */\\nenum Status {\\n    ACTIVE, // The strategy is currently active.\\n    CANCELLED, // The strategy has been cancelled.\\n    COMPLETED // The strategy has been successfully completed.\\n}\\n\\n/**\\n * @notice The `FloorLegType` enum defines the types of floor price legs for trading strategies.\\n * @dev This enum enumerates three possible types of floor price legs that can be associated with a strategy:\\n *      - NO_TYPE: No specific floor price leg is defined.\\n *      - LIMIT_PRICE: The floor price is set as a specific limit price.\\n *      - DECREASE_BY: The floor price is determined by decreasing the current price by a certain amount.\\n */\\nenum FloorLegType {\\n    NO_TYPE, // No specific floor price leg is defined.\\n    LIMIT_PRICE, // The floor price is set as a specific limit price.\\n    DECREASE_BY // The floor price is determined by decreasing the current price by a certain amount.\\n}\\n/**\\n * @notice The `BuyLegType` enum defines the types of buy legs for trading strategies.\\n * @dev This enum enumerates two possible types of buy legs that can be associated with a strategy:\\n *      - NO_TYPE: No specific buy leg is defined.\\n *      - LIMIT_PRICE: The buy leg is set as a specific limit price.\\n */\\nenum BuyLegType {\\n    NO_TYPE, // No specific buy leg is defined.\\n    LIMIT_PRICE // The buy leg is set as a specific limit price.\\n}\\n\\n/**\\n * @notice The `SellLegType` enum defines the types of sell legs for trading strategies.\\n * @dev This enum enumerates three possible types of sell legs that can be associated with a strategy:\\n *      - NO_TYPE: No specific sell leg is defined.\\n *      - LIMIT_PRICE: The sell leg is set as a specific limit price.\\n *      - INCREASE_BY: The sell leg is determined by increasing the current price by a certain amount.\\n */\\nenum SellLegType {\\n    NO_TYPE, // No specific sell leg is defined.\\n    LIMIT_PRICE, // The sell leg is set as a specific limit price.\\n    INCREASE_BY // The sell leg is determined by increasing the current price by a certain amount.\\n}\\n\\n/**\\n * @notice The `DIP_SPIKE` enum defines the types of dip and spike conditions for trading strategies.\\n * @dev This enum enumerates five possible types of dip and spike conditions that can be associated with a strategy:\\n *      - NO_SPIKE: No specific dip or spike condition is defined.\\n *      - DECREASE_BY: The condition is based on a decrease in price by a certain percentage.\\n *      - INCREASE_BY: The condition is based on an increase in price by a certain percentage.\\n *      - FIXED_INCREASE: The condition is based on a fixed increase in price.\\n *      - FIXED_DECREASE: The condition is based on a fixed decrease in price.\\n */\\nenum DIP_SPIKE {\\n    NO_SPIKE, // No specific dip or spike condition is defined.\\n    DECREASE_BY, // The condition is based on a decrease in price by a certain percentage.\\n    INCREASE_BY, // The condition is based on an increase in price by a certain percentage.\\n    FIXED_INCREASE, // The condition is based on a fixed increase in price.\\n    FIXED_DECREASE // The condition is based on a fixed decrease in price.\\n}\\n\\n/**\\n * @notice The `DCA_UNIT` enum defines the units for Dollar-Cost Averaging (DCA) in trading strategies.\\n * @dev This enum enumerates three possible units for DCA that can be associated with a strategy:\\n *      - NO_UNIT: No specific DCA unit is defined.\\n *      - PERCENTAGE: DCA is specified as a percentage of assets.\\n *      - FIXED: DCA is specified as a fixed amount.\\n */\\nenum DCA_UNIT {\\n    NO_UNIT, // No specific DCA unit is defined.\\n    PERCENTAGE, // DCA is specified as a percentage of assets.\\n    FIXED // DCA is specified as a fixed amount.\\n}\\n\\n/**\\n * @notice The `TimeUnit` enum defines the units of time for time-related settings in trading strategies.\\n * @dev This enum enumerates three possible time units that can be used in trading strategies:\\n *      - NO_UNIT: No specific time unit is defined.\\n *      - HOURS: Time is measured in hours.\\n *      - DAYS: Time is measured in days.\\n */\\nenum TimeUnit {\\n    NO_UNIT, // No specific time unit is defined.\\n    HOURS, // Time is measured in hours.\\n    DAYS // Time is measured in days.\\n}\\n\\n/**\\n * @notice The `StrategyParameters` struct defines the parameters that configure a trading strategy.\\n * @dev These parameters dictate the behavior of the strategy, including trading details, conditions, and actions.\\n */\\n\\nstruct StrategyParameters {\\n    // @param _investToken The address of the investment token.\\n    address _investToken;\\n    // @param _investAmount The amount of investment token to be used.\\n    uint256 _investAmount;\\n    // @param _stableToken The address of the stable token.\\n    address _stableToken;\\n    // @param _stableAmount The amount of stable token to be used.\\n    uint256 _stableAmount;\\n    // @param _impact The impact tolerance for the strategy.\\n    uint256 _impact;\\n    // @param _floorType The type of floor price (if floor is set).\\n    FloorLegType _floorType;\\n    // @param _floorValue The value of the floor price (if floor is set).\\n    uint256 _floorValue;\\n    // @param _liquidateOnFloor A flag to trigger liquidation when the floor price is reached (if floor is set)..\\n    bool _liquidateOnFloor;\\n    // @param _cancelOnFloor A flag to cancel the strategy when the floor price is reached (if floor is set).\\n    bool _cancelOnFloor;\\n    // @param _minimumLoss The minimum loss required for floor percentage to satisfy.\\n    uint256 _minimumLoss;\\n    // @param _buyType The type of buy action (if buy is set).\\n    BuyLegType _buyType;\\n    // @param _buyValue The value of the buy action (if buy is set).\\n    uint256 _buyValue;\\n    // @param _buyTwapTime The time interval for TWAP buying (if buy is set).\\n    uint256 _buyTwapTime;\\n    // @param _buyTwapTimeUnit The unit of time for TWAP buying .\\n    TimeUnit _buyTwapTimeUnit;\\n    // @param _btdValue The value for buying the dip (if buy is set).\\n    uint256 _btdValue;\\n    // @param _btdType The type of buy the dip action (if buy is set).\\n    DIP_SPIKE _btdType;\\n    // @param _buyDCAUnit The unit for buy DCA (Dollar-Cost Averaging) for stable amount (if buy is set).\\n    DCA_UNIT _buyDCAUnit;\\n    // @param _buyDCAValue The value for buy DCA.\\n    uint256 _buyDCAValue;\\n    // @param _sellType The type of sell action (if sell is set).\\n    SellLegType _sellType;\\n    // @param _sellValue The value of the sell action (if sell is set).\\n    uint256 _sellValue;\\n    // @param if sell DCA is selected, _highSellValue is used to trigger complete sell when the high sell value is reached (if sell is set).\\n    uint256 _highSellValue;\\n    // @param _minimumProfit The minimum profit to be generated during sell if sell profit percentage is set\\n    uint256 _minimumProfit;\\n    // @param _strValue The value of the str if it is set to true (if sell is set).\\n    uint256 _strValue;\\n    // @param _strType The type of str.\\n    DIP_SPIKE _strType;\\n    // @param _sellDCAUnit The unit for sell DCA (Dollar-Cost Averaging) for the invest amount (if sell is set).\\n    DCA_UNIT _sellDCAUnit;\\n    // @param _sellDCAValue The value for sell DCA.\\n    uint256 _sellDCAValue;\\n    // @param _sellTwapTime The time interval for TWAP selling (if sell is set).\\n    uint256 _sellTwapTime;\\n    //  @param _sellTwapTimeUnit The unit of time for TWAP selling (if sell is set).\\n    TimeUnit _sellTwapTimeUnit;\\n    // @param _completeOnSell A flag to complete the strategy on selling (if sell is set).\\n    bool _completeOnSell;\\n    // @param _current_price_sell The current price indicator is selected for sell\\n    bool _current_price_sell;\\n    // @param _current_price The current price indicator is selected for buy\\n    bool _current_price_buy;\\n}\\n\\n/**\\n * @notice The `Strategy` struct defines the characteristics and status of a trading strategy.\\n * @dev This struct encapsulates important data related to a trading strategy, including user ownership,\\n *      strategy parameters, execution times, financial metrics, and its current status.\\n * it is mostly used for internal computation\\n */\\n\\nstruct Strategy {\\n    //  @param user The address of the strategy owner.\\n    address user;\\n    // @param parameters The parameters that configure the behavior of the strategy\\n    // as passed by the user and defined above\\n    StrategyParameters parameters;\\n    // to store invest amount to be sold when dca is chosen for percentage.\\n    uint256 sellPercentageAmount;\\n    // to store stable amount to be given when dca is chosen for percentage.\\n    uint256 buyPercentageAmount;\\n    // the invest amount based on which sellPercentageAmount is calculated\\n    uint256 sellPercentageTotalAmount;\\n    // the stable amount based on which buyPercentageAmount is calculated\\n    uint256 buyPercentageTotalAmount;\\n    //  @param sellTwapExecutedAt The timestamp of the last executed TWAP (Time-Weighted Average Price) sell.\\n    //  if sell twap is set for the sell. Otherwise it remains 0\\n    uint256 sellTwapExecutedAt;\\n    //  @param buyTwapExecutedAt The timestamp of the last executed TWAP buy.\\n    //  if buy Twap is set for btd. Otherwise it remains 0.\\n    uint256 buyTwapExecutedAt;\\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\\n    uint80 investRoundIdForBTD;\\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\\n    uint80 stableRoundIdForBTD;\\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\\n    uint80 investRoundIdForSTR;\\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\\n    uint80 stableRoundIdForSTR;\\n    // @param investPrice The price at which investment is made.\\n    //While creating strategy it is set to the current price\\n    uint256 investPrice;\\n    //  @param profit The current profit generated by the strategy.\\n    uint256 profit;\\n    //  @param budget The available budget for the strategy.\\n    // it is set at the starting of the strategy\\n    uint256 budget;\\n    // @param status The current status of the strategy.\\n    Status status;\\n}\\n/**\\n * @notice AppStorage is the central storage structure for this contract, holding essential data.\\n * @dev This struct contains critical information used by the contract for operation.\\n * It stores data such as function selectors, supported interfaces, the contract owner, strategy details,\\n * Chainlink feed information, and more.\\n */\\n\\nstruct AppStorage {\\n    // maps function selectors to the facets that execute the functions.\\n    // and maps the selectors to their position in the selectorSlots array.\\n    // func selector => address facet, selector position\\n    mapping(bytes4 => bytes32) facets;\\n    // array of slots of function selectors.\\n    // each slot holds 8 function selectors.\\n    mapping(uint256 => bytes32) selectorSlots;\\n    // The number of function selectors in selectorSlots\\n    uint16 selectorCount;\\n    // Used to query if a contract implements an interface.\\n    // Used to implement ERC-165.\\n    mapping(bytes4 => bool) supportedInterfaces;\\n    // owner of the contract\\n    address owner;\\n    // next id to use for strategies\\n    uint256 nextStrategyId;\\n    // array of strategies\\n    mapping(uint256 => Strategy) strategies;\\n    // chainlink feeds - asset => USD feed\\n    mapping(address => address) feeds;\\n    // account => nonce\\n    mapping(address => uint256) nonces;\\n    // reentrancy status\\n    ReentrancyStatus reentrancyStatus;\\n    // sequencer uptime feed\\n    address sequencerUptimeFeed;\\n    // max stale period\\n    uint256 maxStalePeriod;\\n}\\n\\n/**\\n * @title Swap\\n * @dev A struct representing a swap or trade operation on a decentralized exchange (DEX).\\n *  @param dex: The address of the DEX where the swap is to be executed.\\n *  @param callData: Encoded data containing instructions for the swap on the specified DEX.\\n */\\nstruct Swap {\\n    address dex;\\n    bytes callData;\\n}\\n\\n// Struct representing the parameters to update in a strategy\\nstruct UpdateStruct {\\n    uint256 sellValue;\\n    uint256 buyValue;\\n    uint256 strValue;\\n    uint256 btdValue;\\n    uint256 floorValue;\\n    uint256 highSellValue;\\n    uint256 buyTwapTime;\\n    TimeUnit buyTwapTimeUnit;\\n    uint256 buyDCAValue;\\n    uint256 sellDCAValue;\\n    uint256 sellTwapTime;\\n    TimeUnit sellTwapTimeUnit;\\n    bool toggleCompleteOnSell;\\n    bool toggleLiquidateOnFloor;\\n    bool toggleCancelOnFloor;\\n    uint256 impact;\\n    bool current_price_sell;\\n    bool current_price_buy;\\n    uint256 minimumLoss;\\n    uint256 minimumProfit;\\n}\\n\\n// struct for information regarding which token is added in the strategy and which deleted\\nstruct TokensTransaction {\\n    uint256 tokenSubstracted;\\n    uint256 tokenAdded;\\n    uint256 stableAmount;\\n    uint256 investAmount;\\n}\\n\",\"keccak256\":\"0x153f7b44f853de42ed8d36b437bf7d28d1aaacdee39d4e7f11c0eaa04b6e1718\",\"license\":\"MIT\"},\"contracts/facets/FloorFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { Modifiers } from \\\"../utils/Modifiers.sol\\\";\\nimport { AppStorage, Strategy, Status, Swap, FloorLegType, TokensTransaction, DCA_UNIT } from \\\"../AppStorage.sol\\\";\\nimport { IERC20Metadata } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport { LibSwap } from \\\"../libraries/LibSwap.sol\\\";\\nimport { LibPrice } from \\\"../libraries/LibPrice.sol\\\";\\nimport { LibTrade } from \\\"../libraries/LibTrade.sol\\\";\\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, StrategyIsNotActive, FloorNotSet } from \\\"../utils/GenericErrors.sol\\\";\\nerror PriceIsGreaterThanFloorValue();\\nerror MinimumLossRequired();\\n\\n/**\\n * @title FloorFacet\\n * @notice This facet contains functions responsible for evaluating conditions related to the floor price and liquidation events.\\n * @dev FloorFacet specializes in verifying floor price conditions, handling liquidation actions when the floor price is reached,\\n *      ensuring that the necessary criteria are met before taking any actions and also cancelling the strategy if provided.\\n */\\n\\ncontract FloorFacet is Modifiers {\\n    /**\\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\\n     * please look at AppStorage.sol for more detail\\n     */\\n    AppStorage internal s;\\n\\n    /**\\n     * @notice Emitted when a floor execution is initiated for a trading strategy.\\n     * @param strategyId The unique ID of the strategy where the floor execution is initiated.\\n     * @param impact The allowable price impact percentage for the buy action.\\n     * @param tokens tokens substracted and added into the users wallet\\n     * @param stablePriceInUSD price of stable token in USD\\n     * @param investPrice the average price at which invest tokens were bought.\\n     * @param profit it is the profit made by the strategy.\\n     */\\n    event FloorExecuted(\\n        uint256 indexed strategyId,\\n        uint256 impact,\\n        TokensTransaction tokens,\\n        uint256 stablePriceInUSD,\\n        uint256 investPrice,\\n        uint256 profit\\n    );\\n    /**\\n     * @notice Emitted when a trade execution strategy is cancelled.\\n     * @param strategyId The unique ID of the cancelled strategy.\\n     * @param investTokenPrice The price of the invest token in USD.\\n     * @param stableTokenPrice The price of the stable token in USD.\\n     */\\n    event StrategyCancelled(uint256 indexed strategyId, uint256 investTokenPrice, uint256 stableTokenPrice);\\n\\n    /**\\n     * @notice Execute a floor price check and potential liquidation for a trading strategy.\\n     * @dev This function performs a floor price check and, if the strategy's parameters meet the required conditions,\\n     *      it may execute a liquidation of assets. Liquidation occurs if the strategy's floor price is reached and\\n     *      liquidation is enabled in the strategy parameters.\\n     * @param strategyId The unique ID of the strategy to execute the floor check for.\\n     * @param dexSwap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\\n     */\\n    function executeFloor(uint256 strategyId, Swap calldata dexSwap) external nonReentrant {\\n        // Retrieve the strategy details.\\n        Strategy storage strategy = s.strategies[strategyId];\\n        uint256 stablePrice = LibPrice.getUSDPrice(strategy.parameters._stableToken);\\n        if (strategy.status != Status.ACTIVE) {\\n            revert StrategyIsNotActive();\\n        }\\n\\n        // Check if the floor price is set in the strategy parameters.\\n        if (strategy.parameters._floorValue == 0) {\\n            revert FloorNotSet();\\n        }\\n\\n        // Ensure that there are assets available for swapping.\\n        if (strategy.parameters._investAmount == 0) {\\n            revert NoSwapFromZeroBalance();\\n        }\\n\\n        (uint256 price, , ) = LibPrice.getPrice(strategy.parameters._investToken, strategy.parameters._stableToken);\\n\\n        uint256 floorAt;\\n        if (strategy.parameters._floorType == FloorLegType.LIMIT_PRICE) {\\n            floorAt = strategy.parameters._floorValue;\\n        } else if (strategy.parameters._floorType == FloorLegType.DECREASE_BY) {\\n            uint256 floorPercentage = LibTrade.MAX_PERCENTAGE - strategy.parameters._floorValue;\\n            floorAt = (strategy.investPrice * floorPercentage) / LibTrade.MAX_PERCENTAGE;\\n        }\\n\\n        if (price > floorAt) {\\n            revert PriceIsGreaterThanFloorValue();\\n        }\\n\\n        // If liquidation is enabled, initiate a swap of assets.\\n        if (strategy.parameters._liquidateOnFloor) {\\n            // Prepare swap data for the DEX.\\n            LibSwap.SwapData memory swap = LibSwap.SwapData(\\n                dexSwap.dex,\\n                strategy.parameters._investToken,\\n                strategy.parameters._stableToken,\\n                strategy.parameters._investAmount,\\n                dexSwap.callData,\\n                strategy.user\\n            );\\n\\n            // Execute the asset swap and calculate the exchange rate.\\n            uint256 toTokenAmount = LibSwap.swap(swap);\\n            uint256 rate = LibTrade.calculateExchangeRate(\\n                strategy.parameters._investToken,\\n                strategy.parameters._investAmount,\\n                toTokenAmount\\n            );\\n\\n            // Check if the calculated exchange rate is within the acceptable range.\\n            if (rate > floorAt) {\\n                revert InvalidExchangeRate(floorAt, rate);\\n            }\\n\\n            if (strategy.parameters._floorType == FloorLegType.DECREASE_BY && strategy.parameters._minimumLoss > 0) {\\n                // Check for mimimum loss\\n                uint256 invested = (strategy.parameters._investAmount * strategy.investPrice) /\\n                    10 ** IERC20Metadata(strategy.parameters._investToken).decimals();\\n                uint256 sold = toTokenAmount;\\n                uint256 loss = invested - sold;\\n\\n                if (loss < strategy.parameters._minimumLoss) {\\n                    revert MinimumLossRequired();\\n                }\\n            }\\n\\n            // Validate the impact based on the calculated rate and the latest price.\\n            uint256 impact = LibTrade.validateImpact(rate, price, strategy.parameters._impact, false);\\n\\n            // Update strategy details, including timestamp, asset amounts, round ID, and invest price.\\n            uint256 value = strategy.parameters._investAmount;\\n            strategy.parameters._investAmount = 0;\\n            strategy.investPrice = 0;\\n            uint256 remainingAmount = strategy.budget - strategy.parameters._stableAmount;\\n\\n            if (toTokenAmount > remainingAmount) {\\n                strategy.parameters._stableAmount = strategy.parameters._stableAmount + remainingAmount;\\n                strategy.profit = toTokenAmount - remainingAmount + strategy.profit;\\n            } else {\\n                strategy.parameters._stableAmount = strategy.parameters._stableAmount + toTokenAmount;\\n            }\\n\\n            if (strategy.parameters._buyDCAUnit == DCA_UNIT.PERCENTAGE) {\\n                strategy.buyPercentageAmount =\\n                    (strategy.parameters._buyDCAValue * strategy.parameters._stableAmount) /\\n                    LibTrade.MAX_PERCENTAGE;\\n                strategy.buyPercentageTotalAmount = strategy.parameters._stableAmount;\\n            }\\n\\n            // Check if the strategy should be canceled on reaching the floor price.\\n\\n            emit FloorExecuted(\\n                strategyId,\\n                impact,\\n                TokensTransaction({\\n                    tokenSubstracted: value,\\n                    tokenAdded: toTokenAmount,\\n                    stableAmount: strategy.parameters._stableAmount,\\n                    investAmount: strategy.parameters._investAmount\\n                }),\\n                stablePrice,\\n                strategy.investPrice,\\n                strategy.profit\\n            );\\n        }\\n\\n        if (strategy.parameters._cancelOnFloor) {\\n            uint256 investPrice = LibPrice.getUSDPrice(strategy.parameters._investToken);\\n            strategy.status = Status.CANCELLED;\\n            emit StrategyCancelled(strategyId, investPrice, stablePrice);\\n        }\\n\\n        if (strategy.parameters._cancelOnFloor == false && strategy.parameters._buyValue == 0) {\\n            strategy.status = Status.CANCELLED;\\n            emit StrategyCancelled(strategyId, 0, stablePrice);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x17219e99a1f4be76f557c012b135a748e0973e1377dcd3b70f9a0673a228c71d\",\"license\":\"MIT\"},\"contracts/interfaces/IDiamondCut.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\ninterface IDiamondCut {\\n    enum FacetCutAction {\\n        Add,\\n        Replace,\\n        Remove\\n    }\\n    // Add=0, Replace=1, Remove=2\\n\\n    struct FacetCut {\\n        address facetAddress;\\n        FacetCutAction action;\\n        bytes4[] functionSelectors;\\n    }\\n\\n    /// @notice Add/replace/remove any number of functions and optionally execute\\n    ///         a function with delegatecall\\n    /// @param _diamondCut Contains the facet addresses and function selectors\\n    /// @param _init The address of the contract or facet to execute _calldata\\n    /// @param _calldata A function call, including function selector and arguments\\n    ///                  _calldata is executed with delegatecall on _init\\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\\n\\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\\n}\\n\",\"keccak256\":\"0x882028bbad965788430b37558ea12b191a31b4d6e562c08ac2357fa6e0bc9de5\",\"license\":\"MIT\"},\"contracts/libraries/LibAsset.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { TransferFailed } from \\\"../utils/GenericErrors.sol\\\";\\n\\n/**\\n * @title LibAsset\\n * @dev This library provides functions for interacting with ERC20 assets.\\n */\\nlibrary LibAsset {\\n    uint256 private constant MAX_UINT = type(uint256).max;\\n\\n    /**\\n     * @notice Approves a specified amount of an asset for a spender if the current allowance is insufficient.\\n     * @param asset The address of the asset.\\n     * @param spender The address of the spender.\\n     * @param amount The amount to approve.\\n     */\\n    function maxApprove(address asset, address spender, uint256 amount) internal {\\n        if (IERC20(asset).allowance(address(this), spender) < amount) {\\n            SafeERC20.safeApprove(IERC20(asset), spender, 0);\\n            SafeERC20.safeApprove(IERC20(asset), spender, amount);\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers a specified amount of an asset from one address to another.\\n     * @param asset The address of the asset.\\n     * @param from The sender's address.\\n     * @param to The recipient's address.\\n     * @param amount The amount to transfer.\\n     */\\n    function transferFrom(address asset, address from, address to, uint256 amount) internal {\\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\\n        SafeERC20.safeTransferFrom(IERC20(asset), from, to, amount);\\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\\n            revert TransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Transfers a specified amount of an asset to a recipient.\\n     * @param asset The address of the asset.\\n     * @param to The recipient's address.\\n     * @param amount The amount to transfer.\\n     */\\n    function transfer(address asset, address to, uint256 amount) internal {\\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\\n        SafeERC20.safeTransfer(IERC20(asset), to, amount);\\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\\n            revert TransferFailed();\\n        }\\n    }\\n\\n    /**\\n     * @notice Retrieves the balance of a specified asset for a given account.\\n     * @param asset The address of the asset.\\n     * @param account The account for which to check the balance.\\n     * @return The balance of the asset for the specified account.\\n     */\\n    function balanceOf(address asset, address account) internal view returns (uint256) {\\n        return IERC20(asset).balanceOf(account);\\n    }\\n}\\n\",\"keccak256\":\"0xabaf52a5d90146866c805817efee408b56be4cf4c1dd529fd3634d2bf4abed0e\",\"license\":\"MIT\"},\"contracts/libraries/LibBytes.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nlibrary LibBytes {\\n    // solhint-disable no-inline-assembly\\n\\n    // LibBytes specific errors\\n    error SliceOverflow();\\n    error SliceOutOfBounds();\\n    error AddressOutOfBounds();\\n\\n    bytes16 private constant _SYMBOLS = \\\"0123456789abcdef\\\";\\n\\n    // -------------------------\\n    /**\\n     * @notice Slice a portion of a bytes array.\\n     * @param _bytes The input bytes array.\\n     * @param _start The starting index of the slice.\\n     * @param _length The length of the slice.\\n     * @return tempBytes A new bytes array containing the sliced data.\\n     */\\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\\n        if (_length + 31 < _length) revert SliceOverflow();\\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    /**\\n     * @notice Convert a portion of a bytes array to an address.\\n     * @param _bytes The input bytes array.\\n     * @param _start The starting index of the address data.\\n     * @return tempAddress The address extracted from the bytes array.\\n     */\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        if (_bytes.length < _start + 20) {\\n            revert AddressOutOfBounds();\\n        }\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\\n    /**\\n     * @notice Convert a uint256 to its hexadecimal representation as a string.\\n     * @param value The uint256 value to convert.\\n     * @param length The desired length of the hexadecimal string.\\n     * @return A string containing the hexadecimal representation of the uint256 value.\\n     */\\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\\n        bytes memory buffer = new bytes(2 * length + 2);\\n        buffer[0] = \\\"0\\\";\\n        buffer[1] = \\\"x\\\";\\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\\n            buffer[i] = _SYMBOLS[value & 0xf];\\n            value >>= 4;\\n        }\\n        require(value == 0, \\\"Strings: hex length insufficient\\\");\\n        return string(buffer);\\n    }\\n}\\n\",\"keccak256\":\"0xbd7edc3743a6a3ca135ec7077a7e2f29c45719980c324eed18c084e15293a503\",\"license\":\"MIT\"},\"contracts/libraries/LibDiamond.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { IDiamondCut } from \\\"../interfaces/IDiamondCut.sol\\\";\\nimport { AppStorage } from \\\"../AppStorage.sol\\\";\\n\\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\\n// The loupe functions are required by the EIP2535 Diamonds standard\\n\\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\\n\\nlibrary LibDiamond {\\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\\n\\n    function diamondStorage() internal pure returns (AppStorage storage s) {\\n        assembly {\\n            s.slot := 0\\n        }\\n    }\\n\\n    function setContractOwner(address _newOwner) internal {\\n        AppStorage storage s = diamondStorage();\\n        address previousOwner = s.owner;\\n        s.owner = _newOwner;\\n        emit OwnershipTransferred(previousOwner, _newOwner);\\n    }\\n\\n    // Internal function version of diamondCut\\n    // This code is almost the same as the external diamondCut,\\n    // except it is using 'Facet[] memory _diamondCut' instead of\\n    // 'Facet[] calldata _diamondCut'.\\n    // The code is duplicated to prevent copying calldata to memory which\\n    // causes an error for a two dimensional array.\\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\\n        AppStorage storage s = diamondStorage();\\n        uint256 originalSelectorCount = s.selectorCount;\\n        uint256 selectorCount = originalSelectorCount;\\n        bytes32 selectorSlot;\\n        // Check if last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // get last selectorSlot\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\\n        }\\n        // loop through diamond cut\\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\\n                selectorCount,\\n                selectorSlot,\\n                _diamondCut[facetIndex].facetAddress,\\n                _diamondCut[facetIndex].action,\\n                _diamondCut[facetIndex].functionSelectors\\n            );\\n\\n            unchecked {\\n                facetIndex++;\\n            }\\n        }\\n        if (selectorCount != originalSelectorCount) {\\n            s.selectorCount = uint16(selectorCount);\\n        }\\n        // If last selector slot is not full\\n        // \\\"selectorCount & 7\\\" is a gas efficient modulo by eight \\\"selectorCount % 8\\\"\\n        if (selectorCount & 7 > 0) {\\n            // \\\"selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"selectorSlot / 8\\\"\\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\\n        }\\n        emit DiamondCut(_diamondCut, _init, _calldata);\\n        initializeDiamondCut(_init, _calldata);\\n    }\\n\\n    function addReplaceRemoveFacetSelectors(\\n        uint256 _selectorCount,\\n        bytes32 _selectorSlot,\\n        address _newFacetAddress,\\n        IDiamondCut.FacetCutAction _action,\\n        bytes4[] memory _selectors\\n    ) internal returns (uint256, bytes32) {\\n        AppStorage storage s = diamondStorage();\\n        require(_selectors.length > 0, \\\"LibDiamondCut: No selectors in facet to cut\\\");\\n        if (_action == IDiamondCut.FacetCutAction.Add) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Add facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = s.facets[selector];\\n                require(\\n                    address(bytes20(oldFacet)) == address(0),\\n                    \\\"LibDiamondCut: Can't add function that already exists\\\"\\n                );\\n                // add facet for selector\\n                s.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\\n                // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n                // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\\n                // clear selector position in slot and add selector\\n                _selectorSlot =\\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\\n                    (bytes32(selector) >> selectorInSlotPosition);\\n                // if slot is full then write it to storage\\n                if (selectorInSlotPosition == 224) {\\n                    // \\\"_selectorSlot >> 3\\\" is a gas efficient division by 8 \\\"_selectorSlot / 8\\\"\\n                    s.selectorSlots[_selectorCount >> 3] = _selectorSlot;\\n                    _selectorSlot = 0;\\n                }\\n                _selectorCount++;\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\\n            enforceHasContractCode(_newFacetAddress, \\\"LibDiamondCut: Replace facet has no code\\\");\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                bytes4 selector = _selectors[selectorIndex];\\n                bytes32 oldFacet = s.facets[selector];\\n                address oldFacetAddress = address(bytes20(oldFacet));\\n                // only useful if immutable functions exist\\n                require(oldFacetAddress != address(this), \\\"LibDiamondCut: Can't replace immutable function\\\");\\n                require(\\n                    oldFacetAddress != _newFacetAddress,\\n                    \\\"LibDiamondCut: Can't replace function with same function\\\"\\n                );\\n                require(oldFacetAddress != address(0), \\\"LibDiamondCut: Can't replace function that doesn't exist\\\");\\n                // replace old facet address\\n                s.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\\n            require(_newFacetAddress == address(0), \\\"LibDiamondCut: Remove facet address must be address(0)\\\");\\n            // \\\"_selectorCount >> 3\\\" is a gas efficient division by 8 \\\"_selectorCount / 8\\\"\\n            uint256 selectorSlotCount = _selectorCount >> 3;\\n            // \\\"_selectorCount & 7\\\" is a gas efficient modulo by eight \\\"_selectorCount % 8\\\"\\n            uint256 selectorInSlotIndex = _selectorCount & 7;\\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\\n                if (_selectorSlot == 0) {\\n                    // get last selectorSlot\\n                    selectorSlotCount--;\\n                    _selectorSlot = s.selectorSlots[selectorSlotCount];\\n                    selectorInSlotIndex = 7;\\n                } else {\\n                    selectorInSlotIndex--;\\n                }\\n                bytes4 lastSelector;\\n                uint256 oldSelectorsSlotCount;\\n                uint256 oldSelectorInSlotPosition;\\n                // adding a block here prevents stack too deep error\\n                {\\n                    bytes4 selector = _selectors[selectorIndex];\\n                    bytes32 oldFacet = s.facets[selector];\\n                    require(\\n                        address(bytes20(oldFacet)) != address(0),\\n                        \\\"LibDiamondCut: Can't remove function that doesn't exist\\\"\\n                    );\\n                    // only useful if immutable functions exist\\n                    require(\\n                        address(bytes20(oldFacet)) != address(this),\\n                        \\\"LibDiamondCut: Can't remove immutable function\\\"\\n                    );\\n                    // replace selector with last selector in s.facets\\n                    // gets the last selector\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\\n                    if (lastSelector != selector) {\\n                        // update last selector slot position info\\n                        s.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.facets[lastSelector]);\\n                    }\\n                    delete s.facets[selector];\\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\\n                    // \\\"oldSelectorCount >> 3\\\" is a gas efficient division by 8 \\\"oldSelectorCount / 8\\\"\\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\\n                    // \\\"oldSelectorCount & 7\\\" is a gas efficient modulo by eight \\\"oldSelectorCount % 8\\\"\\n                    // \\\" << 5 is the same as multiplying by 32 ( * 32)\\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\\n                }\\n                if (oldSelectorsSlotCount != selectorSlotCount) {\\n                    bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    oldSelectorSlot =\\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                    // update storage with the modified slot\\n                    s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\\n                } else {\\n                    // clears the selector we are deleting and puts the last selector in its place.\\n                    _selectorSlot =\\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\\n                }\\n                if (selectorInSlotIndex == 0) {\\n                    delete s.selectorSlots[selectorSlotCount];\\n                    _selectorSlot = 0;\\n                }\\n\\n                unchecked {\\n                    selectorIndex++;\\n                }\\n            }\\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\\n        } else {\\n            revert(\\\"LibDiamondCut: Incorrect FacetCutAction\\\");\\n        }\\n        return (_selectorCount, _selectorSlot);\\n    }\\n\\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\\n        if (_init == address(0)) {\\n            return;\\n        }\\n        enforceHasContractCode(_init, \\\"LibDiamondCut: _init address has no code\\\");\\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\\n        if (!success) {\\n            if (error.length > 0) {\\n                // bubble up error\\n                /// @solidity memory-safe-assembly\\n                assembly {\\n                    let returndata_size := mload(error)\\n                    revert(add(32, error), returndata_size)\\n                }\\n            } else {\\n                revert InitializationFunctionReverted(_init, _calldata);\\n            }\\n        }\\n    }\\n\\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\\n        uint256 contractSize;\\n        assembly {\\n            contractSize := extcodesize(_contract)\\n        }\\n        require(contractSize > 0, _errorMessage);\\n    }\\n}\\n\",\"keccak256\":\"0xcaa7ed67af8cf7fe50033f6d06c56cab2bd3392aceceb782660e07153c2c06db\",\"license\":\"MIT\"},\"contracts/libraries/LibPrice.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport \\\"@chainlink/contracts/src/v0.8/Denominations.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport \\\"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\\\";\\n\\nimport { LibDiamond } from \\\"./LibDiamond.sol\\\";\\nimport { InvalidPrice, FeedNotFound } from \\\"../utils/GenericErrors.sol\\\";\\nimport { AppStorage } from \\\"../AppStorage.sol\\\";\\n\\nerror SequencerDown();\\nerror GracePeriodNotOver();\\nerror PriceExpired();\\n\\n/**\\n * @title LibPrice\\n * @dev This library provides functions for fetching and manipulating asset prices.\\n */\\nlibrary LibPrice {\\n    address constant USD_QUOTE = 0x0000000000000000000000000000000000000348;\\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\\n\\n    /**\\n     * @notice Get the current price and round IDs of an asset relative to a unit.\\n     * @param asset The address of the asset.\\n     * @param unit The address of the unit (e.g., USD).\\n     * @return price The current price of the asset in terms of the unit.\\n     * @return investRoundId The round ID of the asset's price feed.\\n     * @return stableRoundId The round ID of the unit's price feed.\\n     */\\n    function getPrice(address asset, address unit) internal view returns (uint256 price, uint80, uint80) {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n\\n        AggregatorV2V3Interface sequencerUptimeFeed = AggregatorV2V3Interface(s.sequencerUptimeFeed);\\n\\n        if (address(sequencerUptimeFeed) != address(0)) {\\n            (\\n                ,\\n                /*uint80 roundID*/ int256 answer,\\n                uint256 startedAt /*uint256 updatedAt*/ /*uint80 answeredInRound*/,\\n                ,\\n\\n            ) = sequencerUptimeFeed.latestRoundData();\\n\\n            // Answer == 0: Sequencer is up\\n            // Answer == 1: Sequencer is down\\n            bool isSequencerUp = answer == 0;\\n            if (!isSequencerUp) {\\n                revert SequencerDown();\\n            }\\n\\n            // Make sure the grace period has passed after the\\n            // sequencer is back up.\\n            uint256 timeSinceUp = block.timestamp - startedAt;\\n            if (timeSinceUp <= GRACE_PERIOD_TIME) {\\n                revert GracePeriodNotOver();\\n            }\\n        }\\n\\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\\n            revert FeedNotFound();\\n        }\\n\\n        (uint80 investRoundId, int256 assetPrice, , uint256 investUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[asset])\\n            .latestRoundData();\\n        (uint80 stableRoundId, int256 unitPrice, , uint256 stableUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[unit])\\n            .latestRoundData();\\n\\n        if (assetPrice == 0 || unitPrice == 0) {\\n            revert InvalidPrice();\\n        }\\n\\n        if (\\n            block.timestamp - investUpdatedAt > s.maxStalePeriod || block.timestamp - stableUpdatedAt > s.maxStalePeriod\\n        ) {\\n            revert PriceExpired();\\n        }\\n\\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\\n        price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\\n\\n        return (price, investRoundId, stableRoundId);\\n    }\\n\\n    /**\\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\\n     * @param investRoundId The round ID of the asset's price feed.\\n     * @param stableRoundId The round ID of the unit's price feed.\\n     * @param asset The address of the asset.\\n     * @param unit The address of the unit (e.g., USD).\\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\\n     */\\n    function getRoundData(\\n        uint80 investRoundId,\\n        uint80 stableRoundId,\\n        address asset,\\n        address unit\\n    ) internal view returns (uint256) {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n\\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\\n            revert FeedNotFound();\\n        }\\n\\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(investRoundId);\\n        (, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).getRoundData(stableRoundId);\\n\\n        if (assetPrice == 0 || unitPrice == 0) {\\n            revert InvalidPrice();\\n        }\\n\\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\\n        uint256 price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\\n\\n        return price;\\n    }\\n\\n    /**\\n     * @notice Get the price of an asset in USD.\\n     * @param asset The address of the asset.\\n     * @return price The price of the asset in USD\\n     */\\n    function getUSDPrice(address asset) internal view returns (uint256) {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n\\n        if (s.feeds[asset] == address(0)) {\\n            revert FeedNotFound();\\n        }\\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\\n        if (assetPrice == 0) {\\n            revert InvalidPrice();\\n        }\\n        return uint256(assetPrice);\\n    }\\n\\n    /**\\n     * @notice Get the price of an asset in USD.\\n     * @param asset The address of the asset.\\n     * @param roundId the round for which price is required.\\n     * @return price The price of the asset based on round Id\\n     */\\n    function getPriceBasedOnRoundId(address asset, uint80 roundId) internal view returns (uint256) {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n\\n        if (s.feeds[asset] == address(0)) {\\n            revert FeedNotFound();\\n        }\\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(roundId);\\n        if (assetPrice == 0) {\\n            revert InvalidPrice();\\n        }\\n        return uint256(assetPrice);\\n    }\\n}\\n\",\"keccak256\":\"0xd302b2e9d5de31e8669fb817227971f01713c68bf6de4539ca1f2d8d66d0b878\",\"license\":\"MIT\"},\"contracts/libraries/LibSwap.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { LibAsset } from \\\"./LibAsset.sol\\\";\\nimport { LibUtil } from \\\"./LibUtil.sol\\\";\\nimport { NoSwapFromZeroBalance, InsufficientBalance, SwapFailed } from \\\"../utils/GenericErrors.sol\\\";\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title LibSwap\\n * @dev This library provides functions for executing asset swaps.\\n */\\nlibrary LibSwap {\\n    struct SwapData {\\n        address callTo; // The address of the contract or dex to execute the swap on.\\n        address fromAsset; // The address of the asset to swap from.\\n        address toAsset; // The address of the asset to receive.\\n        uint256 fromAmount; // The amount of the 'fromAsset' to swap.\\n        bytes callData; // The call data for the swap.\\n        address user; // The user initiating the swap.\\n    }\\n\\n    /**\\n     * @notice Emitted when an asset swap has been executed successfully.\\n     * @param dex The address of the contract or dex used for the swap.\\n     * @param fromAsset The address of the asset swapped from.\\n     * @param toAsset The address of the asset received in the swap.\\n     * @param fromAmount The amount of 'fromAsset' that was swapped.\\n     * @param receivedAmount The amount of 'toAsset' received in the swap.\\n     * @param account The address of the user account that initiated the swap.\\n     */\\n\\n    event AssetSwapped(\\n        address dex,\\n        address fromAsset,\\n        address toAsset,\\n        uint256 fromAmount,\\n        uint256 receivedAmount,\\n        address account\\n    );\\n\\n    /**\\n     * @notice Execute an asset swap from one asset to another using the provided swap data.\\n     * @param _swap The swap data containing all necessary information for the swap.\\n     * @return The amount of 'toAsset' received in the swap.\\n     * @dev This function transfers 'fromAsset' from the user to this contract, executes the swap,\\n     * and transfers the received 'toAsset' back to the user.\\n     */\\n    function swap(SwapData memory _swap) internal returns (uint256) {\\n        uint256 fromAmount = _swap.fromAmount;\\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\\n\\n        LibAsset.transferFrom(_swap.fromAsset, _swap.user, address(this), fromAmount);\\n\\n        uint256 initialReceivingAssetBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\\n\\n        LibAsset.maxApprove(_swap.fromAsset, _swap.callTo, _swap.fromAmount);\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory res) = _swap.callTo.call(_swap.callData);\\n        if (!success) {\\n            string memory reason = LibUtil.getRevertMsg(res);\\n            revert(reason);\\n        }\\n\\n        uint256 newBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\\n        uint256 receivedAmount = newBalance - initialReceivingAssetBalance;\\n\\n        if (receivedAmount == 0) {\\n            revert SwapFailed();\\n        }\\n\\n        LibAsset.transfer(_swap.toAsset, _swap.user, receivedAmount);\\n\\n        emit AssetSwapped(_swap.callTo, _swap.fromAsset, _swap.toAsset, _swap.fromAmount, receivedAmount, _swap.user);\\n\\n        return receivedAmount;\\n    }\\n}\\n\",\"keccak256\":\"0x97d0b9ff55ff5eb11fd67677ccde90384ff4c072b1ef79cffd65c8029a03b598\",\"license\":\"MIT\"},\"contracts/libraries/LibTrade.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { IERC20Metadata } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\nimport { HighImpact } from \\\"../utils/GenericErrors.sol\\\";\\n\\n/**\\n * @title LibTrade\\n * @dev This library provides functions for calculating exchange rates and validating slippage.\\n */\\nlibrary LibTrade {\\n    uint256 public constant MAX_PERCENTAGE = 10000;\\n\\n    /**\\n    @dev Calculate exchange rate given input and output amounts\\n    @param fromAsset Address of the asset that was used to swap\\n    @param fromAmount Amount of the asset that was used to swap\\n    @param toAmount Amount of the asset that was received from swap\\n    @return uint256 Returns the exchange rate in toAsset unit\\n     */\\n    function calculateExchangeRate(\\n        address fromAsset,\\n        uint256 fromAmount,\\n        uint256 toAmount\\n    ) internal view returns (uint256) {\\n        IERC20Metadata _fromToken = IERC20Metadata(fromAsset);\\n        uint256 fromDecimals = _fromToken.decimals();\\n        return ((toAmount * (10 ** fromDecimals)) / fromAmount);\\n    }\\n\\n    /**\\n     * @notice Validate the Impact of a swap.\\n     * @param exchangeRate The calculated exchange rate for the swap.\\n     * @param price The reference price for the swap.\\n     * @param maxImpact The maximum allowed Impact percentage.\\n     * @param isBuy A flag indicating if it's a buy operation (true) or not (false).\\n     * @return uint256 Returns the calculated Impact percentage.\\n     */\\n    function validateImpact(\\n        uint256 exchangeRate,\\n        uint256 price,\\n        uint256 maxImpact,\\n        bool isBuy\\n    ) internal pure returns (uint256) {\\n        uint256 impact = (price * MAX_PERCENTAGE) / exchangeRate;\\n\\n        if (isBuy && impact < MAX_PERCENTAGE && MAX_PERCENTAGE - impact > maxImpact) revert HighImpact();\\n        if (!isBuy && impact > MAX_PERCENTAGE && impact - MAX_PERCENTAGE > maxImpact) revert HighImpact();\\n        uint256 impactValue;\\n        if (isBuy && impact < MAX_PERCENTAGE) {\\n            impactValue = MAX_PERCENTAGE - impact;\\n        } else if (!isBuy && impact > MAX_PERCENTAGE) {\\n            impactValue = impact - MAX_PERCENTAGE;\\n        }\\n        return impactValue;\\n    }\\n}\\n\",\"keccak256\":\"0x96c2b97099929cfb81b5e161e3c0718952c6aea1a09573617c0dca820485b6a0\",\"license\":\"MIT\"},\"contracts/libraries/LibUtil.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nimport \\\"./LibBytes.sol\\\";\\n\\n/**\\n * @title LibUtil\\n * @dev This library provides utility functions for working with revert messages.\\n */\\nlibrary LibUtil {\\n    using LibBytes for bytes;\\n\\n    /**\\n     * @notice Get a revert message from transaction result data.\\n     * @param _res The transaction result data to extract the revert message from.\\n     * @return string The revert message or a \\\"Transaction reverted silently\\\" message if none is found.\\n     */\\n    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {\\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\\n        if (_res.length < 68) return \\\"Transaction reverted silently\\\";\\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\\n        return abi.decode(revertData, (string)); // All that remains is the revert string\\n    }\\n\\n    /**\\n     * @notice Used the get the ID of the current chain.\\n     * @return id The chain ID\\n     */\\n    function getChainID() internal view returns (uint256) {\\n        uint256 id;\\n        assembly {\\n            id := chainid()\\n        }\\n        return id;\\n    }\\n}\\n\",\"keccak256\":\"0x2ad03d87c101071a5a415a5dce0efaa23a1d9b1ea0d56fc2746094d89598e061\",\"license\":\"MIT\"},\"contracts/utils/GenericErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.20;\\n\\nerror NoSwapFromZeroBalance();\\nerror InsufficientBalance(uint256 required, uint256 balance);\\nerror SwapFailed();\\nerror TransferFailed();\\nerror InvalidExchangeRate(uint256 required, uint256 actual);\\nerror InvalidPrice();\\nerror InvalidImpact();\\nerror HighImpact();\\nerror InvalidInvestToken();\\nerror InvalidStableToken();\\nerror TokensMustDiffer();\\nerror AtLeastOneOptionRequired();\\nerror InvalidInvestAmount();\\nerror FloorValueZero();\\nerror InvalidSellType();\\nerror InvalidSellValue();\\nerror BuyAndSellAtMisorder();\\nerror InvalidStableAmount();\\nerror InvalidBuyType();\\nerror InvalidBuyValue();\\nerror InvalidFloorValue();\\nerror InvalidFloorType();\\nerror InvalidSellTypeDCA();\\nerror FloorValueGreaterThanBuyValue();\\nerror FloorValueGreaterThanSellValue();\\nerror BothBuyTwapAndBTD();\\nerror BuyDCAWithoutBuy();\\nerror BuyTwapTimeInvalid();\\nerror BuyTwapTimeUnitNotSelected();\\nerror BothSellTwapAndSTR();\\nerror SellDCAWithoutSell();\\nerror SellTwapTimeUnitNotSelected();\\nerror SellTwapTimeInvalid();\\nerror SellTwapOrStrWithoutSellDCAUnit();\\nerror SellDCAUnitWithoutSellDCAValue();\\nerror StrWithoutStrType();\\nerror BTDWithoutBTDType();\\nerror BuyDCAWithoutBuyDCAUnit();\\nerror BuyDCAUnitWithoutBuyDCAValue();\\nerror InvalidHighSellValue();\\nerror SellDCAValueRangeIsNotValid();\\nerror DCAValueShouldBeLessThanIntitialAmount();\\nerror BuyDCAValueRangeIsNotValid();\\nerror OrphandStrategy();\\nerror BuyNeverExecute();\\nerror FloorGreaterThanPrice();\\nerror FeedNotFound();\\nerror WrongPreviousIDs();\\nerror RoundDataDoesNotMatch();\\nerror StrategyIsNotActive();\\nerror InvalidNonce();\\nerror InvalidSigner();\\nerror AlreadyCancelled();\\nerror BuyNotSet();\\nerror SellNotSelected();\\nerror PercentageNotInRange();\\nerror BuyTwapNotSelected();\\nerror SellTwapNotSelected();\\nerror FloorNotSet();\\nerror ReentrancyGuardReentrantCall();\\nerror PriceNotInRange();\\n\",\"keccak256\":\"0x5e7f9fa92bca7030dbb9bbba701fbf12850c0e8ac401b0490f408d0358da57b3\",\"license\":\"MIT\"},\"contracts/utils/Modifiers.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.20;\\n\\nimport { AppStorage, FloorLegType, BuyLegType, SellLegType, TimeUnit, DIP_SPIKE, DCA_UNIT, ReentrancyStatus } from \\\"../AppStorage.sol\\\";\\nimport { ReentrancyGuardReentrantCall } from \\\"./GenericErrors.sol\\\";\\nimport { LibDiamond } from \\\"../libraries/LibDiamond.sol\\\";\\n\\nabstract contract Modifiers {\\n    /// @notice 100% = 100000 -> 2 decimals\\n\\n    modifier onlyOwner() {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n        require(msg.sender == s.owner, \\\"Modifiers: Must be contract owner\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a `nonReentrant` function from another `nonReentrant`\\n     * function is not supported. It is possible to prevent this from happening\\n     * by making the `nonReentrant` function external, and making it call a\\n     * `private` function that does the actual work.\\n     */\\n    modifier nonReentrant() {\\n        _nonReentrantBefore();\\n        _;\\n        _nonReentrantAfter();\\n    }\\n\\n    function _nonReentrantBefore() private {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n        // On the first call to nonReentrant, s.reentrancyStatus will be ReentrancyStatus.NOT_ENTERED\\n        if (s.reentrancyStatus == ReentrancyStatus.ENTERED) {\\n            revert ReentrancyGuardReentrantCall();\\n        }\\n\\n        // Any calls to nonReentrant after this point will fail\\n        s.reentrancyStatus = ReentrancyStatus.ENTERED;\\n    }\\n\\n    function _nonReentrantAfter() private {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        s.reentrancyStatus = ReentrancyStatus.NOT_ENTERED;\\n    }\\n\\n    /**\\n     * @dev Returns true if the reentrancy guard is currently set to \\\"entered\\\", which indicates there is a\\n     * `nonReentrant` function in the call stack.\\n     */\\n    function _reentrancyGuardEntered() internal view returns (bool) {\\n        AppStorage storage s = LibDiamond.diamondStorage();\\n        return s.reentrancyStatus == ReentrancyStatus.ENTERED;\\n    }\\n}\\n\",\"keccak256\":\"0x6bd19234ff15be724c86ba376048f6e577d7908cda343f5efdb37d22ad6f3216\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611b5e806100206000396000f3fe608060405234801561001057600080fd5b506004361061002b5760003560e01c80631fa7355714610030575b600080fd5b61004361003e3660046116e1565b610045565b005b61004d610690565b60008281526006602052604081206003810154909190610075906001600160a01b03166106e4565b90506000602583015460ff1660028111156100925761009261172f565b146100b05760405163432aa98d60e11b815260040160405180910390fd5b60078201546000036100d55760405163452234a560e11b815260040160405180910390fd5b60028201546000036100fa5760405163391b81e760e21b815260040160405180910390fd5b6001820154600383015460009161011d916001600160a01b0391821691166107cb565b50909150600090506001600685015460ff1660028111156101405761014061172f565b03610150575060078301546101a7565b6002600685015460ff16600281111561016b5761016b61172f565b036101a75760078401546000906101849061271061175b565b9050612710818660220154610199919061176e565b6101a39190611785565b9150505b808211156101c85760405163f4f008ab60e01b815260040160405180910390fd5b600884015460ff1615610598576040805160c08101909152600090806101f160208901896117a7565b6001600160a01b039081168252600188015481166020808401919091526003890154909116604083015260028801546060830152608090910190610237908901896117d0565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250938552505088546001600160a01b031660209093019290925291925061028e905082610b34565b600187015460028801549192506000916102b2916001600160a01b03169084610d16565b9050838111156102e45760405163ba639fe360e01b815260048101859052602481018290526044015b60405180910390fd5b6002600688015460ff1660028111156102ff576102ff61172f565b14801561030f5750600987015415155b156103e85760018701546040805163313ce56760e01b815290516000926001600160a01b03169163313ce5679160048083019260209291908290030181865afa158015610360573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610384919061181e565b61038f90600a611925565b602289015460028a01546103a3919061176e565b6103ad9190611785565b90508260006103bc828461175b565b60098b01549091508110156103e4576040516345678cb160e01b815260040160405180910390fd5b5050505b60006103fe82878a600101600401546000610daf565b60028901805460009182905560228b0182905560048b015460248c0154939450909261042a919061175b565b90508085111561046c5760048a0154610444908290611934565b60048b015560238a0154610458828761175b565b6104629190611934565b60238b0155610482565b60048a015461047c908690611934565b60048b01555b6001600f8b0154610100900460ff1660028111156104a2576104a261172f565b036104d85760048a015460108b0154612710916104be9161176e565b6104c89190611785565b601b8b015560048a0154601d8b01555b8b7f1959507cf6ec55e8b1532defb6dc573238ee7b44454fbc86d2362f4cd8ef90fa8460405180608001604052808681526020018981526020018e6001016003015481526020018e600101600101548152508c8e602201548f60230154604051610589959493929190948552835160208087019190915284015160408087019190915284015160608087019190915290930151608085015260a084019190915260c083015260e08201526101000190565b60405180910390a25050505050505b6008840154610100900460ff16156106135760018401546000906105c4906001600160a01b03166106e4565b60258601805460ff19166001179055604080518281526020810187905291925088917f8b59944fefbac177fb9b4127d4d37da2d50b72e4d47b82e54a81945b166c62cd910160405180910390a2505b6008840154610100900460ff1615801561062f5750600b840154155b156106805760258401805460ff1916600117905560408051600081526020810185905287917f8b59944fefbac177fb9b4127d4d37da2d50b72e4d47b82e54a81945b166c62cd910160405180910390a25b5050505061068c610ea7565b5050565b60006001600982015460ff1660018111156106ad576106ad61172f565b036106cb57604051633ee5aeb560e01b815260040160405180910390fd5b6009810180546001919060ff191682805b021790555050565b6001600160a01b03818116600090815260076020526040812054909182911661072057604051637d53846960e11b815260040160405180910390fd5b6001600160a01b038084166000908152600783016020526040808220548151633fabe5a360e21b815291519293169163feaf968c9160048082019260a0929091908290030181865afa15801561077a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061079e9190611966565b505050915050806000036107c45760405162bfc92160e01b815260040160405180910390fd5b9392505050565b60095460009081908190819061010090046001600160a01b031680156108ad57600080826001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa15801561082c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108509190611966565b5091945092505082159050806108785760405162032b3d60e81b815260040160405180910390fd5b6000610884834261175b565b9050610e1081116108a85760405163d15f73b560e01b815260040160405180910390fd5b505050505b6001600160a01b0387811660009081526007840160205260409020541615806108f057506001600160a01b03868116600090815260078401602052604090205416155b1561090e57604051637d53846960e11b815260040160405180910390fd5b6001600160a01b038088166000908152600784016020526040808220548151633fabe5a360e21b81529151929384938493929091169163feaf968c9160048083019260a09291908290030181865afa15801561096e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109929190611966565b506001600160a01b03808e16600090815260078b016020526040808220548151633fabe5a360e21b81529151979a509598509296509485948594509091169163feaf968c9160048083019260a09291908290030181865afa1580156109fb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a1f9190611966565b50935050925092508460001480610a34575081155b15610a515760405162bfc92160e01b815260040160405180910390fd5b600a880154610a60854261175b565b1180610a785750600a880154610a76824261175b565b115b15610a9657604051632d07c67360e01b815260040160405180910390fd5b60008c6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ad6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610afa919061181e565b60ff16905082610b0b82600a6119b6565b610b15908861176e565b610b1f9190611785565b9e969d50929b50949950505050505050505050565b6060810151600090808203610b5c5760405163391b81e760e21b815260040160405180910390fd5b610b7083602001518460a001513084610ebc565b6000610b80846040015130610fd5565b9050610b9984602001518560000151866060015161104c565b60008085600001516001600160a01b03168660800151604051610bbc91906119e6565b6000604051808303816000865af19150503d8060008114610bf9576040519150601f19603f3d011682016040523d82523d6000602084013e610bfe565b606091505b509150915081610c2f576000610c13826110e1565b90508060405162461bcd60e51b81526004016102db9190611a02565b6000610c3f876040015130610fd5565b90506000610c4d858361175b565b905080600003610c705760405163081ceff360e41b815260040160405180910390fd5b610c8388604001518960a0015183611158565b7f4abed91e53b10abbb1440578b29fa1b1d1b2fd1aea643d553ccf19cd4642f4d8886000015189602001518a604001518b60600151858d60a00151604051610d03969594939291906001600160a01b039687168152948616602086015292851660408501526060840191909152608083015290911660a082015260c00190565b60405180910390a1979650505050505050565b6000808490506000816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d80919061181e565b60ff16905084610d9182600a6119b6565b610d9b908661176e565b610da59190611785565b9695505050505050565b60008085610dbf6127108761176e565b610dc99190611785565b9050828015610dd9575061271081105b8015610def575083610ded8261271061175b565b115b15610e0d57604051630b9750cb60e41b815260040160405180910390fd5b82158015610e1c575061271081115b8015610e32575083610e306127108361175b565b115b15610e5057604051630b9750cb60e41b815260040160405180910390fd5b6000838015610e60575061271082105b15610e7857610e718261271061175b565b9050610e9b565b83158015610e87575061271082115b15610e9b57610e986127108361175b565b90505b9150505b949350505050565b60098054600091829160ff19166001836106dc565b6040516370a0823160e01b81526001600160a01b038381166004830152600091908616906370a0823190602401602060405180830381865afa158015610f06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2a9190611a35565b9050610f388585858561126f565b6040516370a0823160e01b81526001600160a01b038481166004830152839183918816906370a0823190602401602060405180830381865afa158015610f82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa69190611a35565b610fb0919061175b565b14610fce576040516312171d8360e31b815260040160405180910390fd5b5050505050565b6040516370a0823160e01b81526001600160a01b038281166004830152600091908416906370a0823190602401602060405180830381865afa15801561101f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110439190611a35565b90505b92915050565b604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015282919085169063dd62ed3e90604401602060405180830381865afa15801561109b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110bf9190611a35565b10156110dc576110d1838360006112da565b6110dc8383836112da565b505050565b606060448251101561112657505060408051808201909152601d81527f5472616e73616374696f6e2072657665727465642073696c656e746c79000000602082015290565b6000611142600480855161113a919061175b565b8591906113ef565b9050808060200190518101906107c49190611a64565b6040516370a0823160e01b81526001600160a01b038381166004830152600091908516906370a0823190602401602060405180830381865afa1580156111a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c69190611a35565b90506111d38484846114b9565b6040516370a0823160e01b81526001600160a01b038481166004830152839183918716906370a0823190602401602060405180830381865afa15801561121d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112419190611a35565b61124b919061175b565b14611269576040516312171d8360e31b815260040160405180910390fd5b50505050565b6040516001600160a01b03808516602483015283166044820152606481018290526112699085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526114e9565b8015806113545750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa15801561132e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113529190611a35565b155b6113bf5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016102db565b6040516001600160a01b0383166024820152604481018290526110dc90849063095ea7b360e01b906064016112a3565b6060816113fd81601f611934565b101561141c576040516323d5783d60e11b815260040160405180910390fd5b6114268284611934565b8451101561144757604051633b99b53d60e01b815260040160405180910390fd5b60608215801561146657604051915060008252602082016040526114b0565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561149f578051835260209283019201611487565b5050858452601f01601f1916604052505b50949350505050565b6040516001600160a01b0383166024820152604481018290526110dc90849063a9059cbb60e01b906064016112a3565b600061153e826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166115be9092919063ffffffff16565b905080516000148061155f57508080602001905181019061155f9190611b06565b6110dc5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016102db565b6060610e9f848460008585600080866001600160a01b031685876040516115e591906119e6565b60006040518083038185875af1925050503d8060008114611622576040519150601f19603f3d011682016040523d82523d6000602084013e611627565b606091505b509150915061163887838387611643565b979650505050505050565b606083156116b25782516000036116ab576001600160a01b0385163b6116ab5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102db565b5081610e9f565b610e9f83838151156116c75781518083602001fd5b8060405162461bcd60e51b81526004016102db9190611a02565b600080604083850312156116f457600080fd5b82359150602083013567ffffffffffffffff81111561171257600080fd5b83016040818603121561172457600080fd5b809150509250929050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561104657611046611745565b808202811582820484141761104657611046611745565b6000826117a257634e487b7160e01b600052601260045260246000fd5b500490565b6000602082840312156117b957600080fd5b81356001600160a01b03811681146107c457600080fd5b6000808335601e198436030181126117e757600080fd5b83018035915067ffffffffffffffff82111561180257600080fd5b60200191503681900382131561181757600080fd5b9250929050565b60006020828403121561183057600080fd5b815160ff811681146107c457600080fd5b600181815b8085111561187c57816000190482111561186257611862611745565b8085161561186f57918102915b93841c9390800290611846565b509250929050565b60008261189357506001611046565b816118a057506000611046565b81600181146118b657600281146118c0576118dc565b6001915050611046565b60ff8411156118d1576118d1611745565b50506001821b611046565b5060208310610133831016604e8410600b84101617156118ff575081810a611046565b6119098383611841565b806000190482111561191d5761191d611745565b029392505050565b600061104360ff841683611884565b8082018082111561104657611046611745565b805169ffffffffffffffffffff8116811461196157600080fd5b919050565b600080600080600060a0868803121561197e57600080fd5b61198786611947565b94506020860151935060408601519250606086015191506119aa60808701611947565b90509295509295909350565b60006110438383611884565b60005b838110156119dd5781810151838201526020016119c5565b50506000910152565b600082516119f88184602087016119c2565b9190910192915050565b6020815260008251806020840152611a218160408501602087016119c2565b601f01601f19169190910160400192915050565b600060208284031215611a4757600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b600060208284031215611a7657600080fd5b815167ffffffffffffffff80821115611a8e57600080fd5b818401915084601f830112611aa257600080fd5b815181811115611ab457611ab4611a4e565b604051601f8201601f19908116603f01168101908382118183101715611adc57611adc611a4e565b81604052828152876020848701011115611af557600080fd5b6116388360208301602088016119c2565b600060208284031215611b1857600080fd5b815180151581146107c457600080fdfea2646970667358221220b9d9034f6943720ce781ce9189356779e262e7083aa5a18739bfedf23c2124a364736f6c63430008140033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061002b5760003560e01c80631fa7355714610030575b600080fd5b61004361003e3660046116e1565b610045565b005b61004d610690565b60008281526006602052604081206003810154909190610075906001600160a01b03166106e4565b90506000602583015460ff1660028111156100925761009261172f565b146100b05760405163432aa98d60e11b815260040160405180910390fd5b60078201546000036100d55760405163452234a560e11b815260040160405180910390fd5b60028201546000036100fa5760405163391b81e760e21b815260040160405180910390fd5b6001820154600383015460009161011d916001600160a01b0391821691166107cb565b50909150600090506001600685015460ff1660028111156101405761014061172f565b03610150575060078301546101a7565b6002600685015460ff16600281111561016b5761016b61172f565b036101a75760078401546000906101849061271061175b565b9050612710818660220154610199919061176e565b6101a39190611785565b9150505b808211156101c85760405163f4f008ab60e01b815260040160405180910390fd5b600884015460ff1615610598576040805160c08101909152600090806101f160208901896117a7565b6001600160a01b039081168252600188015481166020808401919091526003890154909116604083015260028801546060830152608090910190610237908901896117d0565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920182905250938552505088546001600160a01b031660209093019290925291925061028e905082610b34565b600187015460028801549192506000916102b2916001600160a01b03169084610d16565b9050838111156102e45760405163ba639fe360e01b815260048101859052602481018290526044015b60405180910390fd5b6002600688015460ff1660028111156102ff576102ff61172f565b14801561030f5750600987015415155b156103e85760018701546040805163313ce56760e01b815290516000926001600160a01b03169163313ce5679160048083019260209291908290030181865afa158015610360573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610384919061181e565b61038f90600a611925565b602289015460028a01546103a3919061176e565b6103ad9190611785565b90508260006103bc828461175b565b60098b01549091508110156103e4576040516345678cb160e01b815260040160405180910390fd5b5050505b60006103fe82878a600101600401546000610daf565b60028901805460009182905560228b0182905560048b015460248c0154939450909261042a919061175b565b90508085111561046c5760048a0154610444908290611934565b60048b015560238a0154610458828761175b565b6104629190611934565b60238b0155610482565b60048a015461047c908690611934565b60048b01555b6001600f8b0154610100900460ff1660028111156104a2576104a261172f565b036104d85760048a015460108b0154612710916104be9161176e565b6104c89190611785565b601b8b015560048a0154601d8b01555b8b7f1959507cf6ec55e8b1532defb6dc573238ee7b44454fbc86d2362f4cd8ef90fa8460405180608001604052808681526020018981526020018e6001016003015481526020018e600101600101548152508c8e602201548f60230154604051610589959493929190948552835160208087019190915284015160408087019190915284015160608087019190915290930151608085015260a084019190915260c083015260e08201526101000190565b60405180910390a25050505050505b6008840154610100900460ff16156106135760018401546000906105c4906001600160a01b03166106e4565b60258601805460ff19166001179055604080518281526020810187905291925088917f8b59944fefbac177fb9b4127d4d37da2d50b72e4d47b82e54a81945b166c62cd910160405180910390a2505b6008840154610100900460ff1615801561062f5750600b840154155b156106805760258401805460ff1916600117905560408051600081526020810185905287917f8b59944fefbac177fb9b4127d4d37da2d50b72e4d47b82e54a81945b166c62cd910160405180910390a25b5050505061068c610ea7565b5050565b60006001600982015460ff1660018111156106ad576106ad61172f565b036106cb57604051633ee5aeb560e01b815260040160405180910390fd5b6009810180546001919060ff191682805b021790555050565b6001600160a01b03818116600090815260076020526040812054909182911661072057604051637d53846960e11b815260040160405180910390fd5b6001600160a01b038084166000908152600783016020526040808220548151633fabe5a360e21b815291519293169163feaf968c9160048082019260a0929091908290030181865afa15801561077a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061079e9190611966565b505050915050806000036107c45760405162bfc92160e01b815260040160405180910390fd5b9392505050565b60095460009081908190819061010090046001600160a01b031680156108ad57600080826001600160a01b031663feaf968c6040518163ffffffff1660e01b815260040160a060405180830381865afa15801561082c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108509190611966565b5091945092505082159050806108785760405162032b3d60e81b815260040160405180910390fd5b6000610884834261175b565b9050610e1081116108a85760405163d15f73b560e01b815260040160405180910390fd5b505050505b6001600160a01b0387811660009081526007840160205260409020541615806108f057506001600160a01b03868116600090815260078401602052604090205416155b1561090e57604051637d53846960e11b815260040160405180910390fd5b6001600160a01b038088166000908152600784016020526040808220548151633fabe5a360e21b81529151929384938493929091169163feaf968c9160048083019260a09291908290030181865afa15801561096e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109929190611966565b506001600160a01b03808e16600090815260078b016020526040808220548151633fabe5a360e21b81529151979a509598509296509485948594509091169163feaf968c9160048083019260a09291908290030181865afa1580156109fb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a1f9190611966565b50935050925092508460001480610a34575081155b15610a515760405162bfc92160e01b815260040160405180910390fd5b600a880154610a60854261175b565b1180610a785750600a880154610a76824261175b565b115b15610a9657604051632d07c67360e01b815260040160405180910390fd5b60008c6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ad6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610afa919061181e565b60ff16905082610b0b82600a6119b6565b610b15908861176e565b610b1f9190611785565b9e969d50929b50949950505050505050505050565b6060810151600090808203610b5c5760405163391b81e760e21b815260040160405180910390fd5b610b7083602001518460a001513084610ebc565b6000610b80846040015130610fd5565b9050610b9984602001518560000151866060015161104c565b60008085600001516001600160a01b03168660800151604051610bbc91906119e6565b6000604051808303816000865af19150503d8060008114610bf9576040519150601f19603f3d011682016040523d82523d6000602084013e610bfe565b606091505b509150915081610c2f576000610c13826110e1565b90508060405162461bcd60e51b81526004016102db9190611a02565b6000610c3f876040015130610fd5565b90506000610c4d858361175b565b905080600003610c705760405163081ceff360e41b815260040160405180910390fd5b610c8388604001518960a0015183611158565b7f4abed91e53b10abbb1440578b29fa1b1d1b2fd1aea643d553ccf19cd4642f4d8886000015189602001518a604001518b60600151858d60a00151604051610d03969594939291906001600160a01b039687168152948616602086015292851660408501526060840191909152608083015290911660a082015260c00190565b60405180910390a1979650505050505050565b6000808490506000816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d80919061181e565b60ff16905084610d9182600a6119b6565b610d9b908661176e565b610da59190611785565b9695505050505050565b60008085610dbf6127108761176e565b610dc99190611785565b9050828015610dd9575061271081105b8015610def575083610ded8261271061175b565b115b15610e0d57604051630b9750cb60e41b815260040160405180910390fd5b82158015610e1c575061271081115b8015610e32575083610e306127108361175b565b115b15610e5057604051630b9750cb60e41b815260040160405180910390fd5b6000838015610e60575061271082105b15610e7857610e718261271061175b565b9050610e9b565b83158015610e87575061271082115b15610e9b57610e986127108361175b565b90505b9150505b949350505050565b60098054600091829160ff19166001836106dc565b6040516370a0823160e01b81526001600160a01b038381166004830152600091908616906370a0823190602401602060405180830381865afa158015610f06573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f2a9190611a35565b9050610f388585858561126f565b6040516370a0823160e01b81526001600160a01b038481166004830152839183918816906370a0823190602401602060405180830381865afa158015610f82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fa69190611a35565b610fb0919061175b565b14610fce576040516312171d8360e31b815260040160405180910390fd5b5050505050565b6040516370a0823160e01b81526001600160a01b038281166004830152600091908416906370a0823190602401602060405180830381865afa15801561101f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110439190611a35565b90505b92915050565b604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015282919085169063dd62ed3e90604401602060405180830381865afa15801561109b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110bf9190611a35565b10156110dc576110d1838360006112da565b6110dc8383836112da565b505050565b606060448251101561112657505060408051808201909152601d81527f5472616e73616374696f6e2072657665727465642073696c656e746c79000000602082015290565b6000611142600480855161113a919061175b565b8591906113ef565b9050808060200190518101906107c49190611a64565b6040516370a0823160e01b81526001600160a01b038381166004830152600091908516906370a0823190602401602060405180830381865afa1580156111a2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111c69190611a35565b90506111d38484846114b9565b6040516370a0823160e01b81526001600160a01b038481166004830152839183918716906370a0823190602401602060405180830381865afa15801561121d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112419190611a35565b61124b919061175b565b14611269576040516312171d8360e31b815260040160405180910390fd5b50505050565b6040516001600160a01b03808516602483015283166044820152606481018290526112699085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526114e9565b8015806113545750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa15801561132e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113529190611a35565b155b6113bf5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016102db565b6040516001600160a01b0383166024820152604481018290526110dc90849063095ea7b360e01b906064016112a3565b6060816113fd81601f611934565b101561141c576040516323d5783d60e11b815260040160405180910390fd5b6114268284611934565b8451101561144757604051633b99b53d60e01b815260040160405180910390fd5b60608215801561146657604051915060008252602082016040526114b0565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561149f578051835260209283019201611487565b5050858452601f01601f1916604052505b50949350505050565b6040516001600160a01b0383166024820152604481018290526110dc90849063a9059cbb60e01b906064016112a3565b600061153e826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166115be9092919063ffffffff16565b905080516000148061155f57508080602001905181019061155f9190611b06565b6110dc5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016102db565b6060610e9f848460008585600080866001600160a01b031685876040516115e591906119e6565b60006040518083038185875af1925050503d8060008114611622576040519150601f19603f3d011682016040523d82523d6000602084013e611627565b606091505b509150915061163887838387611643565b979650505050505050565b606083156116b25782516000036116ab576001600160a01b0385163b6116ab5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016102db565b5081610e9f565b610e9f83838151156116c75781518083602001fd5b8060405162461bcd60e51b81526004016102db9190611a02565b600080604083850312156116f457600080fd5b82359150602083013567ffffffffffffffff81111561171257600080fd5b83016040818603121561172457600080fd5b809150509250929050565b634e487b7160e01b600052602160045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8181038181111561104657611046611745565b808202811582820484141761104657611046611745565b6000826117a257634e487b7160e01b600052601260045260246000fd5b500490565b6000602082840312156117b957600080fd5b81356001600160a01b03811681146107c457600080fd5b6000808335601e198436030181126117e757600080fd5b83018035915067ffffffffffffffff82111561180257600080fd5b60200191503681900382131561181757600080fd5b9250929050565b60006020828403121561183057600080fd5b815160ff811681146107c457600080fd5b600181815b8085111561187c57816000190482111561186257611862611745565b8085161561186f57918102915b93841c9390800290611846565b509250929050565b60008261189357506001611046565b816118a057506000611046565b81600181146118b657600281146118c0576118dc565b6001915050611046565b60ff8411156118d1576118d1611745565b50506001821b611046565b5060208310610133831016604e8410600b84101617156118ff575081810a611046565b6119098383611841565b806000190482111561191d5761191d611745565b029392505050565b600061104360ff841683611884565b8082018082111561104657611046611745565b805169ffffffffffffffffffff8116811461196157600080fd5b919050565b600080600080600060a0868803121561197e57600080fd5b61198786611947565b94506020860151935060408601519250606086015191506119aa60808701611947565b90509295509295909350565b60006110438383611884565b60005b838110156119dd5781810151838201526020016119c5565b50506000910152565b600082516119f88184602087016119c2565b9190910192915050565b6020815260008251806020840152611a218160408501602087016119c2565b601f01601f19169190910160400192915050565b600060208284031215611a4757600080fd5b5051919050565b634e487b7160e01b600052604160045260246000fd5b600060208284031215611a7657600080fd5b815167ffffffffffffffff80821115611a8e57600080fd5b818401915084601f830112611aa257600080fd5b815181811115611ab457611ab4611a4e565b604051601f8201601f19908116603f01168101908382118183101715611adc57611adc611a4e565b81604052828152876020848701011115611af557600080fd5b6116388360208301602088016119c2565b600060208284031215611b1857600080fd5b815180151581146107c457600080fdfea2646970667358221220b9d9034f6943720ce781ce9189356779e262e7083aa5a18739bfedf23c2124a364736f6c63430008140033",
  "devdoc": {
    "details": "FloorFacet specializes in verifying floor price conditions, handling liquidation actions when the floor price is reached,      ensuring that the necessary criteria are met before taking any actions and also cancelling the strategy if provided.",
    "events": {
      "AssetSwapped(address,address,address,uint256,uint256,address)": {
        "params": {
          "account": "The address of the user account that initiated the swap.",
          "dex": "The address of the contract or dex used for the swap.",
          "fromAmount": "The amount of 'fromAsset' that was swapped.",
          "fromAsset": "The address of the asset swapped from.",
          "receivedAmount": "The amount of 'toAsset' received in the swap.",
          "toAsset": "The address of the asset received in the swap."
        }
      },
      "FloorExecuted(uint256,uint256,(uint256,uint256,uint256,uint256),uint256,uint256,uint256)": {
        "params": {
          "impact": "The allowable price impact percentage for the buy action.",
          "investPrice": "the average price at which invest tokens were bought.",
          "profit": "it is the profit made by the strategy.",
          "stablePriceInUSD": "price of stable token in USD",
          "strategyId": "The unique ID of the strategy where the floor execution is initiated.",
          "tokens": "tokens substracted and added into the users wallet"
        }
      },
      "StrategyCancelled(uint256,uint256,uint256)": {
        "params": {
          "investTokenPrice": "The price of the invest token in USD.",
          "stableTokenPrice": "The price of the stable token in USD.",
          "strategyId": "The unique ID of the cancelled strategy."
        }
      }
    },
    "kind": "dev",
    "methods": {
      "executeFloor(uint256,(address,bytes))": {
        "details": "This function performs a floor price check and, if the strategy's parameters meet the required conditions,      it may execute a liquidation of assets. Liquidation occurs if the strategy's floor price is reached and      liquidation is enabled in the strategy parameters.",
        "params": {
          "dexSwap": "The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.",
          "strategyId": "The unique ID of the strategy to execute the floor check for."
        }
      }
    },
    "title": "FloorFacet",
    "version": 1
  },
  "userdoc": {
    "events": {
      "AssetSwapped(address,address,address,uint256,uint256,address)": {
        "notice": "Emitted when an asset swap has been executed successfully."
      },
      "FloorExecuted(uint256,uint256,(uint256,uint256,uint256,uint256),uint256,uint256,uint256)": {
        "notice": "Emitted when a floor execution is initiated for a trading strategy."
      },
      "StrategyCancelled(uint256,uint256,uint256)": {
        "notice": "Emitted when a trade execution strategy is cancelled."
      }
    },
    "kind": "user",
    "methods": {
      "executeFloor(uint256,(address,bytes))": {
        "notice": "Execute a floor price check and potential liquidation for a trading strategy."
      }
    },
    "notice": "This facet contains functions responsible for evaluating conditions related to the floor price and liquidation events.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 3526,
        "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
        "label": "s",
        "offset": 0,
        "slot": "0",
        "type": "t_struct(AppStorage)1254_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_enum(BuyLegType)1083": {
        "encoding": "inplace",
        "label": "enum BuyLegType",
        "numberOfBytes": "1"
      },
      "t_enum(DCA_UNIT)1100": {
        "encoding": "inplace",
        "label": "enum DCA_UNIT",
        "numberOfBytes": "1"
      },
      "t_enum(DIP_SPIKE)1095": {
        "encoding": "inplace",
        "label": "enum DIP_SPIKE",
        "numberOfBytes": "1"
      },
      "t_enum(FloorLegType)1079": {
        "encoding": "inplace",
        "label": "enum FloorLegType",
        "numberOfBytes": "1"
      },
      "t_enum(ReentrancyStatus)1069": {
        "encoding": "inplace",
        "label": "enum ReentrancyStatus",
        "numberOfBytes": "1"
      },
      "t_enum(SellLegType)1088": {
        "encoding": "inplace",
        "label": "enum SellLegType",
        "numberOfBytes": "1"
      },
      "t_enum(Status)1074": {
        "encoding": "inplace",
        "label": "enum Status",
        "numberOfBytes": "1"
      },
      "t_enum(TimeUnit)1105": {
        "encoding": "inplace",
        "label": "enum TimeUnit",
        "numberOfBytes": "1"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_mapping(t_bytes4,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_bytes4,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint256,t_bytes32)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => bytes32)",
        "numberOfBytes": "32",
        "value": "t_bytes32"
      },
      "t_mapping(t_uint256,t_struct(Strategy)1214_storage)": {
        "encoding": "mapping",
        "key": "t_uint256",
        "label": "mapping(uint256 => struct Strategy)",
        "numberOfBytes": "32",
        "value": "t_struct(Strategy)1214_storage"
      },
      "t_struct(AppStorage)1254_storage": {
        "encoding": "inplace",
        "label": "struct AppStorage",
        "members": [
          {
            "astId": 1219,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "facets",
            "offset": 0,
            "slot": "0",
            "type": "t_mapping(t_bytes4,t_bytes32)"
          },
          {
            "astId": 1223,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "selectorSlots",
            "offset": 0,
            "slot": "1",
            "type": "t_mapping(t_uint256,t_bytes32)"
          },
          {
            "astId": 1225,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "selectorCount",
            "offset": 0,
            "slot": "2",
            "type": "t_uint16"
          },
          {
            "astId": 1229,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "supportedInterfaces",
            "offset": 0,
            "slot": "3",
            "type": "t_mapping(t_bytes4,t_bool)"
          },
          {
            "astId": 1231,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "owner",
            "offset": 0,
            "slot": "4",
            "type": "t_address"
          },
          {
            "astId": 1233,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "nextStrategyId",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 1238,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "strategies",
            "offset": 0,
            "slot": "6",
            "type": "t_mapping(t_uint256,t_struct(Strategy)1214_storage)"
          },
          {
            "astId": 1242,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "feeds",
            "offset": 0,
            "slot": "7",
            "type": "t_mapping(t_address,t_address)"
          },
          {
            "astId": 1246,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "nonces",
            "offset": 0,
            "slot": "8",
            "type": "t_mapping(t_address,t_uint256)"
          },
          {
            "astId": 1249,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "reentrancyStatus",
            "offset": 0,
            "slot": "9",
            "type": "t_enum(ReentrancyStatus)1069"
          },
          {
            "astId": 1251,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "sequencerUptimeFeed",
            "offset": 1,
            "slot": "9",
            "type": "t_address"
          },
          {
            "astId": 1253,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "maxStalePeriod",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "352"
      },
      "t_struct(Strategy)1214_storage": {
        "encoding": "inplace",
        "label": "struct Strategy",
        "members": [
          {
            "astId": 1181,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "user",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 1184,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "parameters",
            "offset": 0,
            "slot": "1",
            "type": "t_struct(StrategyParameters)1178_storage"
          },
          {
            "astId": 1186,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "sellPercentageAmount",
            "offset": 0,
            "slot": "26",
            "type": "t_uint256"
          },
          {
            "astId": 1188,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "buyPercentageAmount",
            "offset": 0,
            "slot": "27",
            "type": "t_uint256"
          },
          {
            "astId": 1190,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "sellPercentageTotalAmount",
            "offset": 0,
            "slot": "28",
            "type": "t_uint256"
          },
          {
            "astId": 1192,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "buyPercentageTotalAmount",
            "offset": 0,
            "slot": "29",
            "type": "t_uint256"
          },
          {
            "astId": 1194,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "sellTwapExecutedAt",
            "offset": 0,
            "slot": "30",
            "type": "t_uint256"
          },
          {
            "astId": 1196,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "buyTwapExecutedAt",
            "offset": 0,
            "slot": "31",
            "type": "t_uint256"
          },
          {
            "astId": 1198,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "investRoundIdForBTD",
            "offset": 0,
            "slot": "32",
            "type": "t_uint80"
          },
          {
            "astId": 1200,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "stableRoundIdForBTD",
            "offset": 10,
            "slot": "32",
            "type": "t_uint80"
          },
          {
            "astId": 1202,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "investRoundIdForSTR",
            "offset": 20,
            "slot": "32",
            "type": "t_uint80"
          },
          {
            "astId": 1204,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "stableRoundIdForSTR",
            "offset": 0,
            "slot": "33",
            "type": "t_uint80"
          },
          {
            "astId": 1206,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "investPrice",
            "offset": 0,
            "slot": "34",
            "type": "t_uint256"
          },
          {
            "astId": 1208,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "profit",
            "offset": 0,
            "slot": "35",
            "type": "t_uint256"
          },
          {
            "astId": 1210,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "budget",
            "offset": 0,
            "slot": "36",
            "type": "t_uint256"
          },
          {
            "astId": 1213,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "status",
            "offset": 0,
            "slot": "37",
            "type": "t_enum(Status)1074"
          }
        ],
        "numberOfBytes": "1216"
      },
      "t_struct(StrategyParameters)1178_storage": {
        "encoding": "inplace",
        "label": "struct StrategyParameters",
        "members": [
          {
            "astId": 1108,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_investToken",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 1110,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_investAmount",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 1112,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_stableToken",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 1114,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_stableAmount",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 1116,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_impact",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 1119,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_floorType",
            "offset": 0,
            "slot": "5",
            "type": "t_enum(FloorLegType)1079"
          },
          {
            "astId": 1121,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_floorValue",
            "offset": 0,
            "slot": "6",
            "type": "t_uint256"
          },
          {
            "astId": 1123,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_liquidateOnFloor",
            "offset": 0,
            "slot": "7",
            "type": "t_bool"
          },
          {
            "astId": 1125,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_cancelOnFloor",
            "offset": 1,
            "slot": "7",
            "type": "t_bool"
          },
          {
            "astId": 1127,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_minimumLoss",
            "offset": 0,
            "slot": "8",
            "type": "t_uint256"
          },
          {
            "astId": 1130,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_buyType",
            "offset": 0,
            "slot": "9",
            "type": "t_enum(BuyLegType)1083"
          },
          {
            "astId": 1132,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_buyValue",
            "offset": 0,
            "slot": "10",
            "type": "t_uint256"
          },
          {
            "astId": 1134,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_buyTwapTime",
            "offset": 0,
            "slot": "11",
            "type": "t_uint256"
          },
          {
            "astId": 1137,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_buyTwapTimeUnit",
            "offset": 0,
            "slot": "12",
            "type": "t_enum(TimeUnit)1105"
          },
          {
            "astId": 1139,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_btdValue",
            "offset": 0,
            "slot": "13",
            "type": "t_uint256"
          },
          {
            "astId": 1142,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_btdType",
            "offset": 0,
            "slot": "14",
            "type": "t_enum(DIP_SPIKE)1095"
          },
          {
            "astId": 1145,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_buyDCAUnit",
            "offset": 1,
            "slot": "14",
            "type": "t_enum(DCA_UNIT)1100"
          },
          {
            "astId": 1147,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_buyDCAValue",
            "offset": 0,
            "slot": "15",
            "type": "t_uint256"
          },
          {
            "astId": 1150,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_sellType",
            "offset": 0,
            "slot": "16",
            "type": "t_enum(SellLegType)1088"
          },
          {
            "astId": 1152,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_sellValue",
            "offset": 0,
            "slot": "17",
            "type": "t_uint256"
          },
          {
            "astId": 1154,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_highSellValue",
            "offset": 0,
            "slot": "18",
            "type": "t_uint256"
          },
          {
            "astId": 1156,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_minimumProfit",
            "offset": 0,
            "slot": "19",
            "type": "t_uint256"
          },
          {
            "astId": 1158,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_strValue",
            "offset": 0,
            "slot": "20",
            "type": "t_uint256"
          },
          {
            "astId": 1161,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_strType",
            "offset": 0,
            "slot": "21",
            "type": "t_enum(DIP_SPIKE)1095"
          },
          {
            "astId": 1164,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_sellDCAUnit",
            "offset": 1,
            "slot": "21",
            "type": "t_enum(DCA_UNIT)1100"
          },
          {
            "astId": 1166,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_sellDCAValue",
            "offset": 0,
            "slot": "22",
            "type": "t_uint256"
          },
          {
            "astId": 1168,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_sellTwapTime",
            "offset": 0,
            "slot": "23",
            "type": "t_uint256"
          },
          {
            "astId": 1171,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_sellTwapTimeUnit",
            "offset": 0,
            "slot": "24",
            "type": "t_enum(TimeUnit)1105"
          },
          {
            "astId": 1173,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_completeOnSell",
            "offset": 1,
            "slot": "24",
            "type": "t_bool"
          },
          {
            "astId": 1175,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_current_price_sell",
            "offset": 2,
            "slot": "24",
            "type": "t_bool"
          },
          {
            "astId": 1177,
            "contract": "contracts/facets/FloorFacet.sol:FloorFacet",
            "label": "_current_price_buy",
            "offset": 3,
            "slot": "24",
            "type": "t_bool"
          }
        ],
        "numberOfBytes": "800"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint80": {
        "encoding": "inplace",
        "label": "uint80",
        "numberOfBytes": "10"
      }
    }
  }
}
