{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @notice The `Status` enum represents the possible statuses of a trading strategy.\n * @dev This enum defines three status options that describe the state of a strategy:\n *      - ACTIVE: The strategy is currently active and operational.\n *      - CANCELLED: The strategy has been cancelled and is no longer in effect.\n *      - COMPLETED: The strategy has been successfully completed.\n */\nenum Status {\n    ACTIVE, // The strategy is currently active.\n    CANCELLED, // The strategy has been cancelled.\n    COMPLETED // The strategy has been successfully completed.\n}\n\n/**\n * @notice The `FloorLegType` enum defines the types of floor price legs for trading strategies.\n * @dev This enum enumerates three possible types of floor price legs that can be associated with a strategy:\n *      - NO_TYPE: No specific floor price leg is defined.\n *      - LIMIT_PRICE: The floor price is set as a specific limit price.\n *      - DECREASE_BY: The floor price is determined by decreasing the current price by a certain amount.\n */\nenum FloorLegType {\n    NO_TYPE, // No specific floor price leg is defined.\n    LIMIT_PRICE, // The floor price is set as a specific limit price.\n    DECREASE_BY // The floor price is determined by decreasing the current price by a certain amount.\n}\n/**\n * @notice The `BuyLegType` enum defines the types of buy legs for trading strategies.\n * @dev This enum enumerates two possible types of buy legs that can be associated with a strategy:\n *      - NO_TYPE: No specific buy leg is defined.\n *      - LIMIT_PRICE: The buy leg is set as a specific limit price.\n */\nenum BuyLegType {\n    NO_TYPE, // No specific buy leg is defined.\n    LIMIT_PRICE // The buy leg is set as a specific limit price.\n}\n\n/**\n * @notice The `SellLegType` enum defines the types of sell legs for trading strategies.\n * @dev This enum enumerates three possible types of sell legs that can be associated with a strategy:\n *      - NO_TYPE: No specific sell leg is defined.\n *      - LIMIT_PRICE: The sell leg is set as a specific limit price.\n *      - INCREASE_BY: The sell leg is determined by increasing the current price by a certain amount.\n */\nenum SellLegType {\n    NO_TYPE, // No specific sell leg is defined.\n    LIMIT_PRICE, // The sell leg is set as a specific limit price.\n    INCREASE_BY // The sell leg is determined by increasing the current price by a certain amount.\n}\n\n/**\n * @notice The `DIP_SPIKE` enum defines the types of dip and spike conditions for trading strategies.\n * @dev This enum enumerates five possible types of dip and spike conditions that can be associated with a strategy:\n *      - NO_SPIKE: No specific dip or spike condition is defined.\n *      - DECREASE_BY: The condition is based on a decrease in price by a certain percentage.\n *      - INCREASE_BY: The condition is based on an increase in price by a certain percentage.\n *      - FIXED_INCREASE: The condition is based on a fixed increase in price.\n *      - FIXED_DECREASE: The condition is based on a fixed decrease in price.\n */\nenum DIP_SPIKE {\n    NO_SPIKE, // No specific dip or spike condition is defined.\n    DECREASE_BY, // The condition is based on a decrease in price by a certain percentage.\n    INCREASE_BY, // The condition is based on an increase in price by a certain percentage.\n    FIXED_INCREASE, // The condition is based on a fixed increase in price.\n    FIXED_DECREASE // The condition is based on a fixed decrease in price.\n}\n\n/**\n * @notice The `DCA_UNIT` enum defines the units for Dollar-Cost Averaging (DCA) in trading strategies.\n * @dev This enum enumerates three possible units for DCA that can be associated with a strategy:\n *      - NO_UNIT: No specific DCA unit is defined.\n *      - PERCENTAGE: DCA is specified as a percentage of assets.\n *      - FIXED: DCA is specified as a fixed amount.\n */\nenum DCA_UNIT {\n    NO_UNIT, // No specific DCA unit is defined.\n    PERCENTAGE, // DCA is specified as a percentage of assets.\n    FIXED // DCA is specified as a fixed amount.\n}\n\n/**\n * @notice The `CURRENT_PRICE` enum defines the options for selecting the current price source in trading strategies.\n * @dev This enum enumerates four possible options for selecting the current price source:\n *      - NOT_SELECTED: No specific current price source is selected.\n *      - BUY_CURRENT: The current price source is selected for buy actions.\n *      - SELL_CURRENT: The current price source is selected for sell actions.\n *      - EXECUTED: The current price source is selected for executed actions.\n */\nenum CURRENT_PRICE {\n    NOT_SELECTED, // No specific current price source is selected.\n    BUY_CURRENT, // The current price source is selected for buy actions.\n    SELL_CURRENT, // The current price source is selected for sell actions.\n    EXECUTED // The current price source is selected for executed actions.\n}\n\n/**\n * @notice The `TimeUnit` enum defines the units of time for time-related settings in trading strategies.\n * @dev This enum enumerates three possible time units that can be used in trading strategies:\n *      - NO_UNIT: No specific time unit is defined.\n *      - HOURS: Time is measured in hours.\n *      - DAYS: Time is measured in days.\n */\nenum TimeUnit {\n    NO_UNIT, // No specific time unit is defined.\n    HOURS, // Time is measured in hours.\n    DAYS // Time is measured in days.\n}\n\n/**\n * @notice The `StrategyParameters` struct defines the parameters that configure a trading strategy.\n * @dev These parameters dictate the behavior of the strategy, including trading details, conditions, and actions.\n */\n\nstruct StrategyParameters {\n    // @param _investToken The address of the investment token.\n    address _investToken;\n    // @param _investAmount The amount of investment token to be used.\n    uint256 _investAmount;\n    // @param _stableToken The address of the stable token.\n    address _stableToken;\n    // @param _stableAmount The amount of stable token to be used.\n    uint256 _stableAmount;\n    // @param _slippage The slippage tolerance for the strategy.\n    uint256 _slippage;\n    //  @param _floor A flag indicating whether a floor price is set.\n    bool _floor;\n    // @param _floorType The type of floor price (if floor is set).\n    FloorLegType _floorType;\n    // @param _floorValue The value of the floor price (if floor is set).\n    uint256 _floorValue;\n    // @param _liquidateOnFloor A flag to trigger liquidation when the floor price is reached (if floor is set)..\n    bool _liquidateOnFloor;\n    // @param _cancelOnFloor A flag to cancel the strategy when the floor price is reached (if floor is set).\n    bool _cancelOnFloor;\n    // @param _buy A flag indicating whether a buy price is set.\n    bool _buy;\n    // @param _buyType The type of buy action (if buy is set).\n    BuyLegType _buyType;\n    // @param _buyValue The value of the buy action (if buy is set).\n    uint256 _buyValue;\n    //  @param _buyTwap A flag indicating the use of TWAP for buying (if buy is set).\n    bool _buyTwap;\n    // @param _buyTwapTime The time interval for TWAP buying (if buy is set).\n    uint256 _buyTwapTime;\n    // @param _buyTwapTimeUnit The unit of time for TWAP buying .\n    TimeUnit _buyTwapTimeUnit;\n    // @param _btd A flag indicating a buy the dip action (if buy is set).\n    bool _btd;\n    // @param _btdValue The value for buying the dip (if buy is set).\n    uint256 _btdValue;\n    // @param _btdType The type of buy the dip action (if buy is set).\n    DIP_SPIKE _btdType;\n    // @param _buyDCAUnit The unit for buy DCA (Dollar-Cost Averaging) for stable amount (if buy is set).\n    DCA_UNIT _buyDCAUnit;\n    // @param _buyDCAValue The value for buy DCA.\n    uint256 _buyDCAValue;\n    // @param _sell A flag indicating whether a sell price is set.\n    bool _sell;\n    // @param _sellType The type of sell action (if sell is set).\n    SellLegType _sellType;\n    // @param _sellValue The value of the sell action (if sell is set).\n    uint256 _sellValue;\n    // @param if sell DCA is selected, _highSellValue is used to trigger complete sell when the high sell value is reached (if sell is set).\n    uint256 _highSellValue;\n    // @param _str A flag indicating whether Sell the rally feature of the Sell DCA is selected or not (if sell is set).\n    bool _str;\n    // @param _strValue The value of the str if it is set to true (if sell is set).\n    uint256 _strValue;\n    // @param _strType The type of str.\n    DIP_SPIKE _strType;\n    // @param _sellDCAUnit The unit for sell DCA (Dollar-Cost Averaging) for the invest amount (if sell is set).\n    DCA_UNIT _sellDCAUnit;\n    // @param _sellDCAValue The value for sell DCA.\n    uint256 _sellDCAValue;\n    // @param _sellTwap A flag indicating the use of TWAP (Time-Weighted Average Price) for selling (if sell is set).\n    bool _sellTwap;\n    // @param _sellTwapTime The time interval for TWAP selling (if sell is set).\n    uint256 _sellTwapTime;\n    //  @param _sellTwapTimeUnit The unit of time for TWAP selling (if sell is set).\n    TimeUnit _sellTwapTimeUnit;\n    // @param _completeOnSell A flag to complete the strategy on selling (if sell is set).\n    bool _completeOnSell;\n    // @param _current_price The current price indicator is selected what kind of strategy to execute immediately.\n    CURRENT_PRICE _current_price;\n}\n\n/**\n * @notice The `Strategy` struct defines the characteristics and status of a trading strategy.\n * @dev This struct encapsulates important data related to a trading strategy, including user ownership,\n *      strategy parameters, execution times, financial metrics, and its current status.\n * it is mostly used for internal computation\n */\n\nstruct Strategy {\n    //  @param user The address of the strategy owner.\n    address user;\n    // @param parameters The parameters that configure the behavior of the strategy\n    // as passed by the user and defined above\n    StrategyParameters parameters;\n    //  @param sellTwapExecutedAt The timestamp of the last executed TWAP (Time-Weighted Average Price) sell.\n    //  if sell twap is set for the sell. Otherwise it remains 0\n    uint256 sellTwapExecutedAt;\n    //  @param buyTwapExecutedAt The timestamp of the last executed TWAP buy.\n    //  if buy Twap is set for btd. Otherwise it remains 0.\n    uint256 buyTwapExecutedAt;\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 investRoundId;\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 stableRoundId;\n    // @param investPrice The price at which investment is made.\n    //While creating strategy it is set to the current price\n    uint256 investPrice;\n    //  @param profit The current profit generated by the strategy.\n    uint256 profit;\n    //  @param budget The available budget for the strategy.\n    // it is set at the starting of the strategy\n    uint256 budget;\n    // @param status The current status of the strategy.\n    Status status;\n}\n/**\n * @notice AppStorage is the central storage structure for this contract, holding essential data.\n * @dev This struct contains critical information used by the contract for operation.\n * It stores data such as function selectors, supported interfaces, the contract owner, strategy details,\n * Chainlink feed information, and more.\n */\n\nstruct AppStorage {\n    // maps function selectors to the facets that execute the functions.\n    // and maps the selectors to their position in the selectorSlots array.\n    // func selector => address facet, selector position\n    mapping(bytes4 => bytes32) facets;\n    // array of slots of function selectors.\n    // each slot holds 8 function selectors.\n    mapping(uint256 => bytes32) selectorSlots;\n    // The number of function selectors in selectorSlots\n    uint16 selectorCount;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address owner;\n    // next id to use for strategies\n    uint256 nextStrategyId;\n    // array of strategies\n    mapping(uint256 => Strategy) strategies;\n    // chainlink feeds - asset => USD feed\n    mapping(address => address) feeds;\n    // account => nonce\n    mapping(address => uint256) nonces;\n}\n\n/**\n * @title Swap\n * @dev A struct representing a swap or trade operation on a decentralized exchange (DEX).\n *  @param dex: The address of the DEX where the swap is to be executed.\n *  @param callData: Encoded data containing instructions for the swap on the specified DEX.\n */\nstruct Swap {\n    address dex;\n    bytes callData;\n}\n"
    },
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\nimport { AppStorage } from \"./AppStorage.sol\";\n\ncontract Diamond {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        LibDiamond.setContractOwner(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](1);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        cut[0] = IDiamondCut.FacetCut({\n            facetAddress: _diamondCutFacet,\n            action: IDiamondCut.FacetCutAction.Add,\n            functionSelectors: functionSelectors\n        });\n        LibDiamond.diamondCut(cut, address(0), \"\");\n    }\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        // get facet from function selector\n        address facet = address(bytes20(s.facets[msg.sig]));\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n            // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n            // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n            // get any return value\n            returndatacopy(0, 0, returndatasize())\n            // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/facets/BuyFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { AppStorage, Strategy, Status, DCA_UNIT, DIP_SPIKE, SellLegType, BuyLegType, FloorLegType, CURRENT_PRICE, Swap } from \"../AppStorage.sol\";\nimport { LibSwap } from \"../libraries/LibSwap.sol\";\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, FloorGreaterThanPrice, WrongPreviousIDs, RoundDataDoesNotMatch, StrategyIsNotActive } from \"../utils/GenericErrors.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport { LibTime } from \"../libraries/LibTime.sol\";\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\n\nerror BuyNotSet();\nerror BuyDCAIsSet();\nerror BuyTwapNotSelected();\nerror ExpectedTimeNotElapsed();\nerror BTDNotSelected();\nerror PriceIsGreaterThanBuyValue();\nerror PriceDippedBelowFloorValue();\n\n/**\n * @title BuyFacet\n * @notice This facet contains functions responsible for evaluating conditions necessary for executing buy actions.\n * @dev BuyFacet specializes in verifying conditions related to limit price buys and Dollar-Cost Averaging (DCA) buys,\n *      ensuring that the necessary criteria are met before executing a buy action.\n */\n\ncontract BuyFacet is Modifiers {\n    /**\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\n     * please look at AppStorage.sol for more detail\n     */\n    AppStorage internal s;\n\n    /**\n     * @notice Emitted when a buy action is executed for a trading strategy.\n     * @param strategyId The unique ID of the strategy where the buy action was executed.\n     * @param slippage The allowable price slippage percentage for the buy action.\n     * @param investTokenAmount The amount of invest tokens bought.\n     * @param investPrice the average price at which invest tokens were bought.\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\n     */\n\n    event BuyExecuted(\n        uint256 indexed strategyId,\n        uint256 slippage,\n        uint256 investTokenAmount,\n        uint256 investPrice,\n        uint256 exchangeRate\n    );\n\n    /**\n     * @notice Emitted when a Buy on Time-Weighted Average Price (TWAP) action is executed for a trading strategy using a specific DEX, call data, buy value, and execution time.\n     * @param strategyId The unique ID of the strategy where the Buy on TWAP action was executed.\n     * @param slippage The allowable price slippage percentage for the buy action.\n     * @param investTokenAmount The amount of invest tokens bought.\n     * @param investPrice the average price at which invest tokens were bought.\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\n     */\n    event BuyTwapExecuted(\n        uint256 indexed strategyId,\n        uint256 slippage,\n        uint256 investTokenAmount,\n        uint256 investPrice,\n        uint256 exchangeRate\n    );\n    /**\n     * @notice Emitted when a Buy The Dip (BTD) action is executed for a trading strategy using a specific DEX, call data, buy value, and execution time.\n     * @param strategyId The unique ID of the strategy where the BTD action was executed.\n     * @param slippage The allowable price slippage percentage for the buy action.\n     * @param investTokenAmount The amount of invest tokens bought.\n     * @param investPrice the average price at which invest tokens were bought.\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\n     */\n    event BTDExecuted(\n        uint256 indexed strategyId,\n        uint256 slippage,\n        uint256 investTokenAmount,\n        uint256 investPrice,\n        uint256 exchangeRate\n    );\n\n    /**\n     * @notice Emitted when a trade execution strategy is completed.\n     * @param strategyId The unique ID of the completed strategy.\n     */\n    event StrategyCompleted(uint256 indexed strategyId);\n\n    /**\n     * @notice Executes a buy action for a trading strategy based on specified conditions.\n     * @dev The function validates strategy parameters, executes the buy action, and updates the strategy state.\n     * @param strategyId The unique ID of the strategy for which the buy action is executed.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n    function executeBuy(uint256 strategyId, Swap calldata swap) external {\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        if (!strategy.parameters._buy) {\n            revert BuyNotSet();\n        }\n        if (strategy.parameters._btd || strategy.parameters._buyTwap) {\n            revert BuyDCAIsSet();\n        }\n        if (strategy.parameters._stableAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        updateCurrentPrice(strategyId, price);\n        uint256 value = executionBuyAmount(true, strategyId);\n\n        transferBuy(strategyId, value, swap, price, investRoundId, stableRoundId, strategy.parameters._buyValue);\n\n        if (!strategy.parameters._sell && !strategy.parameters._floor) {\n            strategy.status = Status.COMPLETED;\n            emit StrategyCompleted(strategyId);\n        }\n    }\n\n    /**\n     * @notice Executes a Buy on Time-Weighted Average Price (TWAP) action for a trading strategy.\n     * @param strategyId The unique ID of the strategy to execute the Buy on TWAP action.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n    function executeBuyTwap(uint256 strategyId, Swap calldata swap) external {\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        if (!strategy.parameters._buyTwap) {\n            revert BuyTwapNotSelected();\n        }\n        if (strategy.parameters._stableAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        updateCurrentPrice(strategyId, price);\n\n        uint256 timeToExecute = LibTime.convertToSeconds(\n            strategy.parameters._buyTwapTime,\n            strategy.parameters._buyTwapTimeUnit\n        );\n\n        bool execute = LibTime.getTimeDifference(block.timestamp, strategy.buyTwapExecutedAt, timeToExecute);\n\n        if (!execute) {\n            revert ExpectedTimeNotElapsed();\n        }\n\n        uint256 value = executionBuyAmount(false, strategyId);\n\n        transferBuy(strategyId, value, swap, price, investRoundId, stableRoundId, strategy.parameters._buyValue);\n        strategy.buyTwapExecutedAt = block.timestamp;\n        if (!strategy.parameters._sell && !strategy.parameters._floor && strategy.parameters._stableAmount == 0) {\n            strategy.status = Status.COMPLETED;\n            emit StrategyCompleted(strategyId);\n        }\n    }\n\n    /**\n     * @notice Executes a Buy-The-Dip (BTD) trading strategy action within a specified price range.\n     * This function allows the strategy to buy the invest token when its price decreases to a certain target value, following a specified DIP strategy type.\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\n     * @param fromInvestRoundId The starting invest round ID for monitoring price fluctuations.\n     * @param toInvestRoundId The ending invest round ID for monitoring price fluctuations.\n     * @param fromStableRoundId The starting stable round ID for monitoring price fluctuations.\n     * @param toStableRoundId The ending stable round ID for monitoring price fluctuations.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n\n    function executeBTD(\n        uint256 strategyId,\n        uint80 fromInvestRoundId,\n        uint80 fromStableRoundId,\n        uint80 toInvestRoundId,\n        uint80 toStableRoundId,\n        Swap calldata swap\n    ) external {\n        Strategy storage strategy = s.strategies[strategyId];\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        if (!strategy.parameters._btd) {\n            revert BTDNotSelected();\n        }\n        if (strategy.parameters._stableAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        checkRoundPrices(\n            strategyId,\n            fromInvestRoundId,\n            fromStableRoundId,\n            toInvestRoundId,\n            toStableRoundId,\n            investRoundId,\n            stableRoundId\n        );\n\n        uint256 value = executionBuyAmount(false, strategyId);\n\n        transferBuy(strategyId, value, swap, price, investRoundId, stableRoundId, strategy.parameters._buyValue);\n        if (!strategy.parameters._sell && !strategy.parameters._floor && strategy.parameters._stableAmount == 0) {\n            strategy.status = Status.COMPLETED;\n            emit StrategyCompleted(strategyId);\n        }\n    }\n\n    /**\n     * @notice Calculate the effective value for a buy action in a trading strategy.\n     * @param stableAmount Boolean flag indicating whether to consider the entire stable token amount.\n     * @param strategyId The unique ID of the strategy for which to calculate the buy value.\n     * @return The calculated buy value based on the specified parameters.\n     */\n    function executionBuyAmount(bool stableAmount, uint256 strategyId) public view returns (uint256) {\n        uint256 amount;\n        Strategy memory strategy = s.strategies[strategyId];\n        if (stableAmount) {\n            amount = strategy.parameters._stableAmount;\n        } else if (strategy.parameters._buyDCAUnit == DCA_UNIT.FIXED) {\n            amount = (strategy.parameters._stableAmount > strategy.parameters._buyDCAValue)\n                ? strategy.parameters._buyDCAValue\n                : strategy.parameters._stableAmount;\n        } else if (strategy.parameters._buyDCAUnit == DCA_UNIT.PERCENTAGE) {\n            uint256 buyPercentageAmount = (strategy.parameters._buyDCAValue * strategy.parameters._stableAmount) /\n                LibTrade.MAX_PERCENTAGE;\n            amount = (strategy.parameters._stableAmount > buyPercentageAmount)\n                ? buyPercentageAmount\n                : strategy.parameters._stableAmount;\n        }\n\n        return amount;\n    }\n\n    /**\n     * @notice Update the current price of a trading strategy based on the given price.\n     * @param strategyId The unique ID of the strategy to update.\n     * @param price The new price to set as the current price.\n     */\n    function updateCurrentPrice(uint256 strategyId, uint256 price) internal {\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.parameters._current_price == CURRENT_PRICE.BUY_CURRENT) {\n            strategy.parameters._buyValue = price;\n            strategy.parameters._current_price = CURRENT_PRICE.EXECUTED;\n        }\n    }\n\n    /**\n     * @notice Internal function to execute a \"Buy\" action within a specified price range.\n     * @dev This function transfers assets from stable tokens to investment tokens on a DEX.\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\n     * @param value The value to be transferred from stable tokens to investment tokens.\n     * @param dexSwap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     * @param price The current price of the investment token.\n     * @param investRoundId The invest round ID associated with the current price data.\n     * @param stableRoundId The stable round ID associated with the current price data.\n     * @param buyValue The target price at which the \"Buy\" action should be executed.\n     */\n\n    function transferBuy(\n        uint256 strategyId,\n        uint256 value,\n        Swap memory dexSwap,\n        uint256 price,\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        uint256 buyValue\n    ) internal {\n        Strategy storage strategy = s.strategies[strategyId];\n        if (price > buyValue) {\n            revert PriceIsGreaterThanBuyValue();\n        }\n\n        if (strategy.parameters._floor && strategy.parameters._floorValue > 0) {\n            uint256 floorAt;\n            if (strategy.parameters._floorType == FloorLegType.LIMIT_PRICE) {\n                floorAt = strategy.parameters._floorValue;\n            } else if (strategy.parameters._floorType == FloorLegType.DECREASE_BY) {\n                uint256 floorPercentage = LibTrade.MAX_PERCENTAGE - strategy.parameters._floorValue;\n                floorAt = (strategy.investPrice * floorPercentage) / LibTrade.MAX_PERCENTAGE;\n            }\n\n            if (floorAt > price) {\n                revert FloorGreaterThanPrice();\n            }\n        }\n        LibSwap.SwapData memory swap = LibSwap.SwapData(\n            dexSwap.dex,\n            strategy.parameters._stableToken,\n            strategy.parameters._investToken,\n            value,\n            dexSwap.callData,\n            strategy.user\n        );\n\n        uint256 toTokenAmount = LibSwap.swap(swap);\n\n        uint256 rate = LibTrade.calculateExchangeRate(strategy.parameters._investToken, toTokenAmount, value);\n\n        if (rate > buyValue) {\n            revert InvalidExchangeRate(buyValue, rate);\n        }\n\n        strategy.parameters._stableAmount -= value;\n        uint256 previousValue = strategy.parameters._investAmount * strategy.investPrice;\n        strategy.parameters._investAmount = strategy.parameters._investAmount + toTokenAmount;\n\n        strategy.investPrice = (previousValue + (toTokenAmount * price)) / strategy.parameters._investAmount;\n\n        strategy.investRoundId = investRoundId;\n        strategy.stableRoundId = stableRoundId;\n\n        uint256 slippage = LibTrade.validateSlippage(rate, price, strategy.parameters._slippage, true);\n\n        if (strategy.parameters._buy && !strategy.parameters._btd && !strategy.parameters._buyTwap) {\n            emit BuyExecuted(strategyId, slippage, toTokenAmount, strategy.investPrice, rate);\n        } else if (strategy.parameters._btd) {\n            emit BTDExecuted(strategyId, slippage, toTokenAmount, strategy.investPrice, rate);\n        } else if (strategy.parameters._buyTwap) {\n            emit BuyTwapExecuted(strategyId, slippage, toTokenAmount, strategy.investPrice, rate);\n        }\n    }\n\n    /**\n     * @notice Internal function to check if there is a data mismatch between price rounds for a strategy.\n     * @dev This function ensures that the price fluctuations between specified rounds adhere to strategy parameters.\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\n     * @param fromInvestRoundId The round ID for the investment token's price data to start checking from.\n     * @param fromStableRoundId The round ID for the stable token's price data to start checking from.\n     * @param toInvestRoundId The round ID for the investment token's price data to check up to.\n     * @param toStableRoundId The round ID for the stable token's price data to check up to.\n     * @param presentInvestRound The present round ID for the invest token's price.\n     * @param presentStableRound The present round ID for the stable token's price.\n     */\n    function checkRoundPrices(\n        uint256 strategyId,\n        uint80 fromInvestRoundId,\n        uint80 fromStableRoundId,\n        uint80 toInvestRoundId,\n        uint80 toStableRoundId,\n        uint80 presentInvestRound,\n        uint80 presentStableRound\n    ) internal view {\n        Strategy memory strategy = s.strategies[strategyId];\n\n        if (presentInvestRound < toInvestRoundId || presentStableRound < toStableRoundId) {\n            revert WrongPreviousIDs();\n        }\n        if (toInvestRoundId < fromInvestRoundId || toStableRoundId < fromStableRoundId) {\n            revert WrongPreviousIDs();\n        }\n        if (\n            strategy.investRoundId >= fromInvestRoundId ||\n            strategy.investRoundId >= toInvestRoundId ||\n            strategy.stableRoundId >= fromStableRoundId ||\n            strategy.stableRoundId >= toStableRoundId\n        ) {\n            revert WrongPreviousIDs();\n        }\n\n        uint256 fromPrice = LibPrice.getRoundData(\n            fromInvestRoundId,\n            fromStableRoundId,\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n        uint256 toPrice = LibPrice.getRoundData(\n            toInvestRoundId,\n            toStableRoundId,\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        uint256 btdValue = strategy.parameters._btdValue;\n        uint256 fromToPriceDifference;\n        uint256 toFromPriceDifference;\n\n        if (\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE ||\n                strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY)\n        ) {\n            if (toPrice < fromPrice) {\n                revert RoundDataDoesNotMatch();\n            } else {\n                toFromPriceDifference = toPrice - fromPrice;\n            }\n        }\n        if (\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE ||\n                strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            if (toPrice > fromPrice) {\n                revert RoundDataDoesNotMatch();\n            } else {\n                fromToPriceDifference = fromPrice - toPrice;\n            }\n        }\n\n        if ((strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE) && (btdValue > toFromPriceDifference)) {\n            revert RoundDataDoesNotMatch();\n        } else if ((strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE) && (btdValue > fromToPriceDifference)) {\n            revert RoundDataDoesNotMatch();\n        } else if (\n            (strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY) &&\n            (btdValue > ((toFromPriceDifference * 10000) / fromPrice))\n        ) {\n            revert RoundDataDoesNotMatch();\n        } else if (\n            (strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY) &&\n            (btdValue > ((fromToPriceDifference * 10000) / fromPrice))\n        ) {\n            revert RoundDataDoesNotMatch();\n        }\n    }\n}\n"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut, Modifiers {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override onlyOwner {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        uint256 originalSelectorCount = s.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            s.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        LibDiamond.initializeDiamondCut(_init, _calldata);\n    }\n}\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external view override returns (Facet[] memory facets_) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        facets_ = new Facet[](s.selectorCount);\n        uint16[] memory numFacetSelectors = new uint16[](s.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < s.selectorCount; slotIndex++) {\n            bytes32 slot = s.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > s.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(s.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\n                        // probably will never have more than 256 functions from one facet contract\n                        require(numFacetSelectors[facetIndex] < 255);\n                        numFacetSelectors[facetIndex]++;\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facets_[numFacets].facetAddress = facetAddress_;\n                facets_[numFacets].functionSelectors = new bytes4[](s.selectorCount);\n                facets_[numFacets].functionSelectors[0] = selector;\n                numFacetSelectors[numFacets] = 1;\n                numFacets++;\n            }\n        }\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n            uint256 numSelectors = numFacetSelectors[facetIndex];\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\n            // setting the number of selectors\n            assembly {\n                mstore(selectors, numSelectors)\n            }\n        }\n        // setting the number of facets\n        assembly {\n            mstore(facets_, numFacets)\n        }\n    }\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\n    function facetFunctionSelectors(\n        address _facet\n    ) external view override returns (bytes4[] memory _facetFunctionSelectors) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        uint256 numSelectors;\n        _facetFunctionSelectors = new bytes4[](s.selectorCount);\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < s.selectorCount; slotIndex++) {\n            bytes32 slot = s.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > s.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facet = address(bytes20(s.facets[selector]));\n                if (_facet == facet) {\n                    _facetFunctionSelectors[numSelectors] = selector;\n                    numSelectors++;\n                }\n            }\n        }\n        // Set the number of selectors in the array\n        assembly {\n            mstore(_facetFunctionSelectors, numSelectors)\n        }\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        facetAddresses_ = new address[](s.selectorCount);\n        uint256 numFacets;\n        uint256 selectorIndex;\n        // loop through function selectors\n        for (uint256 slotIndex; selectorIndex < s.selectorCount; slotIndex++) {\n            bytes32 slot = s.selectorSlots[slotIndex];\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\n                selectorIndex++;\n                if (selectorIndex > s.selectorCount) {\n                    break;\n                }\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\n                address facetAddress_ = address(bytes20(s.facets[selector]));\n                bool continueLoop;\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\n                        continueLoop = true;\n                        break;\n                    }\n                }\n                if (continueLoop) {\n                    continue;\n                }\n                facetAddresses_[numFacets] = facetAddress_;\n                numFacets++;\n            }\n        }\n        // Set the number of facet addresses in the array\n        assembly {\n            mstore(facetAddresses_, numFacets)\n        }\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        facetAddress_ = address(bytes20(s.facets[_functionSelector]));\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        return s.supportedInterfaces[_interfaceId];\n    }\n}\n"
    },
    "contracts/facets/FloorFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { AppStorage, Strategy, Status, Swap, FloorLegType } from \"../AppStorage.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { LibSwap } from \"../libraries/LibSwap.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, StrategyIsNotActive } from \"../utils/GenericErrors.sol\";\nerror FloorNotSet();\nerror PriceIsGreaterThanFloorValue();\n\n/**\n * @title FloorFacet\n * @notice This facet contains functions responsible for evaluating conditions related to the floor price and liquidation events.\n * @dev FloorFacet specializes in verifying floor price conditions, handling liquidation actions when the floor price is reached,\n *      ensuring that the necessary criteria are met before taking any actions and also cancelling the strategy if provided.\n */\n\ncontract FloorFacet is Modifiers {\n    /**\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\n     * please look at AppStorage.sol for more detail\n     */\n    AppStorage internal s;\n\n    /**\n     * @notice Emitted when a floor execution is initiated for a trading strategy.\n     * @param strategyId The unique ID of the strategy where the floor execution is initiated.\n     * @param slippage The allowable price slippage percentage for the buy action.\n     * @param stableTokenAmount The amount of stable tokens bought.\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\n     */\n    event FloorExecuted(uint256 indexed strategyId, uint256 slippage, uint256 stableTokenAmount, uint256 exchangeRate);\n    /**\n     * @notice Emitted when a trade execution strategy is cancelled.\n     * @param strategyId The unique ID of the cancelled strategy.\n     */\n    event StrategyCancelled(uint256 indexed strategyId);\n\n    /**\n     * @notice Execute a floor price check and potential liquidation for a trading strategy.\n     * @dev This function performs a floor price check and, if the strategy's parameters meet the required conditions,\n     *      it may execute a liquidation of assets. Liquidation occurs if the strategy's floor price is reached and\n     *      liquidation is enabled in the strategy parameters.\n     * @param strategyId The unique ID of the strategy to execute the floor check for.\n     * @param dexSwap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n    function executeFloor(uint256 strategyId, Swap calldata dexSwap) external {\n        // Retrieve the strategy details.\n        Strategy storage strategy = s.strategies[strategyId];\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        // Check if the floor price is set in the strategy parameters.\n        if (!strategy.parameters._floor) {\n            revert FloorNotSet();\n        }\n\n        // Ensure that there are assets available for swapping.\n        if (strategy.parameters._investAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        uint256 floorAt;\n        if (strategy.parameters._floorType == FloorLegType.LIMIT_PRICE) {\n            floorAt = strategy.parameters._floorValue;\n        } else if (strategy.parameters._floorType == FloorLegType.DECREASE_BY) {\n            uint256 floorPercentage = LibTrade.MAX_PERCENTAGE - strategy.parameters._floorValue;\n            floorAt = (strategy.investPrice * floorPercentage) / LibTrade.MAX_PERCENTAGE;\n        }\n\n        if (price > floorAt) {\n            revert PriceIsGreaterThanFloorValue();\n        }\n\n        // If liquidation is enabled, initiate a swap of assets.\n        if (strategy.parameters._liquidateOnFloor) {\n            // Prepare swap data for the DEX.\n            LibSwap.SwapData memory swap = LibSwap.SwapData(\n                dexSwap.dex,\n                strategy.parameters._investToken,\n                strategy.parameters._stableToken,\n                strategy.parameters._investAmount,\n                dexSwap.callData,\n                strategy.user\n            );\n\n            // Execute the asset swap and calculate the exchange rate.\n            uint256 toTokenAmount = LibSwap.swap(swap);\n            uint256 rate = LibTrade.calculateExchangeRate(\n                strategy.parameters._investToken,\n                strategy.parameters._investAmount,\n                toTokenAmount\n            );\n\n            // Check if the calculated exchange rate is within the acceptable range.\n            if (rate > floorAt) {\n                revert InvalidExchangeRate(floorAt, rate);\n            }\n\n            // Validate the slippage based on the calculated rate and the latest price.\n            uint256 slippage = LibTrade.validateSlippage(rate, price, strategy.parameters._slippage, false);\n\n            // Update strategy details, including timestamp, asset amounts, round ID, and invest price.\n            strategy.parameters._investAmount = 0;\n            strategy.parameters._stableAmount += toTokenAmount;\n            strategy.investRoundId = investRoundId;\n            strategy.stableRoundId = stableRoundId;\n            strategy.investPrice = 0;\n\n            // Check if the strategy should be canceled on reaching the floor price.\n            if (strategy.parameters._cancelOnFloor) {\n                strategy.status = Status.CANCELLED;\n                emit StrategyCancelled(strategyId);\n            }\n            emit FloorExecuted(strategyId, slippage, toTokenAmount, rate);\n        }\n    }\n}\n"
    },
    "contracts/facets/LensFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\nimport { LibUtil } from \"../libraries/LibUtil.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n/**\n * @title LensFacet\n * @dev This contract provides functions for calculating exchange rates and validating slippage in trades.\n */\ncontract LensFacet is Modifiers {\n    /**\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\n     * please look at AppStorage.sol for more detail\n     */\n    AppStorage internal s;\n\n    /**\n     * @notice Calculate the exchange rate between two assets for a given trade.\n     * @param fromAsset The address of the source asset.\n     * @param fromAmount The amount of the source asset.\n     * @param toAmount The amount of the target asset.\n     * @return The calculated exchange rate.\n     */\n    function calculateExchangeRate(\n        address fromAsset,\n        uint256 fromAmount,\n        uint256 toAmount\n    ) external view returns (uint256) {\n        return LibTrade.calculateExchangeRate(fromAsset, fromAmount, toAmount);\n    }\n\n    /**\n     * @notice Validate slippage for a trade based on exchange rate, price, and maximum allowed slippage.\n     * @param exchangeRate The calculated exchange rate for the trade.\n     * @param price The current market price.\n     * @param maxSlippage The maximum allowable slippage percentage.\n     * @param isBuy A flag indicating whether it's a buy (true) or sell (false) trade.\n     * @return The validated slippage for the trade.\n     */\n    function validateSlippage(\n        uint256 exchangeRate,\n        uint256 price,\n        uint256 maxSlippage,\n        bool isBuy\n    ) external pure returns (uint256) {\n        return LibTrade.validateSlippage(exchangeRate, price, maxSlippage, isBuy);\n    }\n\n    /**\n     * @notice Get the current nonce for a given account.\n     * @param account The address of the account.\n     * @return nonce current nonce.\n     */\n    function getNonce(address account) external view returns (uint256 nonce) {\n        return s.nonces[account];\n    }\n\n    /**\n     * @notice Get the current chain ID.\n     * @return chain ID.\n     */\n    function getChainId() external view returns (uint256) {\n        return LibUtil.getChainID();\n    }\n}\n"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n/**\n * @title OwnershipFacet\n * @dev This contract handles the ownership management of the diamond contract.\n */\ncontract OwnershipFacet is IERC173, Modifiers {\n    AppStorage internal s;\n\n    /**\n     * @notice Transfers ownership of the diamond contract to a new owner.\n     * @param _newOwner The address of the new owner.\n     */\n    function transferOwnership(address _newOwner) external override onlyOwner {\n        LibDiamond.setContractOwner(_newOwner);\n    }\n\n    /**\n     * @notice Retrieves the current owner of the diamond contract.\n     */\n    function owner() external view override returns (address owner_) {\n        owner_ = s.owner;\n    }\n}\n"
    },
    "contracts/facets/PriceOracleFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title PriceOracleFacet\n * @dev This contract manages asset price feeds used by the diamond contract.\n */\ncontract PriceOracleFacet is Modifiers {\n    AppStorage internal s;\n\n    /**\n     * @notice Sets the asset price feed address for a specific asset.\n     * @param _asset The address of the asset.\n     * @param _feed The address of the price feed for the asset.\n     */\n    function setAssetFeed(address _asset, address _feed) external onlyOwner {\n        s.feeds[_asset] = _feed;\n    }\n\n    /**\n     * @notice Get the current price and round IDs of an asset relative to a unit.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The current price of the asset in terms of the unit.\n     * @return investRoundId The round ID of the asset's price feed.\n     * @return stableRoundId The round ID of the unit's price feed.\n     */\n    function getPrice(address asset, address unit) external view returns (uint256 price, uint80, uint80) {\n        return LibPrice.getPrice(asset, unit);\n    }\n\n    /**\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\n     * @param investRoundId The round ID of the asset's price feed.\n     * @param stableRoundId The round ID of the unit's price feed.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\n     */\n    function getRoundData(\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        address asset,\n        address unit\n    ) external view returns (uint256) {\n        return LibPrice.getRoundData(investRoundId, stableRoundId, asset, unit);\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @return price The price of the asset in USD\n     */\n    function getUSDPrice(address asset) external view returns (uint256) {\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\n        return uint256(assetPrice);\n    }\n}\n"
    },
    "contracts/facets/SellFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { AppStorage, Strategy, Status, DCA_UNIT, DIP_SPIKE, SellLegType, CURRENT_PRICE, Swap } from \"../AppStorage.sol\";\nimport { LibSwap } from \"../libraries/LibSwap.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, WrongPreviousIDs, RoundDataDoesNotMatch, StrategyIsNotActive } from \"../utils/GenericErrors.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport { LibTime } from \"../libraries/LibTime.sol\";\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\n\nerror SellNotSelected();\nerror PriceLessThanHighSellValue();\nerror SellDCASelected();\nerror SellTwapNotSelected();\nerror ValueGreaterThanHighSellValue();\nerror TWAPTimeDifferenceIsLess();\nerror STRNotSelected();\nerror PriceLessThanSellValue();\nerror PriceIsNotInTheRange();\n\n/**\n * @title SellFacet\n * @notice This facet contains functions responsible for evaluating conditions for executing sell actions.\n * @dev SellFacet specializes in verifying conditions related to sell actions,\n * including limit price sells, Time-Weighted Average Price (TWAP) sells, and sell the rally criteria.\n *      It ensures that the necessary conditions are met before executing sell actions.\n */\ncontract SellFacet is Modifiers {\n    /**\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\n     * please look at AppStorage.sol for more detail\n     */\n    AppStorage internal s;\n\n    /**\n     * @notice Emitted when a sell action is executed for a trading strategy using a specific DEX and call data.\n     * @param strategyId The unique ID of the strategy where the sell action is executed.\n     * @param slippage The allowable price slippage percentage for the buy action.\n     * @param stableTokenAmount The amount of stable tokens bought.\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\n     * @param profit it is the profit made by the strategy.\n     */\n    event SellExecuted(\n        uint256 indexed strategyId,\n        uint256 slippage,\n        uint256 stableTokenAmount,\n        uint256 exchangeRate,\n        uint256 profit\n    );\n\n    /**\n     * @notice Emitted when a Time-Weighted Average Price (TWAP) sell action is executed for a trading strategy using a specific DEX and call data.\n     * @param strategyId The unique ID of the strategy where the TWAP sell action was executed.\n     * @param slippage The allowable price slippage percentage for the buy action.\n     * @param stableTokenAmount The amount of stable tokens bought.\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\n     * @param profit it is the profit made by the strategy.\n     */\n    event SellTwapExecuted(\n        uint256 indexed strategyId,\n        uint256 slippage,\n        uint256 stableTokenAmount,\n        uint256 exchangeRate,\n        uint256 profit\n    );\n\n    /**\n     * @notice Emitted when a Spike Trigger (STR) event is executed for a trading strategy using a specific DEX and call data.\n     * @param strategyId The unique ID of the strategy where the STR event was executed.\n     * @param slippage The allowable price slippage percentage for the buy action.\n     * @param stableTokenAmount The amount of stable tokens bought.\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\n     * @param profit it is the profit made by the strategy.\n     */\n    event STRExecuted(\n        uint256 indexed strategyId,\n        uint256 slippage,\n        uint256 stableTokenAmount,\n        uint256 exchangeRate,\n        uint256 profit\n    );\n\n    /**\n     * @notice Emitted when a trade execution strategy is completed.\n     * @param strategyId The unique ID of the completed strategy.\n     */\n    event StrategyCompleted(uint256 indexed strategyId);\n\n    /**\n     * @notice Execute a sell action for a trading strategy.\n     * @dev This function performs a sell action based on the specified strategy parameters and market conditions.\n     *      It verifies whether the strategy's parameters meet the required conditions for executing a sell.\n     * @param strategyId The unique ID of the strategy to execute the sell action for.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     */\n    function executeSell(uint256 strategyId, Swap calldata swap) external {\n        // Retrieve the strategy details.\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        // Ensure that selling is selected in the strategy parameters.\n        if (!strategy.parameters._sell) {\n            revert SellNotSelected();\n        }\n\n        // Ensure that there is invest token available for selling.\n        if (strategy.parameters._investAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        // Retrieve the latest price and round ID from Chainlink.\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        uint256 sellAt = strategy.parameters._sellValue;\n\n        if (strategy.parameters._sellType == SellLegType.INCREASE_BY) {\n            uint256 sellPercentage = LibTrade.MAX_PERCENTAGE + strategy.parameters._sellValue;\n            sellAt = (strategy.investPrice * sellPercentage) / LibTrade.MAX_PERCENTAGE;\n        }\n\n        updateCurrentPrice(strategyId, price);\n        if (sellAt > price) {\n            revert PriceLessThanSellValue();\n        }\n\n        if (strategy.parameters._highSellValue != 0) {\n            // If a high sell value is specified and \"strategy\" or \"sell TWAP\" is selected, use the high sell value.\n            sellAt = strategy.parameters._highSellValue;\n            if (price < sellAt) {\n                revert PriceLessThanHighSellValue();\n            }\n        } else if (strategy.parameters._str || strategy.parameters._sellTwap) {\n            // If neither high sell value nor \"sell the rally\" nor \"sell TWAP\" is selected, throw an error.\n            revert SellDCASelected();\n        }\n        uint256 value = executionSellAmount(true, strategyId);\n\n        // Perform the sell action, including transferring assets to the DEX.\n        transferSell(strategyId, value, swap, price, investRoundId, stableRoundId, sellAt);\n\n        // If there are no further buy actions in the strategy, mark it as completed.\n        if (!strategy.parameters._buy) {\n            strategy.status = Status.COMPLETED;\n            emit StrategyCompleted(strategyId);\n        }\n    }\n\n    /**\n   * @notice Execute a Time-Weighted Average Price (TWAP) sell action for a trading strategy.\n   * @dev This function performs a TWAP sell action based on the specified strategy parameters and market conditions.\n   *      It verifies whether the strategy's parameters meet the required conditions for executing a TWAP sell.\n   * @param strategyId The unique ID of the strategy to execute the TWAP sell action for.\n   * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n\n   */\n    function executeSellTwap(uint256 strategyId, Swap calldata swap) external {\n        // Retrieve the strategy details.\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        // Ensure that TWAP sell is selected in the strategy parameters.\n        if (!strategy.parameters._sellTwap) {\n            revert SellTwapNotSelected();\n        }\n\n        // Ensure that there is invest token available for selling.\n        if (strategy.parameters._investAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        // Retrieve the latest price and round ID from Chainlink.\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        updateCurrentPrice(strategyId, price);\n        uint256 sellAt = strategy.parameters._sellValue;\n        if (strategy.parameters._sellType == SellLegType.INCREASE_BY) {\n            uint256 sellPercentage = LibTrade.MAX_PERCENTAGE + strategy.parameters._sellValue;\n            sellAt = (strategy.investPrice * sellPercentage) / LibTrade.MAX_PERCENTAGE;\n        }\n\n        if (\n            price < sellAt || (strategy.parameters._highSellValue != 0 && price >= strategy.parameters._highSellValue)\n        ) {\n            revert PriceIsNotInTheRange();\n        }\n\n        // Initialize value for the TWAP sell.\n        uint256 value = executionSellAmount(false, strategyId);\n\n        // Calculate the time interval for TWAP execution and check if it can be executed.\n        uint256 timeToExecute = LibTime.convertToSeconds(\n            strategy.parameters._sellTwapTime,\n            strategy.parameters._sellTwapTimeUnit\n        );\n        bool execute = LibTime.getTimeDifference(block.timestamp, strategy.sellTwapExecutedAt, timeToExecute);\n\n        if (!execute) {\n            revert TWAPTimeDifferenceIsLess();\n        }\n\n        // Update the TWAP execution timestamp and perform the TWAP sell action.\n        strategy.sellTwapExecutedAt = block.timestamp;\n        transferSell(strategyId, value, swap, price, investRoundId, stableRoundId, sellAt);\n\n        // Mark the strategy as completed if there are no further buy actions and no assets left to invest.\n        if (!strategy.parameters._buy && strategy.parameters._investAmount == 0) {\n            strategy.status = Status.COMPLETED;\n            emit StrategyCompleted(strategyId);\n        }\n    }\n\n    /**\n     * @notice Execute a strategy based on Spike Trigger (STR) conditions for a trading strategy.\n     * @dev This function performs actions based on the specified strategy parameters and market conditions to execute Sell The Rally (STR) events.\n     *      It verifies whether the strategy's parameters meet the required conditions for executing STR events.\n     * @param strategyId The unique ID of the strategy to execute the STR actions for.\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     * @param fromInvestRoundId The starting invest round ID for price data.\n     * @param toInvestRoundId The ending invest round ID for price data.\n     * @param fromStableRoundId The starting stable round ID for price data.\n     * @param toStableRoundId The ending stable round ID for price data.\n     */\n    function executeSTR(\n        uint256 strategyId,\n        uint80 fromInvestRoundId,\n        uint80 fromStableRoundId,\n        uint80 toInvestRoundId,\n        uint80 toStableRoundId,\n        Swap calldata swap\n    ) public {\n        // Retrieve the strategy details.\n        Strategy storage strategy = s.strategies[strategyId];\n\n        if (strategy.status != Status.ACTIVE) {\n            revert StrategyIsNotActive();\n        }\n\n        // Ensure that STR events are selected in the strategy parameters.\n        if (!strategy.parameters._str) {\n            revert STRNotSelected();\n        }\n\n        // Ensure that there is invest token available for selling.\n        if (strategy.parameters._investAmount == 0) {\n            revert NoSwapFromZeroBalance();\n        }\n\n        // Retrieve the latest price and round ID from Chainlink.\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        uint256 sellAt = strategy.parameters._sellValue;\n        if (strategy.parameters._sellType == SellLegType.INCREASE_BY) {\n            uint256 sellPercentage = LibTrade.MAX_PERCENTAGE + strategy.parameters._sellValue;\n            sellAt = (strategy.investPrice * sellPercentage) / LibTrade.MAX_PERCENTAGE;\n        }\n\n        if (\n            price < sellAt || (strategy.parameters._highSellValue != 0 && price >= strategy.parameters._highSellValue)\n        ) {\n            revert PriceIsNotInTheRange();\n        }\n\n        checkRoundPrices(\n            strategyId,\n            fromInvestRoundId,\n            fromStableRoundId,\n            toInvestRoundId,\n            toStableRoundId,\n            investRoundId,\n            stableRoundId\n        );\n\n        uint256 value = executionSellAmount(false, strategyId);\n\n        transferSell(strategyId, value, swap, price, investRoundId, stableRoundId, sellAt);\n\n        // Mark the strategy as completed if there are no further buy actions and no assets left to invest.\n\n        if (!strategy.parameters._buy && strategy.parameters._investAmount == 0) {\n            strategy.status = Status.COMPLETED;\n            emit StrategyCompleted(strategyId);\n        }\n    }\n\n    /**\n     * @notice Calculate the value to be sold in a trading strategy based on provided parameters.\n     * @param investValue Boolean indicating whether the value is based on the investment amount.\n     * @param strategyId The unique ID of the strategy for which the sell value is calculated.\n     * @return The calculated value to be sold, which can be based on fixed or percentage units.\n     */\n\n    function executionSellAmount(bool investValue, uint256 strategyId) public view returns (uint256) {\n        uint256 amount;\n        Strategy memory strategy = s.strategies[strategyId];\n        if (investValue) {\n            amount = strategy.parameters._investAmount;\n        } else if (strategy.parameters._sellDCAUnit == DCA_UNIT.FIXED) {\n            amount = (strategy.parameters._investAmount > strategy.parameters._sellDCAValue)\n                ? strategy.parameters._sellDCAValue\n                : strategy.parameters._investAmount;\n        } else if (strategy.parameters._sellDCAUnit == DCA_UNIT.PERCENTAGE) {\n            uint256 sellPercentageAmount = (strategy.parameters._sellDCAValue * strategy.parameters._investAmount) /\n                LibTrade.MAX_PERCENTAGE;\n\n            amount = (strategy.parameters._investAmount > sellPercentageAmount)\n                ? sellPercentageAmount\n                : strategy.parameters._investAmount;\n        }\n        return amount;\n    }\n\n    /**\n     * @notice Transfer assets from the trading strategy during a sell action.\n     * @dev This function swaps a specified amount of assets on a DEX (Decentralized Exchange) and updates the strategy's state accordingly.\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\n     * @param value The amount to be sold on the DEX.\n     * @param dexSwap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\n     * @param price The current market price of the investment token.\n     * @param investRoundId The round ID for invest price data.\n     * @param stableRoundId The round ID for stable price data.\n     * @param sellValue The value at which the sell action was executed.\n     */\n    function transferSell(\n        uint256 strategyId,\n        uint256 value,\n        Swap calldata dexSwap,\n        uint256 price,\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        uint256 sellValue\n    ) internal {\n        Strategy storage strategy = s.strategies[strategyId];\n\n        // Create a swap data structure for the DEX trade.\n        LibSwap.SwapData memory swap = LibSwap.SwapData(\n            dexSwap.dex,\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken,\n            value,\n            dexSwap.callData,\n            strategy.user\n        );\n\n        // Perform the asset swap on the DEX and calculate the exchange rate.\n        uint256 toTokenAmount = LibSwap.swap(swap);\n\n        uint256 rate = LibTrade.calculateExchangeRate(strategy.parameters._investToken, value, toTokenAmount);\n        // Check if the exchange rate meets the specified sell value.\n        if (rate < sellValue) {\n            revert InvalidExchangeRate(sellValue, rate);\n        }\n\n        // Validate slippage if the strategy is not an STR (Spike Trigger).\n        uint256 slippage = 0;\n        if (!strategy.parameters._str) {\n            slippage = LibTrade.validateSlippage(rate, price, strategy.parameters._slippage, false);\n        }\n\n        // Calculate the total investment amount and check if it exceeds the budget.\n\n        uint256 decimals = 10 ** IERC20Metadata(strategy.parameters._investToken).decimals();\n\n        strategy.parameters._investAmount = strategy.parameters._investAmount - value;\n        strategy.parameters._stableAmount = strategy.parameters._stableAmount + toTokenAmount;\n\n        uint256 totalInvestAmount = (strategy.parameters._investAmount * strategy.investPrice) / decimals;\n        uint256 sum = strategy.parameters._stableAmount + totalInvestAmount;\n\n        if (strategy.budget < sum) {\n            strategy.parameters._stableAmount = strategy.budget - totalInvestAmount;\n\n            strategy.profit = sum - strategy.budget + strategy.profit;\n        }\n\n        // Update the strategy's timestamp, buy percentage amount, and round ID if necessary.\n\n        strategy.investRoundId = investRoundId;\n        strategy.stableRoundId = stableRoundId;\n        // Calculate the buy percentage amount if buy actions are based on TWAP or BTD.\n\n        if (\n            (strategy.parameters._sell && !strategy.parameters._str && !strategy.parameters._sellTwap) ||\n            (strategy.parameters._sell && strategy.parameters._highSellValue > price)\n        ) {\n            emit SellExecuted(strategyId, slippage, toTokenAmount, rate, strategy.profit);\n        } else if (strategy.parameters._str) {\n            emit STRExecuted(strategyId, slippage, toTokenAmount, rate, strategy.profit);\n        } else if (strategy.parameters._sellTwap) {\n            emit SellTwapExecuted(strategyId, slippage, toTokenAmount, rate, strategy.profit);\n        }\n    }\n\n    /**\n     * @notice Update the current price of a trading strategy based on the given price.\n     * @param strategyId The unique ID of the strategy to update.\n     * @param price The new price to set as the current price.\n     */\n    function updateCurrentPrice(uint256 strategyId, uint256 price) internal {\n        Strategy storage strategy = s.strategies[strategyId];\n\n        // Check the current price source selected in the strategy parameters.\n        if (strategy.parameters._current_price == CURRENT_PRICE.SELL_CURRENT) {\n            strategy.parameters._sellValue = price;\n            strategy.parameters._current_price = CURRENT_PRICE.EXECUTED;\n        }\n    }\n\n    /**\n     * @notice Internal function to check if there is a data mismatch between price rounds for a strategy.\n     * @dev This function ensures that the price fluctuations between specified rounds adhere to strategy parameters.\n     * @param strategyId The unique ID of the strategy to execute the STR actions for.\n     * @param fromInvestRoundId The round ID for the investment token's price data to start checking from.\n     * @param fromStableRoundId The round ID for the stable token's price data to start checking from.\n     * @param toInvestRoundId The round ID for the investment token's price data to check up to.\n     * @param toStableRoundId The round ID for the stable token's price data to check up to.\n     * @param presentInvestRound The present round ID for the invest token's price.\n     * @param presentStableRound The present round ID for the stable token's price.\n     */\n    function checkRoundPrices(\n        uint256 strategyId,\n        uint80 fromInvestRoundId,\n        uint80 fromStableRoundId,\n        uint80 toInvestRoundId,\n        uint80 toStableRoundId,\n        uint80 presentInvestRound,\n        uint80 presentStableRound\n    ) internal view {\n        Strategy memory strategy = s.strategies[strategyId];\n\n        if (presentInvestRound < toInvestRoundId || presentStableRound < toStableRoundId) {\n            revert WrongPreviousIDs();\n        }\n        if (toInvestRoundId < fromInvestRoundId || toStableRoundId < fromStableRoundId) {\n            revert WrongPreviousIDs();\n        }\n\n        if (\n            strategy.investRoundId >= fromInvestRoundId ||\n            strategy.investRoundId >= toInvestRoundId ||\n            strategy.stableRoundId >= fromStableRoundId ||\n            strategy.stableRoundId >= toStableRoundId\n        ) {\n            revert WrongPreviousIDs();\n        }\n\n        uint256 fromPrice = LibPrice.getRoundData(\n            fromInvestRoundId,\n            fromStableRoundId,\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n        uint256 toPrice = LibPrice.getRoundData(\n            toInvestRoundId,\n            toStableRoundId,\n            strategy.parameters._investToken,\n            strategy.parameters._stableToken\n        );\n\n        uint256 strValue = strategy.parameters._strValue;\n        uint256 fromToPriceDifference;\n        uint256 toFromPriceDifference;\n\n        if (\n            (strategy.parameters._strType == DIP_SPIKE.FIXED_INCREASE ||\n                strategy.parameters._strType == DIP_SPIKE.INCREASE_BY)\n        ) {\n            if (toPrice < fromPrice) {\n                revert RoundDataDoesNotMatch();\n            } else {\n                toFromPriceDifference = toPrice - fromPrice;\n            }\n        }\n        if (\n            (strategy.parameters._strType == DIP_SPIKE.FIXED_DECREASE ||\n                strategy.parameters._strType == DIP_SPIKE.DECREASE_BY)\n        ) {\n            if (toPrice > fromPrice) {\n                revert RoundDataDoesNotMatch();\n            } else {\n                fromToPriceDifference = fromPrice - toPrice;\n            }\n        }\n\n        if ((strategy.parameters._strType == DIP_SPIKE.FIXED_INCREASE) && (strValue > toFromPriceDifference)) {\n            revert RoundDataDoesNotMatch();\n        } else if ((strategy.parameters._strType == DIP_SPIKE.FIXED_DECREASE) && (strValue > fromToPriceDifference)) {\n            revert RoundDataDoesNotMatch();\n        } else if (\n            (strategy.parameters._strType == DIP_SPIKE.INCREASE_BY) &&\n            (strValue > ((toFromPriceDifference * 10000) / fromPrice))\n        ) {\n            revert RoundDataDoesNotMatch();\n        } else if (\n            (strategy.parameters._strType == DIP_SPIKE.DECREASE_BY) &&\n            (strValue > ((fromToPriceDifference * 10000) / fromPrice))\n        ) {\n            revert RoundDataDoesNotMatch();\n        }\n    }\n}\n"
    },
    "contracts/facets/StrategyFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { AppStorage, Strategy, StrategyParameters, SellLegType, BuyLegType, FloorLegType, DCA_UNIT, DIP_SPIKE, TimeUnit, Status, CURRENT_PRICE } from \"../AppStorage.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { InvalidSlippage, InvalidInvestToken, InvalidStableToken, TokensMustDiffer, AtLeastOneOptionRequired, InvalidBuyValue, InvalidBuyType, InvalidFloorValue, InvalidFloorType, InvalidSellType, InvalidSellValue, InvalidStableAmount, BuyAndSellAtMisorder, InvalidInvestAmount, FloorValueGreaterThanBuyValue, FloorValueGreaterThanSellValue, SellPercentageWithDCA, FloorPercentageWithDCA, BothBuyTwapAndBTD, BuyDCAWithoutBuy, BuyTwapTimeInvalid, BuyTwapTimeUnitNotSelected, BothSellTwapAndSTR, SellDCAWithoutSell, SellTwapTimeUnitNotSelected, SellTwapTimeInvalid, SellTwapOrStrWithoutSellDCAUnit, SellDCAUnitWithoutSellDCAValue, StrWithoutStrValueOrType, BTDWithoutBTDType, BTDTypeWithoutBTDValue, BuyDCAWithoutBuyDCAUnit, BuyDCAUnitWithoutBuyDCAValue, InvalidHighSellValue, SellDCAValueRangeIsNotValid, BuyDCAValueRangeIsNotValid, DCAValueShouldBeLessThanIntitialAmount, OrphandStrategy, BuyNeverExecute, InvalidSigner, InvalidNonce } from \"../utils/GenericErrors.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\nimport { LibSignature } from \"../libraries/LibSignature.sol\";\nimport { LibUtil } from \"../libraries/LibUtil.sol\";\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { IERC20Permit } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\";\n\nerror BothStableAndInvestAmountProvided();\nerror OnlyOwnerCanCancelStrategies();\nerror NoAmountProvided();\nerror HighSellValueIsChosenWithoutSeLLDCA();\n\n/**\n * @title StrategyFacet\n * @notice This contract handles the creation, retrieval, and cancellation of strategies.\n * Strategies define specific trade execution conditions and actions.\n * @dev StrategyFacet is one of the facets of the system, dedicated to strategy management.\n */\ncontract StrategyFacet is Modifiers {\n    /**\n     * @notice The `Permit` struct is used to hold the parameters for the permit function.\n     * @param token The address of the token to spend.\n     * @param owner The address of the owner of the token.\n     * @param spender The address of the spender of the token.\n     * @param value The amount of the token to spend.\n     * @param deadline The deadline for the permit.\n     * @param v The v parameter of the permit signature.\n     * @param r The r parameter of the permit signature.\n     * @param s The s parameter of the permit signature.\n     */\n    struct Permit {\n        address token;\n        address owner;\n        address spender;\n        uint256 value;\n        uint256 deadline;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    /**\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\n     * please look at AppStorage.sol for more detail\n     */\n    AppStorage internal s;\n\n    /**\n     * @notice Emitted when a new trading strategy is created.\n     * @param strategyId The unique ID of the strategy.\n     * @param user address of the user whose  for whose strategy is created\n     * @param parameter The strategy parameter including settings for buying and selling.\n     * @param investRoundId Round ID for the invest token price when the strategy is created.\n     * @param stableRoundId Round ID for the stable token price when the strategy is created.\n     * @param budget total budget of the user in the stable token\n     */\n\n    event StrategyCreated(\n        uint256 indexed strategyId,\n        address user,\n        StrategyParameters parameter,\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        uint256 budget\n    );\n\n    /**\n     * @notice Emitted when a trade execution strategy is cancelled.\n     * @param strategyId The unique ID of the cancelled strategy.\n     */\n    event StrategyCancelled(uint256 indexed strategyId);\n\n    /**\n     * @notice Cancel a trade execution strategy.\n     * @dev This function allows users to cancel a trade execution strategy based on its unique ID.\n     *      When cancelled, the strategy's status is updated to \"CANCELLED.\"\n     * @param id The unique ID of the strategy to cancel.\n     */\n    function cancelStrategy(uint256 id) external {\n        Strategy storage strategy = s.strategies[id];\n        if (msg.sender != strategy.user) {\n            revert OnlyOwnerCanCancelStrategies();\n        }\n        strategy.status = Status.CANCELLED;\n        emit StrategyCancelled(id);\n    }\n\n    /**\n     * @notice Get the next available strategy ID.\n     * @dev This function returns the unique ID that will be assigned to the next created strategy.\n     * @return The next available strategy ID.\n     */\n    function nextStartegyId() external view returns (uint256) {\n        return s.nextStrategyId;\n    }\n\n    /**\n     * @notice Create a new trade execution strategy based on the provided parameters.\n     * @dev This function validates the input parameters to ensure they satisfy the criteria for creating a strategy.\n     *      If the parameters are valid, a new strategy is created and an event is emitted to indicate the successful creation.\n     *      If the parameters do not meet the criteria, an error is thrown.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     */\n    function createStrategy(StrategyParameters memory _parameter) public {\n        _createStrategy(_parameter, msg.sender);\n    }\n\n    /**\n     * @notice Create a new trade execution strategy based on the provided parameters on behalf of another user.\n     * @dev This function validates the input parameters to ensure they satisfy the criteria for creating a strategy.\n     *      If the parameters are valid, a new strategy is created and an event is emitted to indicate the successful creation.\n     *      If the parameters do not meet the criteria, an error is thrown.\n     * @param permits The array of `Permit` structs containing the parameters for the permit function.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     * @param account The address of the user who created the strategy.\n     * @param nonce The nonce of the user who created the strategy.\n     * @param signature The signature of the user who created the strategy.\n     */\n    function createStrategyOnBehalf(\n        Permit[] memory permits,\n        StrategyParameters memory _parameter,\n        address account,\n        uint256 nonce,\n        bytes memory signature\n    ) public {\n        for (uint256 i = 0; i < permits.length; i++) {\n            IERC20Permit(permits[i].token).permit(\n                permits[i].owner,\n                permits[i].spender,\n                permits[i].value,\n                permits[i].deadline,\n                permits[i].v,\n                permits[i].r,\n                permits[i].s\n            );\n        }\n\n        if (s.nonces[account] != nonce) {\n            revert InvalidNonce();\n        }\n\n        bytes32 messageHash = getMessageHash(_parameter, nonce, account);\n        bytes32 ethSignedMessageHash = LibSignature.getEthSignedMessageHash(messageHash);\n        address signer = LibSignature.recoverSigner(ethSignedMessageHash, signature);\n        s.nonces[account] = s.nonces[account] + 1;\n\n        if (signer != account) {\n            revert InvalidSigner();\n        }\n\n        _createStrategy(_parameter, account);\n    }\n\n    /**\n     * @notice Get the message hash for a given strategy.\n     * @dev This function returns the message hash that must be signed by the user in order to create a strategy on behalf of another user.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     * @param nonce The nonce of the user who created the strategy.\n     * @param account The address of the user who created the strategy.\n     * @return The message hash for the given strategy.\n     */\n    function getMessageHash(\n        StrategyParameters memory _parameter,\n        uint256 nonce,\n        address account\n    ) public view returns (bytes32) {\n        return keccak256(abi.encode(account, nonce, _parameter, LibUtil.getChainID()));\n    }\n\n    /**\n     * @notice Retrieve the details of a trade execution strategy.\n     * @dev This function allows users to query and retrieve information about a trade execution strategy\n     *      based on its unique ID.\n     * @param id The unique ID of the strategy to retrieve.\n     * @return A `Strategy` struct containing details of the specified strategy.\n     */\n    function getStrategy(uint256 id) external view returns (Strategy memory) {\n        return s.strategies[id];\n    }\n\n    /**\n     * @notice Create a new trade execution strategy based on the provided parameters.\n     * @dev This function validates the input parameters to ensure they satisfy the criteria for creating a strategy.\n     *      If the parameters are valid, a new strategy is created and an event is emitted to indicate the successful creation.\n     *      If the parameters do not meet the criteria, an error is thrown.\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\n     * @param user The address of the user who created the strategy.\n     */\n    function _createStrategy(StrategyParameters memory _parameter, address user) internal {\n        if (_parameter._investToken == address(0)) {\n            revert InvalidInvestToken();\n        }\n\n        if (_parameter._stableToken == address(0)) {\n            revert InvalidStableToken();\n        }\n\n        if (_parameter._investToken == _parameter._stableToken) {\n            revert TokensMustDiffer();\n        }\n\n        if (!(_parameter._floor || _parameter._sell || _parameter._buy)) {\n            revert AtLeastOneOptionRequired();\n        }\n\n        if (_parameter._sellType == SellLegType.INCREASE_BY && (_parameter._str || _parameter._sellTwap)) {\n            revert SellPercentageWithDCA();\n        }\n\n        if (_parameter._floorType == FloorLegType.DECREASE_BY && (_parameter._buyTwap || _parameter._btd)) {\n            revert FloorPercentageWithDCA();\n        }\n\n        if (_parameter._buy && _parameter._buyTwap && _parameter._btd) {\n            revert BothBuyTwapAndBTD();\n        }\n\n        if ((_parameter._buyTwap || _parameter._btd) && !_parameter._buy) {\n            revert BuyDCAWithoutBuy();\n        }\n\n        if (_parameter._buyTwap && _parameter._buyTwapTime <= 0) {\n            revert BuyTwapTimeInvalid();\n        }\n        if (_parameter._buyTwap && _parameter._buyTwapTimeUnit == TimeUnit.NO_UNIT) {\n            revert BuyTwapTimeUnitNotSelected();\n        }\n\n        if (_parameter._sellTwap && _parameter._str) {\n            revert BothSellTwapAndSTR();\n        }\n\n        if ((_parameter._sellTwap || _parameter._str) && !_parameter._sell) {\n            revert SellDCAWithoutSell();\n        }\n        if (_parameter._sellTwap && _parameter._sellTwapTimeUnit == TimeUnit.NO_UNIT) {\n            revert SellTwapTimeUnitNotSelected();\n        }\n\n        if (_parameter._sellTwap && _parameter._sellTwapTime <= 0) {\n            revert SellTwapTimeInvalid();\n        }\n\n        if ((_parameter._sellTwap || _parameter._str) && _parameter._sellDCAUnit == DCA_UNIT.NO_UNIT) {\n            revert SellTwapOrStrWithoutSellDCAUnit();\n        }\n\n        if (_parameter._sellDCAUnit != DCA_UNIT.NO_UNIT && _parameter._sellDCAValue == 0) {\n            revert SellDCAUnitWithoutSellDCAValue();\n        }\n\n        if (_parameter._str && (_parameter._strValue == 0 || _parameter._strType == DIP_SPIKE.NO_SPIKE)) {\n            revert StrWithoutStrValueOrType();\n        }\n\n        if (_parameter._btd && _parameter._btdType == DIP_SPIKE.NO_SPIKE) {\n            revert BTDWithoutBTDType();\n        }\n\n        if (_parameter._btdType != DIP_SPIKE.NO_SPIKE && _parameter._btdValue == 0) {\n            revert BTDTypeWithoutBTDValue();\n        }\n\n        if ((_parameter._btd || _parameter._buyTwap) && _parameter._buyDCAUnit == DCA_UNIT.NO_UNIT) {\n            revert BuyDCAWithoutBuyDCAUnit();\n        }\n\n        if (_parameter._buyDCAUnit != DCA_UNIT.NO_UNIT && _parameter._buyDCAValue == 0) {\n            revert BuyDCAUnitWithoutBuyDCAValue();\n        }\n\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\n            _parameter._investToken,\n            _parameter._stableToken\n        );\n\n        uint256 buyValue = _parameter._buyValue;\n        if (_parameter._current_price == CURRENT_PRICE.BUY_CURRENT) {\n            buyValue = price;\n            _parameter._buyType = BuyLegType.LIMIT_PRICE;\n            if (_parameter._btd) {\n                _parameter._buyValue = price;\n                _parameter._current_price = CURRENT_PRICE.EXECUTED;\n            }\n        }\n        uint256 sellValue = _parameter._sellValue;\n        if (_parameter._current_price == CURRENT_PRICE.SELL_CURRENT) {\n            sellValue = price;\n            _parameter._sellType = SellLegType.LIMIT_PRICE;\n            if (_parameter._str) {\n                _parameter._sellValue = price;\n                _parameter._current_price = CURRENT_PRICE.EXECUTED;\n            }\n        }\n\n        if (_parameter._buy) {\n            if (buyValue == 0) {\n                revert InvalidBuyValue();\n            }\n            if (_parameter._buyType == BuyLegType.NO_TYPE) {\n                revert InvalidBuyType();\n            }\n        }\n\n        // Check if floor is chosen\n        if (_parameter._floor) {\n            if (_parameter._floorValue == 0) {\n                revert InvalidFloorValue();\n            }\n            if (_parameter._floorType == FloorLegType.NO_TYPE) {\n                revert InvalidFloorType();\n            }\n        }\n\n        if (_parameter._highSellValue != 0) {\n            if (!(_parameter._str || _parameter._sellTwap)) {\n                revert HighSellValueIsChosenWithoutSeLLDCA();\n            }\n        }\n\n        if (_parameter._sell || _parameter._str || _parameter._sellTwap) {\n            if (_parameter._sellType == SellLegType.NO_TYPE) {\n                revert InvalidSellType();\n            }\n            if (sellValue == 0) {\n                revert InvalidSellValue();\n            }\n            if (_parameter._highSellValue != 0 && sellValue > _parameter._highSellValue) {\n                revert InvalidHighSellValue();\n            }\n        }\n\n        // Check if both buy and sell are chosen\n        if (_parameter._buy && _parameter._sell) {\n            if (!(_parameter._stableAmount > 0 || _parameter._investAmount > 0)) {\n                revert NoAmountProvided();\n            }\n            if (buyValue >= sellValue && _parameter._sellType == SellLegType.LIMIT_PRICE) {\n                revert BuyAndSellAtMisorder();\n            }\n        }\n        // Check if only buy is chosen\n        if (_parameter._buy && !_parameter._sell && !_parameter._floor) {\n            if (!(_parameter._stableAmount > 0)) {\n                revert InvalidStableAmount();\n            }\n        }\n\n        if (_parameter._buy && !_parameter._sell && !_parameter._floor) {\n            if (_parameter._investAmount > 0) {\n                revert OrphandStrategy();\n            }\n        }\n        if (!_parameter._buy && _parameter._sell && _parameter._floor) {\n            if (_parameter._stableAmount > 0) {\n                revert OrphandStrategy();\n            }\n        }\n\n        // Check if only sell is chosen\n        if (\n            (_parameter._sell || _parameter._floor) &&\n            _parameter._investAmount > 0 &&\n            (_parameter._completeOnSell || _parameter._cancelOnFloor) &&\n            _parameter._buy\n        ) {\n            revert BuyNeverExecute();\n        }\n\n        // Check if floor and sell are chosen\n        if (\n            _parameter._floor &&\n            _parameter._sell &&\n            _parameter._sellType == SellLegType.LIMIT_PRICE &&\n            _parameter._floorType == FloorLegType.LIMIT_PRICE\n        ) {\n            if (_parameter._floorValue >= sellValue) {\n                revert FloorValueGreaterThanSellValue();\n            }\n        }\n\n        // Check if floor and buy are chosen\n        if (_parameter._floor && _parameter._buy && _parameter._floorType == FloorLegType.LIMIT_PRICE) {\n            if (_parameter._floorValue >= buyValue) {\n                revert FloorValueGreaterThanBuyValue();\n            }\n        }\n\n        if (_parameter._slippage > LibTrade.MAX_PERCENTAGE) {\n            revert InvalidSlippage();\n        }\n\n        if ((_parameter._sellTwap || _parameter._str) && _parameter._sellDCAUnit == DCA_UNIT.PERCENTAGE) {\n            if (_parameter._sellDCAValue < 0 || _parameter._sellDCAValue > LibTrade.MAX_PERCENTAGE) {\n                revert SellDCAValueRangeIsNotValid();\n            }\n        }\n\n        if (\n            ((_parameter._sellTwap || _parameter._str) && _parameter._sellDCAUnit == DCA_UNIT.FIXED) &&\n            _parameter._investAmount > 0 &&\n            (_parameter._sellDCAValue > _parameter._investAmount)\n        ) {\n            revert DCAValueShouldBeLessThanIntitialAmount();\n        }\n\n        if (\n            (_parameter._buyTwap || _parameter._btd) &&\n            (_parameter._buyDCAUnit == DCA_UNIT.FIXED) &&\n            _parameter._stableAmount > 0 &&\n            (_parameter._buyDCAValue > _parameter._stableAmount)\n        ) {\n            revert DCAValueShouldBeLessThanIntitialAmount();\n        }\n\n        if ((_parameter._buyTwap || _parameter._btd) && _parameter._buyDCAUnit == DCA_UNIT.PERCENTAGE) {\n            if (_parameter._buyDCAValue < 0 || _parameter._buyDCAValue > LibTrade.MAX_PERCENTAGE) {\n                revert BuyDCAValueRangeIsNotValid();\n            }\n        }\n\n        uint256 decimals = 10 ** IERC20Metadata(_parameter._investToken).decimals();\n\n        if (_parameter._investAmount > 0 && _parameter._stableAmount > 0) {\n            revert BothStableAndInvestAmountProvided();\n        }\n        uint256 budget = 0;\n\n        if (_parameter._investAmount > 0) {\n            budget = ((_parameter._investAmount * price) / decimals);\n        }\n\n        if (_parameter._stableAmount > 0) {\n            budget = _parameter._stableAmount;\n        }\n        uint256 investPrice = 0;\n        if (_parameter._investAmount > 0) {\n            investPrice = price;\n        }\n        s.strategies[s.nextStrategyId] = Strategy({\n            user: user,\n            sellTwapExecutedAt: 0,\n            buyTwapExecutedAt: 0,\n            investRoundId: investRoundId,\n            stableRoundId: stableRoundId,\n            parameters: _parameter,\n            investPrice: investPrice,\n            profit: 0,\n            budget: budget,\n            status: Status.ACTIVE\n        });\n\n        s.nextStrategyId++;\n\n        emit StrategyCreated((s.nextStrategyId - 1), user, _parameter, investRoundId, stableRoundId, budget);\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/libraries/LibAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport { TransferFailed } from \"../utils/GenericErrors.sol\";\n\n/**\n * @title LibAsset\n * @dev This library provides functions for interacting with ERC20 assets.\n */\nlibrary LibAsset {\n    uint256 private constant MAX_UINT = type(uint256).max;\n\n    /**\n     * @notice Approves a specified amount of an asset for a spender if the current allowance is insufficient.\n     * @param asset The address of the asset.\n     * @param spender The address of the spender.\n     * @param amount The amount to approve.\n     */\n    function maxApprove(address asset, address spender, uint256 amount) internal {\n        if (IERC20(asset).allowance(address(this), spender) < amount) {\n            SafeERC20.safeApprove(IERC20(asset), spender, 0);\n            SafeERC20.safeApprove(IERC20(asset), spender, amount);\n        }\n    }\n\n    /**\n     * @notice Transfers a specified amount of an asset from one address to another.\n     * @param asset The address of the asset.\n     * @param from The sender's address.\n     * @param to The recipient's address.\n     * @param amount The amount to transfer.\n     */\n    function transferFrom(address asset, address from, address to, uint256 amount) internal {\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\n        SafeERC20.safeTransferFrom(IERC20(asset), from, to, amount);\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\n            revert TransferFailed();\n        }\n    }\n\n    /**\n     * @notice Transfers a specified amount of an asset to a recipient.\n     * @param asset The address of the asset.\n     * @param to The recipient's address.\n     * @param amount The amount to transfer.\n     */\n    function transfer(address asset, address to, uint256 amount) internal {\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\n        SafeERC20.safeTransfer(IERC20(asset), to, amount);\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\n            revert TransferFailed();\n        }\n    }\n\n    /**\n     * @notice Retrieves the balance of a specified asset for a given account.\n     * @param asset The address of the asset.\n     * @param account The account for which to check the balance.\n     * @return The balance of the asset for the specified account.\n     */\n    function balanceOf(address asset, address account) internal view returns (uint256) {\n        return IERC20(asset).balanceOf(account);\n    }\n}\n"
    },
    "contracts/libraries/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nlibrary LibBytes {\n    // solhint-disable no-inline-assembly\n\n    // LibBytes specific errors\n    error SliceOverflow();\n    error SliceOutOfBounds();\n    error AddressOutOfBounds();\n\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n\n    // -------------------------\n    /**\n     * @notice Slice a portion of a bytes array.\n     * @param _bytes The input bytes array.\n     * @param _start The starting index of the slice.\n     * @param _length The length of the slice.\n     * @return tempBytes A new bytes array containing the sliced data.\n     */\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\n        if (_length + 31 < _length) revert SliceOverflow();\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    /**\n     * @notice Convert a portion of a bytes array to an address.\n     * @param _bytes The input bytes array.\n     * @param _start The starting index of the address data.\n     * @return tempAddress The address extracted from the bytes array.\n     */\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        if (_bytes.length < _start + 20) {\n            revert AddressOutOfBounds();\n        }\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\n    /**\n     * @notice Convert a uint256 to its hexadecimal representation as a string.\n     * @param value The uint256 value to convert.\n     * @param length The desired length of the hexadecimal string.\n     * @return A string containing the hexadecimal representation of the uint256 value.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    function diamondStorage() internal pure returns (AppStorage storage s) {\n        assembly {\n            s.slot := 0\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        AppStorage storage s = diamondStorage();\n        address previousOwner = s.owner;\n        s.owner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        AppStorage storage s = diamondStorage();\n        uint256 originalSelectorCount = s.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            s.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        AppStorage storage s = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"LibDiamondCut: Can't add function that already exists\"\n                );\n                // add facet for selector\n                s.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot =\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    s.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"LibDiamondCut: Can't replace function with same function\"\n                );\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                s.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = s.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = s.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\n                    );\n                    // only useful if immutable functions exist\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"LibDiamondCut: Can't remove immutable function\"\n                    );\n                    // replace selector with last selector in s.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        s.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.facets[lastSelector]);\n                    }\n                    delete s.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete s.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport { LibDiamond } from \"./LibDiamond.sol\";\nimport { InvalidPrice, FeedNotFound } from \"../utils/GenericErrors.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n/**\n * @title LibPrice\n * @dev This library provides functions for fetching and manipulating asset prices.\n */\nlibrary LibPrice {\n    address constant USD_QUOTE = 0x0000000000000000000000000000000000000348;\n\n    /**\n     * @notice Get the current price and round IDs of an asset relative to a unit.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The current price of the asset in terms of the unit.\n     * @return investRoundId The round ID of the asset's price feed.\n     * @return stableRoundId The round ID of the unit's price feed.\n     */\n    function getPrice(address asset, address unit) internal view returns (uint256 price, uint80, uint80) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (uint80 investRoundId, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\n        (uint80 stableRoundId, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).latestRoundData();\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return (price, investRoundId, stableRoundId);\n    }\n\n    /**\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\n     * @param investRoundId The round ID of the asset's price feed.\n     * @param stableRoundId The round ID of the unit's price feed.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\n     */\n    function getRoundData(\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        address asset,\n        address unit\n    ) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(investRoundId);\n        (, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).getRoundData(stableRoundId);\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        uint256 price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return price;\n    }\n}\n"
    },
    "contracts/libraries/LibSignature.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\n/**\n * @title LibSignature\n * @dev This library provides utility functions for signature verification.\n */\nlibrary LibSignature {\n    function recoverSigner(bytes32 _ethSignedMessageHash, bytes memory _signature) internal pure returns (address) {\n        (bytes32 r, bytes32 s, uint8 v) = splitSignature(_signature);\n\n        return ecrecover(_ethSignedMessageHash, v, r, s);\n    }\n\n    function splitSignature(bytes memory sig) internal pure returns (bytes32 r, bytes32 s, uint8 v) {\n        require(sig.length == 65, \"invalid signature length\");\n\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n    }\n\n    function getEthSignedMessageHash(bytes32 _messageHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", _messageHash));\n    }\n}\n"
    },
    "contracts/libraries/LibSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibAsset } from \"./LibAsset.sol\";\nimport { LibUtil } from \"./LibUtil.sol\";\nimport { NoSwapFromZeroBalance, InsufficientBalance, SwapFailed } from \"../utils/GenericErrors.sol\";\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title LibSwap\n * @dev This library provides functions for executing asset swaps.\n */\nlibrary LibSwap {\n    struct SwapData {\n        address callTo; // The address of the contract or dex to execute the swap on.\n        address fromAsset; // The address of the asset to swap from.\n        address toAsset; // The address of the asset to receive.\n        uint256 fromAmount; // The amount of the 'fromAsset' to swap.\n        bytes callData; // The call data for the swap.\n        address user; // The user initiating the swap.\n    }\n\n    /**\n     * @notice Emitted when an asset swap has been executed successfully.\n     * @param dex The address of the contract or dex used for the swap.\n     * @param fromAsset The address of the asset swapped from.\n     * @param toAsset The address of the asset received in the swap.\n     * @param fromAmount The amount of 'fromAsset' that was swapped.\n     * @param receivedAmount The amount of 'toAsset' received in the swap.\n     * @param account The address of the user account that initiated the swap.\n     */\n\n    event AssetSwapped(\n        address dex,\n        address fromAsset,\n        address toAsset,\n        uint256 fromAmount,\n        uint256 receivedAmount,\n        address account\n    );\n\n    /**\n     * @notice Execute an asset swap from one asset to another using the provided swap data.\n     * @param _swap The swap data containing all necessary information for the swap.\n     * @return The amount of 'toAsset' received in the swap.\n     * @dev This function transfers 'fromAsset' from the user to this contract, executes the swap,\n     * and transfers the received 'toAsset' back to the user.\n     */\n    function swap(SwapData memory _swap) internal returns (uint256) {\n        uint256 fromAmount = _swap.fromAmount;\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\n\n        LibAsset.transferFrom(_swap.fromAsset, _swap.user, address(this), fromAmount);\n\n        uint256 initialReceivingAssetBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\n\n        LibAsset.maxApprove(_swap.fromAsset, _swap.callTo, _swap.fromAmount);\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swap.callTo.call(_swap.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        uint256 newBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\n        uint256 receivedAmount = newBalance - initialReceivingAssetBalance;\n\n        if (receivedAmount == 0) {\n            revert SwapFailed();\n        }\n\n        LibAsset.transfer(_swap.toAsset, _swap.user, receivedAmount);\n\n        emit AssetSwapped(_swap.callTo, _swap.fromAsset, _swap.toAsset, _swap.fromAmount, receivedAmount, _swap.user);\n\n        return receivedAmount;\n    }\n}\n"
    },
    "contracts/libraries/LibTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { TimeUnit } from \"../AppStorage.sol\";\n\nerror InvalidUnit();\n\n/**\n * @title LibTime\n * @dev This library provides functions for time-related calculations.\n */\nlibrary LibTime {\n    /**\n     * @notice Convert a given time value to seconds based on the specified time unit.\n     * @param time The time value to convert.\n     * @param unit The time unit (e.g., TimeUnit.HOURS, TimeUnit.DAYS).\n     * @return The time value converted to seconds.\n     * @dev Reverts with `InvalidUnit` error if an unsupported time unit is provided.\n     */\n    function convertToSeconds(uint256 time, TimeUnit unit) internal pure returns (uint256) {\n        if (unit == TimeUnit.HOURS) {\n            return time * 3600;\n        } else if (unit == TimeUnit.DAYS) {\n            return time * 86400;\n        } else {\n            revert InvalidUnit();\n        }\n    }\n\n    /**\n     * @notice Check if a time difference condition is met.\n     * @param presentTime The current time.\n     * @param executionTime The execution time to consider (0 for immediate execution).\n     * @param targetTime The target time for comparison.\n     * @return A boolean indicating whether the time difference condition is met.\n     */\n\n    function getTimeDifference(\n        uint256 presentTime,\n        uint256 executionTime,\n        uint256 targetTime\n    ) internal pure returns (bool) {\n        if (executionTime == 0) {\n            return true;\n        }\n        bool timeDifference = targetTime <= presentTime - executionTime ? true : false;\n        return timeDifference;\n    }\n}\n"
    },
    "contracts/libraries/LibTrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport { HighSlippage } from \"../utils/GenericErrors.sol\";\n\n/**\n * @title LibTrade\n * @dev This library provides functions for calculating exchange rates and validating slippage.\n */\nlibrary LibTrade {\n    uint256 public constant MAX_PERCENTAGE = 10000;\n\n    /**\n    @dev Calculate exchange rate given input and output amounts\n    @param fromAsset Address of the asset that was used to swap\n    @param fromAmount Amount of the asset that was used to swap\n    @param toAmount Amount of the asset that was received from swap\n    @return uint256 Returns the exchange rate in toAsset unit\n     */\n    function calculateExchangeRate(\n        address fromAsset,\n        uint256 fromAmount,\n        uint256 toAmount\n    ) internal view returns (uint256) {\n        IERC20Metadata _fromToken = IERC20Metadata(fromAsset);\n        uint256 fromDecimals = _fromToken.decimals();\n        return ((toAmount * (10 ** fromDecimals)) / fromAmount);\n    }\n\n    /**\n     * @notice Validate the slippage of a swap.\n     * @param exchangeRate The calculated exchange rate for the swap.\n     * @param price The reference price for the swap.\n     * @param maxSlippage The maximum allowed slippage percentage.\n     * @param isBuy A flag indicating if it's a buy operation (true) or not (false).\n     * @return uint256 Returns the calculated slippage percentage.\n     */\n    function validateSlippage(\n        uint256 exchangeRate,\n        uint256 price,\n        uint256 maxSlippage,\n        bool isBuy\n    ) internal pure returns (uint256) {\n        uint256 slippage = (price * MAX_PERCENTAGE) / exchangeRate;\n\n        if (isBuy && slippage < MAX_PERCENTAGE && MAX_PERCENTAGE - slippage > maxSlippage) revert HighSlippage();\n        if (!isBuy && slippage > MAX_PERCENTAGE && slippage - MAX_PERCENTAGE > maxSlippage) revert HighSlippage();\n        return slippage;\n    }\n}\n"
    },
    "contracts/libraries/LibUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nimport \"./LibBytes.sol\";\n\n/**\n * @title LibUtil\n * @dev This library provides utility functions for working with revert messages.\n */\nlibrary LibUtil {\n    using LibBytes for bytes;\n\n    /**\n     * @notice Get a revert message from transaction result data.\n     * @param _res The transaction result data to extract the revert message from.\n     * @return string The revert message or a \"Transaction reverted silently\" message if none is found.\n     */\n    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }\n\n    /**\n     * @notice Used the get the ID of the current chain.\n     * @return id The chain ID\n     */\n    function getChainID() internal view returns (uint256) {\n        uint256 id;\n        assembly {\n            id := chainid()\n        }\n        return id;\n    }\n}\n"
    },
    "contracts/test/ScenarioBasicERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ScenarioBasicERC20 is ERC20 {\n    uint8 private _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\n        _decimals = decimals_;\n    }\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}"
    },
    "contracts/test/ScenarioDEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { ScenarioERC20 } from \"./ScenarioERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\ncontract ScenarioDEX {\n    // total decimals for USD price\n    uint256 public constant USD_DECIMALS = 8;\n\n    uint256 public constant MAX_SLIPPAGE = 10000;\n\n    // asset => exchangeRate in USD\n    mapping(address => uint256) public exchangeRate;\n\n    // asset => feed in USD\n    mapping(address => address) public feeds;\n\n    // MAX_SLIPPAGE = 100% = 10000\n    uint256 public slippage = 0;\n\n    function updateExchangeRate(address asset, uint256 rate) external {\n        exchangeRate[asset] = rate;\n    }\n\n    function updateFeed(address asset, address feed) external {\n        feeds[asset] = feed;\n    }\n\n    function updateSlippage(uint256 _slippage) external {\n        require(_slippage <= MAX_SLIPPAGE, \"ScenarioDEX: slippage must be less than 100%\");\n        slippage = _slippage;\n    }\n\n    function getPrice(address asset) public view returns (uint256) {\n        require(feeds[asset] != address(0) || exchangeRate[asset] > 0, \"ScenarioDEX: price not set\");\n\n        if (feeds[asset] != address(0)) {\n            return uint256(AggregatorV2V3Interface(feeds[asset]).latestAnswer());\n        } else {\n            return exchangeRate[asset];\n        }\n    }\n\n    function swap(address fromAsset, address toAsset, uint256 fromAmount) external {\n        require(fromAmount > 0, \"ScenarioDEX: fromAmount must be greater than 0\");\n\n        IERC20Metadata _fromToken = IERC20Metadata(fromAsset);\n        IERC20Metadata _toToken = IERC20Metadata(toAsset);\n\n        uint256 fromAmountInUSD = (fromAmount * getPrice(fromAsset)) / (10 ** _fromToken.decimals());\n        uint256 toAmount = (fromAmountInUSD * 10 ** _toToken.decimals()) / getPrice(toAsset);\n\n        uint256 slippageAmount = (toAmount * slippage) / MAX_SLIPPAGE;\n\n        ScenarioERC20(toAsset).mint(address(this), toAmount - slippageAmount);\n        SafeERC20.safeTransfer(IERC20(toAsset), msg.sender, toAmount - slippageAmount);\n        SafeERC20.safeTransferFrom(IERC20(fromAsset), msg.sender, address(this), fromAmount);\n    }\n}\n"
    },
    "contracts/test/ScenarioERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract ScenarioERC20 is ERC20Permit {\n    uint8 private _decimals;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) ERC20Permit(name_) {\n        _decimals = decimals_;\n    }\n\n    function mint(address to, uint256 amount) external {\n        _mint(to, amount);\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return _decimals;\n    }\n}\n"
    },
    "contracts/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\ncontract DiamondInit {\n    // You can add parameters to this function in order to pass in\n    // data to set your own state variables\n    function init() external {\n        // adding ERC165 data\n        AppStorage storage s = LibDiamond.diamondStorage();\n        s.supportedInterfaces[type(IERC165).interfaceId] = true;\n        s.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        s.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        s.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        // add your own state variables\n        // EIP-2535 specifies that the `diamondCut` function takes two optional\n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface\n    }\n}\n"
    },
    "contracts/utils/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nerror NoSwapFromZeroBalance();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror SwapFailed();\nerror TransferFailed();\nerror InvalidExchangeRate(uint256 required, uint256 actual);\nerror InvalidPrice();\nerror InvalidSlippage();\nerror HighSlippage();\nerror InvalidInvestToken();\nerror InvalidStableToken();\nerror TokensMustDiffer();\nerror AtLeastOneOptionRequired();\nerror InvalidInvestAmount();\nerror FloorValueZero();\nerror InvalidSellType();\nerror InvalidSellValue();\nerror BuyAndSellAtMisorder();\nerror InvalidStableAmount();\nerror InvalidBuyType();\nerror InvalidBuyValue();\nerror InvalidFloorValue();\nerror InvalidFloorType();\nerror InvalidSellTypeDCA();\nerror FloorValueGreaterThanBuyValue();\nerror FloorValueGreaterThanSellValue();\nerror SellPercentageWithDCA();\nerror FloorPercentageWithDCA();\nerror BothBuyTwapAndBTD();\nerror BuyDCAWithoutBuy();\nerror BuyTwapTimeInvalid();\nerror BuyTwapTimeUnitNotSelected();\nerror BothSellTwapAndSTR();\nerror SellDCAWithoutSell();\nerror SellTwapTimeUnitNotSelected();\nerror SellTwapTimeInvalid();\nerror SellTwapOrStrWithoutSellDCAUnit();\nerror SellDCAUnitWithoutSellDCAValue();\nerror StrWithoutStrValueOrType();\nerror BTDWithoutBTDType();\nerror BTDTypeWithoutBTDValue();\nerror BuyDCAWithoutBuyDCAUnit();\nerror BuyDCAUnitWithoutBuyDCAValue();\nerror InvalidHighSellValue();\nerror SellDCAValueRangeIsNotValid();\nerror DCAValueShouldBeLessThanIntitialAmount();\nerror BuyDCAValueRangeIsNotValid();\nerror OrphandStrategy();\nerror BuyNeverExecute();\nerror FloorGreaterThanPrice();\nerror FeedNotFound();\nerror WrongPreviousIDs();\nerror RoundDataDoesNotMatch();\nerror StrategyIsNotActive();\nerror InvalidNonce();\nerror InvalidSigner();\n"
    },
    "contracts/utils/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { AppStorage, FloorLegType, BuyLegType, SellLegType, TimeUnit, DIP_SPIKE, DCA_UNIT, CURRENT_PRICE } from \"../AppStorage.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\nabstract contract Modifiers {\n    /// @notice 100% = 100000 -> 2 decimals\n\n    modifier onlyOwner() {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        require(msg.sender == s.owner, \"Modifiers: Must be contract owner\");\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
