{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/**\r\n * @notice The `Status` enum represents the possible statuses of a trading strategy.\r\n * @dev This enum defines three status options that describe the state of a strategy:\r\n *      - ACTIVE: The strategy is currently active and operational.\r\n *      - CANCELLED: The strategy has been cancelled and is no longer in effect.\r\n *      - COMPLETED: The strategy has been successfully completed.\r\n */\r\nenum Status {\r\n    ACTIVE, // The strategy is currently active.\r\n    CANCELLED, // The strategy has been cancelled.\r\n    COMPLETED // The strategy has been successfully completed.\r\n}\r\n\r\n/**\r\n * @notice The `FloorLegType` enum defines the types of floor price legs for trading strategies.\r\n * @dev This enum enumerates three possible types of floor price legs that can be associated with a strategy:\r\n *      - NO_TYPE: No specific floor price leg is defined.\r\n *      - LIMIT_PRICE: The floor price is set as a specific limit price.\r\n *      - DECREASE_BY: The floor price is determined by decreasing the current price by a certain amount.\r\n */\r\nenum FloorLegType {\r\n    NO_TYPE, // No specific floor price leg is defined.\r\n    LIMIT_PRICE, // The floor price is set as a specific limit price.\r\n    DECREASE_BY // The floor price is determined by decreasing the current price by a certain amount.\r\n}\r\n/**\r\n * @notice The `BuyLegType` enum defines the types of buy legs for trading strategies.\r\n * @dev This enum enumerates two possible types of buy legs that can be associated with a strategy:\r\n *      - NO_TYPE: No specific buy leg is defined.\r\n *      - LIMIT_PRICE: The buy leg is set as a specific limit price.\r\n */\r\nenum BuyLegType {\r\n    NO_TYPE, // No specific buy leg is defined.\r\n    LIMIT_PRICE // The buy leg is set as a specific limit price.\r\n}\r\n\r\n/**\r\n * @notice The `SellLegType` enum defines the types of sell legs for trading strategies.\r\n * @dev This enum enumerates three possible types of sell legs that can be associated with a strategy:\r\n *      - NO_TYPE: No specific sell leg is defined.\r\n *      - LIMIT_PRICE: The sell leg is set as a specific limit price.\r\n *      - INCREASE_BY: The sell leg is determined by increasing the current price by a certain amount.\r\n */\r\nenum SellLegType {\r\n    NO_TYPE, // No specific sell leg is defined.\r\n    LIMIT_PRICE, // The sell leg is set as a specific limit price.\r\n    INCREASE_BY // The sell leg is determined by increasing the current price by a certain amount.\r\n}\r\n\r\n/**\r\n * @notice The `DIP_SPIKE` enum defines the types of dip and spike conditions for trading strategies.\r\n * @dev This enum enumerates five possible types of dip and spike conditions that can be associated with a strategy:\r\n *      - NO_SPIKE: No specific dip or spike condition is defined.\r\n *      - DECREASE_BY: The condition is based on a decrease in price by a certain percentage.\r\n *      - INCREASE_BY: The condition is based on an increase in price by a certain percentage.\r\n *      - FIXED_INCREASE: The condition is based on a fixed increase in price.\r\n *      - FIXED_DECREASE: The condition is based on a fixed decrease in price.\r\n */\r\nenum DIP_SPIKE {\r\n    NO_SPIKE, // No specific dip or spike condition is defined.\r\n    DECREASE_BY, // The condition is based on a decrease in price by a certain percentage.\r\n    INCREASE_BY, // The condition is based on an increase in price by a certain percentage.\r\n    FIXED_INCREASE, // The condition is based on a fixed increase in price.\r\n    FIXED_DECREASE // The condition is based on a fixed decrease in price.\r\n}\r\n\r\n/**\r\n * @notice The `DCA_UNIT` enum defines the units for Dollar-Cost Averaging (DCA) in trading strategies.\r\n * @dev This enum enumerates three possible units for DCA that can be associated with a strategy:\r\n *      - NO_UNIT: No specific DCA unit is defined.\r\n *      - PERCENTAGE: DCA is specified as a percentage of assets.\r\n *      - FIXED: DCA is specified as a fixed amount.\r\n */\r\nenum DCA_UNIT {\r\n    NO_UNIT, // No specific DCA unit is defined.\r\n    PERCENTAGE, // DCA is specified as a percentage of assets.\r\n    FIXED // DCA is specified as a fixed amount.\r\n}\r\n\r\n/**\r\n * @notice The `CURRENT_PRICE` enum defines the options for selecting the current price source in trading strategies.\r\n * @dev This enum enumerates four possible options for selecting the current price source:\r\n *      - NOT_SELECTED: No specific current price source is selected.\r\n *      - BUY_CURRENT: The current price source is selected for buy actions.\r\n *      - SELL_CURRENT: The current price source is selected for sell actions.\r\n *      - EXECUTED: The current price source is selected for executed actions.\r\n */\r\nenum CURRENT_PRICE {\r\n    NOT_SELECTED, // No specific current price source is selected.\r\n    BUY_CURRENT, // The current price source is selected for buy actions.\r\n    SELL_CURRENT, // The current price source is selected for sell actions.\r\n    EXECUTED // The current price source is selected for executed actions.\r\n}\r\n\r\n/**\r\n * @notice The `TimeUnit` enum defines the units of time for time-related settings in trading strategies.\r\n * @dev This enum enumerates three possible time units that can be used in trading strategies:\r\n *      - NO_UNIT: No specific time unit is defined.\r\n *      - HOURS: Time is measured in hours.\r\n *      - DAYS: Time is measured in days.\r\n */\r\nenum TimeUnit {\r\n    NO_UNIT, // No specific time unit is defined.\r\n    HOURS, // Time is measured in hours.\r\n    DAYS // Time is measured in days.\r\n}\r\n\r\n/**\r\n * @notice The `StrategyParameters` struct defines the parameters that configure a trading strategy.\r\n * @dev These parameters dictate the behavior of the strategy, including trading details, conditions, and actions.\r\n */\r\n\r\nstruct StrategyParameters {\r\n    // @param _investToken The address of the investment token.\r\n    address _investToken;\r\n    // @param _investAmount The amount of investment token to be used.\r\n    uint256 _investAmount;\r\n    // @param _stableToken The address of the stable token.\r\n    address _stableToken;\r\n    // @param _stableAmount The amount of stable token to be used.\r\n    uint256 _stableAmount;\r\n    // @param _slippage The slippage tolerance for the strategy.\r\n    uint256 _slippage;\r\n    //  @param _floor A flag indicating whether a floor price is set.\r\n    bool _floor;\r\n    // @param _floorType The type of floor price (if floor is set).\r\n    FloorLegType _floorType;\r\n    // @param _floorValue The value of the floor price (if floor is set).\r\n    uint256 _floorValue;\r\n    // @param _liquidateOnFloor A flag to trigger liquidation when the floor price is reached (if floor is set)..\r\n    bool _liquidateOnFloor;\r\n    // @param _cancelOnFloor A flag to cancel the strategy when the floor price is reached (if floor is set).\r\n    bool _cancelOnFloor;\r\n    // @param _buy A flag indicating whether a buy price is set.\r\n    bool _buy;\r\n    // @param _buyType The type of buy action (if buy is set).\r\n    BuyLegType _buyType;\r\n    // @param _buyValue The value of the buy action (if buy is set).\r\n    uint256 _buyValue;\r\n    //  @param _buyTwap A flag indicating the use of TWAP for buying (if buy is set).\r\n    bool _buyTwap;\r\n    // @param _buyTwapTime The time interval for TWAP buying (if buy is set).\r\n    uint256 _buyTwapTime;\r\n    // @param _buyTwapTimeUnit The unit of time for TWAP buying .\r\n    TimeUnit _buyTwapTimeUnit;\r\n    // @param _btd A flag indicating a buy the dip action (if buy is set).\r\n    bool _btd;\r\n    // @param _btdValue The value for buying the dip (if buy is set).\r\n    uint256 _btdValue;\r\n    // @param _btdType The type of buy the dip action (if buy is set).\r\n    DIP_SPIKE _btdType;\r\n    // @param _buyDCAUnit The unit for buy DCA (Dollar-Cost Averaging) for stable amount (if buy is set).\r\n    DCA_UNIT _buyDCAUnit;\r\n    // @param _buyDCAValue The value for buy DCA.\r\n    uint256 _buyDCAValue;\r\n    // @param _sell A flag indicating whether a sell price is set.\r\n    bool _sell;\r\n    // @param _sellType The type of sell action (if sell is set).\r\n    SellLegType _sellType;\r\n    // @param _sellValue The value of the sell action (if sell is set).\r\n    uint256 _sellValue;\r\n    // @param if sell DCA is selected, _highSellValue is used to trigger complete sell when the high sell value is reached (if sell is set).\r\n    uint256 _highSellValue;\r\n    // @param _str A flag indicating whether Sell the rally feature of the Sell DCA is selected or not (if sell is set).\r\n    bool _str;\r\n    // @param _strValue The value of the str if it is set to true (if sell is set).\r\n    uint256 _strValue;\r\n    // @param _strType The type of str.\r\n    DIP_SPIKE _strType;\r\n    // @param _sellDCAUnit The unit for sell DCA (Dollar-Cost Averaging) for the invest amount (if sell is set).\r\n    DCA_UNIT _sellDCAUnit;\r\n    // @param _sellDCAValue The value for sell DCA.\r\n    uint256 _sellDCAValue;\r\n    // @param _sellTwap A flag indicating the use of TWAP (Time-Weighted Average Price) for selling (if sell is set).\r\n    bool _sellTwap;\r\n    // @param _sellTwapTime The time interval for TWAP selling (if sell is set).\r\n    uint256 _sellTwapTime;\r\n    //  @param _sellTwapTimeUnit The unit of time for TWAP selling (if sell is set).\r\n    TimeUnit _sellTwapTimeUnit;\r\n    // @param _completeOnSell A flag to complete the strategy on selling (if sell is set).\r\n    bool _completeOnSell;\r\n    // @param _current_price The current price indicator is selected what kind of strategy to execute immediately.\r\n    CURRENT_PRICE _current_price;\r\n}\r\n\r\n/**\r\n * @notice The `Strategy` struct defines the characteristics and status of a trading strategy.\r\n * @dev This struct encapsulates important data related to a trading strategy, including user ownership,\r\n *      strategy parameters, execution times, financial metrics, and its current status.\r\n * it is mostly used for internal computation\r\n */\r\n\r\nstruct Strategy {\r\n    //  @param user The address of the strategy owner.\r\n    address user;\r\n    // @param parameters The parameters that configure the behavior of the strategy\r\n    // as passed by the user and defined above\r\n    StrategyParameters parameters;\r\n    //  @param sellTwapExecutedAt The timestamp of the last executed TWAP (Time-Weighted Average Price) sell.\r\n    //  if sell twap is set for the sell. Otherwise it remains 0\r\n    uint256 sellTwapExecutedAt;\r\n    //  @param buyTwapExecutedAt The timestamp of the last executed TWAP buy.\r\n    //  if buy Twap is set for btd. Otherwise it remains 0.\r\n    uint256 buyTwapExecutedAt;\r\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\r\n    uint80 investRoundId;\r\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\r\n    uint80 stableRoundId;\r\n    // @param investPrice The price at which investment is made.\r\n    //While creating strategy it is set to the current price\r\n    uint256 investPrice;\r\n    //  @param profit The current profit generated by the strategy.\r\n    uint256 profit;\r\n    //  @param budget The available budget for the strategy.\r\n    // it is set at the starting of the strategy\r\n    uint256 budget;\r\n    // @param status The current status of the strategy.\r\n    Status status;\r\n}\r\n/**\r\n * @notice AppStorage is the central storage structure for this contract, holding essential data.\r\n * @dev This struct contains critical information used by the contract for operation.\r\n * It stores data such as function selectors, supported interfaces, the contract owner, strategy details,\r\n * Chainlink feed information, and more.\r\n */\r\n\r\nstruct AppStorage {\r\n    // maps function selectors to the facets that execute the functions.\r\n    // and maps the selectors to their position in the selectorSlots array.\r\n    // func selector => address facet, selector position\r\n    mapping(bytes4 => bytes32) facets;\r\n    // array of slots of function selectors.\r\n    // each slot holds 8 function selectors.\r\n    mapping(uint256 => bytes32) selectorSlots;\r\n    // The number of function selectors in selectorSlots\r\n    uint16 selectorCount;\r\n    // Used to query if a contract implements an interface.\r\n    // Used to implement ERC-165.\r\n    mapping(bytes4 => bool) supportedInterfaces;\r\n    // owner of the contract\r\n    address owner;\r\n    // next id to use for strategies\r\n    uint256 nextStrategyId;\r\n    // array of strategies\r\n    mapping(uint256 => Strategy) strategies;\r\n    // chainlink feeds - asset => USD feed\r\n    mapping(address => address) feeds;\r\n}\r\n\r\n/**\r\n * @title Swap\r\n * @dev A struct representing a swap or trade operation on a decentralized exchange (DEX).\r\n *  @param dex: The address of the DEX where the swap is to be executed.\r\n *  @param callData: Encoded data containing instructions for the swap on the specified DEX.\r\n */\r\nstruct Swap {\r\n    address dex;\r\n    bytes callData;\r\n}\r\n"
    },
    "contracts/Diamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { LibDiamond } from \"./libraries/LibDiamond.sol\";\r\nimport { IDiamondCut } from \"./interfaces/IDiamondCut.sol\";\r\nimport { AppStorage } from \"./AppStorage.sol\";\r\n\r\ncontract Diamond {\r\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\r\n        LibDiamond.setContractOwner(_contractOwner);\r\n\r\n        // Add the diamondCut external function from the diamondCutFacet\r\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\r\n        bytes4[] memory functionSelectors = new bytes4[](1);\r\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\r\n        cut[0] = IDiamondCut.FacetCut({\r\n            facetAddress: _diamondCutFacet,\r\n            action: IDiamondCut.FacetCutAction.Add,\r\n            functionSelectors: functionSelectors\r\n        });\r\n        LibDiamond.diamondCut(cut, address(0), \"\");\r\n    }\r\n\r\n    // Find facet for function that is called and execute the\r\n    // function if a facet is found and return any value.\r\n    fallback() external payable {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n\r\n        // get facet from function selector\r\n        address facet = address(bytes20(s.facets[msg.sig]));\r\n        require(facet != address(0), \"Diamond: Function does not exist\");\r\n        // Execute external function from facet using delegatecall and return any value.\r\n        assembly {\r\n            // copy function selector and any arguments\r\n            calldatacopy(0, 0, calldatasize())\r\n            // execute function call using the facet\r\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\r\n            // get any return value\r\n            returndatacopy(0, 0, returndatasize())\r\n            // return any return value or error back to the caller\r\n            switch result\r\n            case 0 {\r\n                revert(0, returndatasize())\r\n            }\r\n            default {\r\n                return(0, returndatasize())\r\n            }\r\n        }\r\n    }\r\n\r\n    receive() external payable {}\r\n}\r\n"
    },
    "contracts/facets/BuyFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { AppStorage, Strategy, Status, DCA_UNIT, DIP_SPIKE, SellLegType, BuyLegType, FloorLegType, CURRENT_PRICE, Swap } from \"../AppStorage.sol\";\r\nimport { LibSwap } from \"../libraries/LibSwap.sol\";\r\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, FloorGreaterThanPrice, WrongPreviousIDs, RoundDataDoesNotMatch, StrategyIsNotActive } from \"../utils/GenericErrors.sol\";\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\r\nimport { LibTime } from \"../libraries/LibTime.sol\";\r\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\r\n\r\nerror BuyNotSet();\r\nerror BuyDCAIsSet();\r\nerror BuyTwapNotSelected();\r\nerror ExpectedTimeNotElapsed();\r\nerror BTDNotSelected();\r\nerror PriceIsGreaterThanBuyValue();\r\nerror PriceDippedBelowFloorValue();\r\n\r\n/**\r\n * @title BuyFacet\r\n * @notice This facet contains functions responsible for evaluating conditions necessary for executing buy actions.\r\n * @dev BuyFacet specializes in verifying conditions related to limit price buys and Dollar-Cost Averaging (DCA) buys,\r\n *      ensuring that the necessary criteria are met before executing a buy action.\r\n */\r\n\r\ncontract BuyFacet is Modifiers {\r\n    /**\r\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\r\n     * please look at AppStorage.sol for more detail\r\n     */\r\n    AppStorage internal s;\r\n\r\n    /**\r\n     * @notice Emitted when a buy action is executed for a trading strategy.\r\n     * @param strategyId The unique ID of the strategy where the buy action was executed.\r\n     * @param price The price at which the buy action was executed.\r\n     * @param slippage The allowable price slippage percentage for the buy action.\r\n     * @param investTokenAmount The amount of invest tokens bought.\r\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\r\n     */\r\n\r\n    event BuyExecuted(\r\n        uint256 indexed strategyId,\r\n        uint256 price,\r\n        uint256 slippage,\r\n        uint256 investTokenAmount,\r\n        uint256 exchangeRate\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a Buy on Time-Weighted Average Price (TWAP) action is executed for a trading strategy using a specific DEX, call data, buy value, and execution time.\r\n     * @param strategyId The unique ID of the strategy where the Buy on TWAP action was executed.\r\n     * @param price The price at which the Buy on TWAP action was executed.\r\n     * @param slippage The allowable price slippage percentage for the buy action.\r\n     * @param investTokenAmount The amount of invest tokens bought.\r\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\r\n     * @param time The time at which it was executed.\r\n     */\r\n    event BuyTwapExecuted(\r\n        uint256 indexed strategyId,\r\n        uint256 price,\r\n        uint256 slippage,\r\n        uint256 investTokenAmount,\r\n        uint256 exchangeRate,\r\n        uint256 time\r\n    );\r\n    /**\r\n     * @notice Emitted when a Buy The Dip (BTD) action is executed for a trading strategy using a specific DEX, call data, buy value, and execution time.\r\n     * @param strategyId The unique ID of the strategy where the BTD action was executed.\r\n     * @param price The price at which the BTD action was executed.\r\n     * @param slippage The allowable price slippage percentage for the buy action.\r\n     * @param investTokenAmount The amount of invest tokens bought.\r\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\r\n     */\r\n    event BTDExecuted(\r\n        uint256 indexed strategyId,\r\n        uint256 price,\r\n        uint256 slippage,\r\n        uint256 investTokenAmount,\r\n        uint256 exchangeRate\r\n    );\r\n\r\n    /**\r\n     * @notice Executes a buy action for a trading strategy based on specified conditions.\r\n     * @dev The function validates strategy parameters, executes the buy action, and updates the strategy state.\r\n     * @param strategyId The unique ID of the strategy for which the buy action is executed.\r\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n     */\r\n    function executeBuy(uint256 strategyId, Swap calldata swap) external {\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        if (strategy.status != Status.ACTIVE) {\r\n            revert StrategyIsNotActive();\r\n        }\r\n\r\n        if (!strategy.parameters._buy) {\r\n            revert BuyNotSet();\r\n        }\r\n        if (strategy.parameters._btd || strategy.parameters._buyTwap) {\r\n            revert BuyDCAIsSet();\r\n        }\r\n        if (strategy.parameters._stableAmount == 0) {\r\n            revert NoSwapFromZeroBalance();\r\n        }\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        updateCurrentPrice(strategyId, price);\r\n        uint256 value = executionBuyAmount(true, strategyId);\r\n\r\n        transferBuy(strategyId, value, swap, price, investRoundId, stableRoundId, strategy.parameters._buyValue);\r\n\r\n        if (!strategy.parameters._sell && !strategy.parameters._floor) {\r\n            strategy.status = Status.COMPLETED;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Executes a Buy on Time-Weighted Average Price (TWAP) action for a trading strategy.\r\n     * @param strategyId The unique ID of the strategy to execute the Buy on TWAP action.\r\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n     */\r\n    function executeBuyTwap(uint256 strategyId, Swap calldata swap) external {\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        if (strategy.status != Status.ACTIVE) {\r\n            revert StrategyIsNotActive();\r\n        }\r\n\r\n        if (!strategy.parameters._buyTwap) {\r\n            revert BuyTwapNotSelected();\r\n        }\r\n        if (strategy.parameters._stableAmount == 0) {\r\n            revert NoSwapFromZeroBalance();\r\n        }\r\n\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        updateCurrentPrice(strategyId, price);\r\n\r\n        uint256 timeToExecute = LibTime.convertToSeconds(\r\n            strategy.parameters._buyTwapTime,\r\n            strategy.parameters._buyTwapTimeUnit\r\n        );\r\n\r\n        bool execute = LibTime.getTimeDifference(block.timestamp, strategy.buyTwapExecutedAt, timeToExecute);\r\n\r\n        if (!execute) {\r\n            revert ExpectedTimeNotElapsed();\r\n        }\r\n\r\n        uint256 value = executionBuyAmount(false, strategyId);\r\n\r\n        transferBuy(strategyId, value, swap, price, investRoundId, stableRoundId, strategy.parameters._buyValue);\r\n        strategy.buyTwapExecutedAt = block.timestamp;\r\n        if (!strategy.parameters._sell && !strategy.parameters._floor && strategy.parameters._stableAmount == 0) {\r\n            strategy.status = Status.COMPLETED;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Executes a Buy-The-Dip (BTD) trading strategy action within a specified price range.\r\n     * This function allows the strategy to buy the invest token when its price decreases to a certain target value, following a specified DIP strategy type.\r\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\r\n     * @param fromInvestRoundId The starting invest round ID for monitoring price fluctuations.\r\n     * @param toInvestRoundId The ending invest round ID for monitoring price fluctuations.\r\n     * @param fromStableRoundId The starting stable round ID for monitoring price fluctuations.\r\n     * @param toStableRoundId The ending stable round ID for monitoring price fluctuations.\r\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n     */\r\n\r\n    function executeBTD(\r\n        uint256 strategyId,\r\n        uint80 fromInvestRoundId,\r\n        uint80 fromStableRoundId,\r\n        uint80 toInvestRoundId,\r\n        uint80 toStableRoundId,\r\n        Swap calldata swap\r\n    ) external {\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n        if (strategy.status != Status.ACTIVE) {\r\n            revert StrategyIsNotActive();\r\n        }\r\n\r\n        if (!strategy.parameters._btd) {\r\n            revert BTDNotSelected();\r\n        }\r\n        if (strategy.parameters._stableAmount == 0) {\r\n            revert NoSwapFromZeroBalance();\r\n        }\r\n\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        checkRoundPrices(\r\n            strategyId,\r\n            fromInvestRoundId,\r\n            fromStableRoundId,\r\n            toInvestRoundId,\r\n            toStableRoundId,\r\n            investRoundId,\r\n            stableRoundId\r\n        );\r\n\r\n        uint256 value = executionBuyAmount(false, strategyId);\r\n\r\n        transferBuy(strategyId, value, swap, price, investRoundId, stableRoundId, strategy.parameters._buyValue);\r\n        if (!strategy.parameters._sell && !strategy.parameters._floor && strategy.parameters._stableAmount == 0) {\r\n            strategy.status = Status.COMPLETED;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the effective value for a buy action in a trading strategy.\r\n     * @param stableAmount Boolean flag indicating whether to consider the entire stable token amount.\r\n     * @param strategyId The unique ID of the strategy for which to calculate the buy value.\r\n     * @return The calculated buy value based on the specified parameters.\r\n     */\r\n    function executionBuyAmount(bool stableAmount, uint256 strategyId) public view returns (uint256) {\r\n        uint256 amount;\r\n        Strategy memory strategy = s.strategies[strategyId];\r\n        if (stableAmount) {\r\n            amount = strategy.parameters._stableAmount;\r\n        } else if (strategy.parameters._buyDCAUnit == DCA_UNIT.FIXED) {\r\n            amount = (strategy.parameters._stableAmount > strategy.parameters._buyDCAValue)\r\n                ? strategy.parameters._buyDCAValue\r\n                : strategy.parameters._stableAmount;\r\n        } else if (strategy.parameters._buyDCAUnit == DCA_UNIT.PERCENTAGE) {\r\n            uint256 buyPercentageAmount = (strategy.parameters._buyDCAValue * strategy.parameters._stableAmount) /\r\n                LibTrade.MAX_PERCENTAGE;\r\n            amount = (strategy.parameters._stableAmount > buyPercentageAmount)\r\n                ? buyPercentageAmount\r\n                : strategy.parameters._stableAmount;\r\n        }\r\n\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Update the current price of a trading strategy based on the given price.\r\n     * @param strategyId The unique ID of the strategy to update.\r\n     * @param price The new price to set as the current price.\r\n     */\r\n    function updateCurrentPrice(uint256 strategyId, uint256 price) internal {\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        if (strategy.parameters._current_price == CURRENT_PRICE.BUY_CURRENT) {\r\n            strategy.parameters._buyValue = price;\r\n            strategy.parameters._current_price = CURRENT_PRICE.EXECUTED;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to execute a \"Buy\" action within a specified price range.\r\n     * @dev This function transfers assets from stable tokens to investment tokens on a DEX.\r\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\r\n     * @param value The value to be transferred from stable tokens to investment tokens.\r\n     * @param dexSwap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n     * @param price The current price of the investment token.\r\n     * @param investRoundId The invest round ID associated with the current price data.\r\n     * @param stableRoundId The stable round ID associated with the current price data.\r\n     * @param buyValue The target price at which the \"Buy\" action should be executed.\r\n     */\r\n\r\n    function transferBuy(\r\n        uint256 strategyId,\r\n        uint256 value,\r\n        Swap memory dexSwap,\r\n        uint256 price,\r\n        uint80 investRoundId,\r\n        uint80 stableRoundId,\r\n        uint256 buyValue\r\n    ) internal {\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n        if (price > buyValue) {\r\n            revert PriceIsGreaterThanBuyValue();\r\n        }\r\n\r\n        if (strategy.parameters._floor && strategy.parameters._floorValue > 0) {\r\n            uint256 floorAt;\r\n            if (strategy.parameters._floorType == FloorLegType.LIMIT_PRICE) {\r\n                floorAt = strategy.parameters._floorValue;\r\n            } else if (strategy.parameters._floorType == FloorLegType.DECREASE_BY) {\r\n                uint256 floorPercentage = LibTrade.MAX_PERCENTAGE - strategy.parameters._floorValue;\r\n                floorAt = (strategy.investPrice * floorPercentage) / LibTrade.MAX_PERCENTAGE;\r\n            }\r\n\r\n            if (floorAt > price) {\r\n                revert FloorGreaterThanPrice();\r\n            }\r\n        }\r\n        LibSwap.SwapData memory swap = LibSwap.SwapData(\r\n            dexSwap.dex,\r\n            strategy.parameters._stableToken,\r\n            strategy.parameters._investToken,\r\n            value,\r\n            dexSwap.callData,\r\n            strategy.user\r\n        );\r\n\r\n        uint256 toTokenAmount = LibSwap.swap(swap);\r\n\r\n        uint256 rate = LibTrade.calculateExchangeRate(strategy.parameters._investToken, toTokenAmount, value);\r\n\r\n        if (rate > buyValue) {\r\n            revert InvalidExchangeRate(buyValue, rate);\r\n        }\r\n\r\n        strategy.parameters._stableAmount -= value;\r\n        uint256 previousValue = strategy.parameters._investAmount * strategy.investPrice;\r\n        strategy.parameters._investAmount = strategy.parameters._investAmount + toTokenAmount;\r\n\r\n        strategy.investPrice = (previousValue + (toTokenAmount * price)) / strategy.parameters._investAmount;\r\n\r\n        strategy.investRoundId = investRoundId;\r\n        strategy.stableRoundId = stableRoundId;\r\n\r\n        uint256 slippage = LibTrade.validateSlippage(rate, price, strategy.parameters._slippage, true);\r\n\r\n        if (strategy.parameters._buy && !strategy.parameters._btd && !strategy.parameters._buyTwap) {\r\n            emit BuyExecuted(strategyId, price, slippage, toTokenAmount, rate);\r\n        } else if (strategy.parameters._btd) {\r\n            emit BTDExecuted(strategyId, price, slippage, toTokenAmount, rate);\r\n        } else if (strategy.parameters._buyTwap) {\r\n            emit BuyTwapExecuted(strategyId, price, slippage, toTokenAmount, rate, block.timestamp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to check if there is a data mismatch between price rounds for a strategy.\r\n     * @dev This function ensures that the price fluctuations between specified rounds adhere to strategy parameters.\r\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\r\n     * @param fromInvestRoundId The round ID for the investment token's price data to start checking from.\r\n     * @param fromStableRoundId The round ID for the stable token's price data to start checking from.\r\n     * @param toInvestRoundId The round ID for the investment token's price data to check up to.\r\n     * @param toStableRoundId The round ID for the stable token's price data to check up to.\r\n     * @param presentInvestRound The present round ID for the invest token's price.\r\n     * @param presentStableRound The present round ID for the stable token's price.\r\n     */\r\n    function checkRoundPrices(\r\n        uint256 strategyId,\r\n        uint80 fromInvestRoundId,\r\n        uint80 fromStableRoundId,\r\n        uint80 toInvestRoundId,\r\n        uint80 toStableRoundId,\r\n        uint80 presentInvestRound,\r\n        uint80 presentStableRound\r\n    ) internal view {\r\n        Strategy memory strategy = s.strategies[strategyId];\r\n\r\n        if (presentInvestRound < toInvestRoundId || presentStableRound < toStableRoundId) {\r\n            revert WrongPreviousIDs();\r\n        }\r\n        if (toInvestRoundId < fromInvestRoundId || toStableRoundId < fromStableRoundId) {\r\n            revert WrongPreviousIDs();\r\n        }\r\n        if (\r\n            strategy.investRoundId >= fromInvestRoundId ||\r\n            strategy.investRoundId >= toInvestRoundId ||\r\n            strategy.stableRoundId >= fromStableRoundId ||\r\n            strategy.stableRoundId >= toStableRoundId\r\n        ) {\r\n            revert WrongPreviousIDs();\r\n        }\r\n\r\n        uint256 fromPrice = LibPrice.getRoundData(\r\n            fromInvestRoundId,\r\n            fromStableRoundId,\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n        uint256 toPrice = LibPrice.getRoundData(\r\n            toInvestRoundId,\r\n            toStableRoundId,\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        uint256 btdValue = strategy.parameters._btdValue;\r\n        uint256 fromToPriceDifference;\r\n        uint256 toFromPriceDifference;\r\n\r\n        if (\r\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE ||\r\n                strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY)\r\n        ) {\r\n            if (toPrice < fromPrice) {\r\n                revert RoundDataDoesNotMatch();\r\n            } else {\r\n                toFromPriceDifference = toPrice - fromPrice;\r\n            }\r\n        }\r\n        if (\r\n            (strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE ||\r\n                strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY)\r\n        ) {\r\n            if (toPrice > fromPrice) {\r\n                revert RoundDataDoesNotMatch();\r\n            } else {\r\n                fromToPriceDifference = fromPrice - toPrice;\r\n            }\r\n        }\r\n\r\n        if ((strategy.parameters._btdType == DIP_SPIKE.FIXED_INCREASE) && (btdValue > toFromPriceDifference)) {\r\n            revert RoundDataDoesNotMatch();\r\n        } else if ((strategy.parameters._btdType == DIP_SPIKE.FIXED_DECREASE) && (btdValue > fromToPriceDifference)) {\r\n            revert RoundDataDoesNotMatch();\r\n        } else if (\r\n            (strategy.parameters._btdType == DIP_SPIKE.INCREASE_BY) &&\r\n            (btdValue > ((toFromPriceDifference * 10000) / fromPrice))\r\n        ) {\r\n            revert RoundDataDoesNotMatch();\r\n        } else if (\r\n            (strategy.parameters._btdType == DIP_SPIKE.DECREASE_BY) &&\r\n            (btdValue > ((fromToPriceDifference * 10000) / fromPrice))\r\n        ) {\r\n            revert RoundDataDoesNotMatch();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\nimport { AppStorage } from \"../AppStorage.sol\";\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\ncontract DiamondCutFacet is IDiamondCut, Modifiers {\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(\r\n        FacetCut[] calldata _diamondCut,\r\n        address _init,\r\n        bytes calldata _calldata\r\n    ) external override onlyOwner {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        uint256 originalSelectorCount = s.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\r\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\r\n            (selectorCount, selectorSlot) = LibDiamond.addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n\r\n            unchecked {\r\n                facetIndex++;\r\n            }\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            s.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\r\n        if (selectorCount & 7 > 0) {\r\n            // \"selectorCount >> 3\" is a gas efficient division by 8 \"selectorCount / 8\"\r\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        LibDiamond.initializeDiamondCut(_init, _calldata);\r\n    }\r\n}\r\n"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\r\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\r\nimport { AppStorage } from \"../AppStorage.sol\";\r\n\r\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\r\n// The EIP-2535 Diamond standard requires these functions\r\n\r\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\r\n    // Diamond Loupe Functions\r\n    ////////////////////////////////////////////////////////////////////\r\n    /// These functions are expected to be called frequently by tools.\r\n    //\r\n    // struct Facet {\r\n    //     address facetAddress;\r\n    //     bytes4[] functionSelectors;\r\n    // }\r\n    /// @notice Gets all facets and their selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view override returns (Facet[] memory facets_) {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        facets_ = new Facet[](s.selectorCount);\r\n        uint16[] memory numFacetSelectors = new uint16[](s.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < s.selectorCount; slotIndex++) {\r\n            bytes32 slot = s.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > s.selectorCount) {\r\n                    break;\r\n                }\r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(s.facets[selector]));\r\n                bool continueLoop;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facets_[facetIndex].facetAddress == facetAddress_) {\r\n                        facets_[facetIndex].functionSelectors[numFacetSelectors[facetIndex]] = selector;\r\n                        // probably will never have more than 256 functions from one facet contract\r\n                        require(numFacetSelectors[facetIndex] < 255);\r\n                        numFacetSelectors[facetIndex]++;\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n                facets_[numFacets].facetAddress = facetAddress_;\r\n                facets_[numFacets].functionSelectors = new bytes4[](s.selectorCount);\r\n                facets_[numFacets].functionSelectors[0] = selector;\r\n                numFacetSelectors[numFacets] = 1;\r\n                numFacets++;\r\n            }\r\n        }\r\n        for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n            uint256 numSelectors = numFacetSelectors[facetIndex];\r\n            bytes4[] memory selectors = facets_[facetIndex].functionSelectors;\r\n            // setting the number of selectors\r\n            assembly {\r\n                mstore(selectors, numSelectors)\r\n            }\r\n        }\r\n        // setting the number of facets\r\n        assembly {\r\n            mstore(facets_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return _facetFunctionSelectors The selectors associated with a facet address.\r\n    function facetFunctionSelectors(\r\n        address _facet\r\n    ) external view override returns (bytes4[] memory _facetFunctionSelectors) {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        uint256 numSelectors;\r\n        _facetFunctionSelectors = new bytes4[](s.selectorCount);\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < s.selectorCount; slotIndex++) {\r\n            bytes32 slot = s.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > s.selectorCount) {\r\n                    break;\r\n                }\r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facet = address(bytes20(s.facets[selector]));\r\n                if (_facet == facet) {\r\n                    _facetFunctionSelectors[numSelectors] = selector;\r\n                    numSelectors++;\r\n                }\r\n            }\r\n        }\r\n        // Set the number of selectors in the array\r\n        assembly {\r\n            mstore(_facetFunctionSelectors, numSelectors)\r\n        }\r\n    }\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view override returns (address[] memory facetAddresses_) {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        facetAddresses_ = new address[](s.selectorCount);\r\n        uint256 numFacets;\r\n        uint256 selectorIndex;\r\n        // loop through function selectors\r\n        for (uint256 slotIndex; selectorIndex < s.selectorCount; slotIndex++) {\r\n            bytes32 slot = s.selectorSlots[slotIndex];\r\n            for (uint256 selectorSlotIndex; selectorSlotIndex < 8; selectorSlotIndex++) {\r\n                selectorIndex++;\r\n                if (selectorIndex > s.selectorCount) {\r\n                    break;\r\n                }\r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                bytes4 selector = bytes4(slot << (selectorSlotIndex << 5));\r\n                address facetAddress_ = address(bytes20(s.facets[selector]));\r\n                bool continueLoop;\r\n                for (uint256 facetIndex; facetIndex < numFacets; facetIndex++) {\r\n                    if (facetAddress_ == facetAddresses_[facetIndex]) {\r\n                        continueLoop = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (continueLoop) {\r\n                    continue;\r\n                }\r\n                facetAddresses_[numFacets] = facetAddress_;\r\n                numFacets++;\r\n            }\r\n        }\r\n        // Set the number of facet addresses in the array\r\n        assembly {\r\n            mstore(facetAddresses_, numFacets)\r\n        }\r\n    }\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view override returns (address facetAddress_) {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        facetAddress_ = address(bytes20(s.facets[_functionSelector]));\r\n    }\r\n\r\n    // This implements ERC-165.\r\n    function supportsInterface(bytes4 _interfaceId) external view override returns (bool) {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        return s.supportedInterfaces[_interfaceId];\r\n    }\r\n}\r\n"
    },
    "contracts/facets/FloorFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\nimport { AppStorage, Strategy, Status, Swap, FloorLegType } from \"../AppStorage.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { LibSwap } from \"../libraries/LibSwap.sol\";\r\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\r\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\r\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, StrategyIsNotActive } from \"../utils/GenericErrors.sol\";\r\nerror FloorNotSet();\r\nerror PriceIsGreaterThanFloorValue();\r\n\r\n/**\r\n * @title FloorFacet\r\n * @notice This facet contains functions responsible for evaluating conditions related to the floor price and liquidation events.\r\n * @dev FloorFacet specializes in verifying floor price conditions, handling liquidation actions when the floor price is reached,\r\n *      ensuring that the necessary criteria are met before taking any actions and also cancelling the strategy if provided.\r\n */\r\n\r\ncontract FloorFacet is Modifiers {\r\n    /**\r\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\r\n     * please look at AppStorage.sol for more detail\r\n     */\r\n    AppStorage internal s;\r\n\r\n    /**\r\n     * @notice Emitted when a floor execution is initiated for a trading strategy.\r\n     * @param strategyId The unique ID of the strategy where the floor execution is initiated.\r\n     * @param price The price at which the floor action was executed.\r\n     * @param slippage The allowable price slippage percentage for the buy action.\r\n     * @param stableTokenAmount The amount of stable tokens bought.\r\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\r\n     */\r\n    event FloorExecuted(\r\n        uint256 indexed strategyId,\r\n        uint256 price,\r\n        uint256 slippage,\r\n        uint256 stableTokenAmount,\r\n        uint256 exchangeRate\r\n    );\r\n\r\n    /**\r\n     * @notice Execute a floor price check and potential liquidation for a trading strategy.\r\n     * @dev This function performs a floor price check and, if the strategy's parameters meet the required conditions,\r\n     *      it may execute a liquidation of assets. Liquidation occurs if the strategy's floor price is reached and\r\n     *      liquidation is enabled in the strategy parameters.\r\n     * @param strategyId The unique ID of the strategy to execute the floor check for.\r\n     * @param dexSwap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n     */\r\n    function executeFloor(uint256 strategyId, Swap calldata dexSwap) external {\r\n        // Retrieve the strategy details.\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n        if (strategy.status != Status.ACTIVE) {\r\n            revert StrategyIsNotActive();\r\n        }\r\n\r\n        // Check if the floor price is set in the strategy parameters.\r\n        if (!strategy.parameters._floor) {\r\n            revert FloorNotSet();\r\n        }\r\n\r\n        // Ensure that there are assets available for swapping.\r\n        if (strategy.parameters._investAmount == 0) {\r\n            revert NoSwapFromZeroBalance();\r\n        }\r\n\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        uint256 floorAt;\r\n        if (strategy.parameters._floorType == FloorLegType.LIMIT_PRICE) {\r\n            floorAt = strategy.parameters._floorValue;\r\n        } else if (strategy.parameters._floorType == FloorLegType.DECREASE_BY) {\r\n            uint256 floorPercentage = LibTrade.MAX_PERCENTAGE - strategy.parameters._floorValue;\r\n            floorAt = (strategy.investPrice * floorPercentage) / LibTrade.MAX_PERCENTAGE;\r\n        }\r\n\r\n        if (price > floorAt) {\r\n            revert PriceIsGreaterThanFloorValue();\r\n        }\r\n\r\n        // If liquidation is enabled, initiate a swap of assets.\r\n        if (strategy.parameters._liquidateOnFloor) {\r\n            // Prepare swap data for the DEX.\r\n            LibSwap.SwapData memory swap = LibSwap.SwapData(\r\n                dexSwap.dex,\r\n                strategy.parameters._investToken,\r\n                strategy.parameters._stableToken,\r\n                strategy.parameters._investAmount,\r\n                dexSwap.callData,\r\n                strategy.user\r\n            );\r\n\r\n            // Execute the asset swap and calculate the exchange rate.\r\n            uint256 toTokenAmount = LibSwap.swap(swap);\r\n            uint256 rate = LibTrade.calculateExchangeRate(\r\n                strategy.parameters._investToken,\r\n                strategy.parameters._investAmount,\r\n                toTokenAmount\r\n            );\r\n\r\n            // Check if the calculated exchange rate is within the acceptable range.\r\n            if (rate > floorAt) {\r\n                revert InvalidExchangeRate(floorAt, rate);\r\n            }\r\n\r\n            // Validate the slippage based on the calculated rate and the latest price.\r\n            uint256 slippage = LibTrade.validateSlippage(rate, price, strategy.parameters._slippage, false);\r\n\r\n            // Update strategy details, including timestamp, asset amounts, round ID, and invest price.\r\n            strategy.parameters._investAmount = 0;\r\n            strategy.parameters._stableAmount += toTokenAmount;\r\n            strategy.investRoundId = investRoundId;\r\n            strategy.stableRoundId = stableRoundId;\r\n            strategy.investPrice = 0;\r\n\r\n            // Check if the strategy should be canceled on reaching the floor price.\r\n            if (strategy.parameters._cancelOnFloor) {\r\n                strategy.status = Status.CANCELLED;\r\n            }\r\n            emit FloorExecuted(strategyId, price, slippage, toTokenAmount, rate);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/facets/LensFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\r\n\r\n/**\r\n * @title LensFacet\r\n * @dev This contract provides functions for calculating exchange rates and validating slippage in trades.\r\n */\r\ncontract LensFacet is Modifiers {\r\n    /**\r\n     * @notice Calculate the exchange rate between two assets for a given trade.\r\n     * @param fromAsset The address of the source asset.\r\n     * @param fromAmount The amount of the source asset.\r\n     * @param toAmount The amount of the target asset.\r\n     * @return The calculated exchange rate.\r\n     */\r\n    function calculateExchangeRate(\r\n        address fromAsset,\r\n        uint256 fromAmount,\r\n        uint256 toAmount\r\n    ) external view returns (uint256) {\r\n        return LibTrade.calculateExchangeRate(fromAsset, fromAmount, toAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Validate slippage for a trade based on exchange rate, price, and maximum allowed slippage.\r\n     * @param exchangeRate The calculated exchange rate for the trade.\r\n     * @param price The current market price.\r\n     * @param maxSlippage The maximum allowable slippage percentage.\r\n     * @param isBuy A flag indicating whether it's a buy (true) or sell (false) trade.\r\n     * @return The validated slippage for the trade.\r\n     */\r\n    function validateSlippage(\r\n        uint256 exchangeRate,\r\n        uint256 price,\r\n        uint256 maxSlippage,\r\n        bool isBuy\r\n    ) external pure returns (uint256) {\r\n        return LibTrade.validateSlippage(exchangeRate, price, maxSlippage, isBuy);\r\n    }\r\n}\r\n"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\nimport { AppStorage } from \"../AppStorage.sol\";\r\n\r\n/**\r\n * @title OwnershipFacet\r\n * @dev This contract handles the ownership management of the diamond contract.\r\n */\r\ncontract OwnershipFacet is IERC173, Modifiers {\r\n    AppStorage internal s;\r\n\r\n    /**\r\n     * @notice Transfers ownership of the diamond contract to a new owner.\r\n     * @param _newOwner The address of the new owner.\r\n     */\r\n    function transferOwnership(address _newOwner) external override onlyOwner {\r\n        LibDiamond.setContractOwner(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the current owner of the diamond contract.\r\n     */\r\n    function owner() external view override returns (address owner_) {\r\n        owner_ = s.owner;\r\n    }\r\n}\r\n"
    },
    "contracts/facets/PriceOracleFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\nimport { AppStorage } from \"../AppStorage.sol\";\r\n\r\n/**\r\n * @title PriceOracleFacet\r\n * @dev This contract manages asset price feeds used by the diamond contract.\r\n */\r\ncontract PriceOracleFacet is Modifiers {\r\n    AppStorage internal s;\r\n\r\n    /**\r\n     * @notice Sets the asset price feed address for a specific asset.\r\n     * @param _asset The address of the asset.\r\n     * @param _feed The address of the price feed for the asset.\r\n     */\r\n    function setAssetFeed(address _asset, address _feed) external onlyOwner {\r\n        s.feeds[_asset] = _feed;\r\n    }\r\n}\r\n"
    },
    "contracts/facets/SellFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { AppStorage, Strategy, Status, DCA_UNIT, DIP_SPIKE, SellLegType, CURRENT_PRICE, Swap } from \"../AppStorage.sol\";\r\nimport { LibSwap } from \"../libraries/LibSwap.sol\";\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\nimport { InvalidExchangeRate, NoSwapFromZeroBalance, WrongPreviousIDs, RoundDataDoesNotMatch, StrategyIsNotActive } from \"../utils/GenericErrors.sol\";\r\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\r\nimport { LibTime } from \"../libraries/LibTime.sol\";\r\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\r\n\r\nerror SellNotSelected();\r\nerror PriceLessThanHighSellValue();\r\nerror SellDCASelected();\r\nerror SellTwapNotSelected();\r\nerror ValueGreaterThanHighSellValue();\r\nerror TWAPTimeDifferenceIsLess();\r\nerror STRNotSelected();\r\nerror PriceLessThanSellValue();\r\nerror PriceIsNotInTheRange();\r\n\r\n/**\r\n * @title SellFacet\r\n * @notice This facet contains functions responsible for evaluating conditions for executing sell actions.\r\n * @dev SellFacet specializes in verifying conditions related to sell actions,\r\n * including limit price sells, Time-Weighted Average Price (TWAP) sells, and sell the rally criteria.\r\n *      It ensures that the necessary conditions are met before executing sell actions.\r\n */\r\ncontract SellFacet is Modifiers {\r\n    /**\r\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\r\n     * please look at AppStorage.sol for more detail\r\n     */\r\n    AppStorage internal s;\r\n\r\n    /**\r\n     * @notice Emitted when a sell action is executed for a trading strategy using a specific DEX and call data.\r\n     * @param strategyId The unique ID of the strategy where the sell action is executed.\r\n     * @param price The price at which the  sell action was executed.\r\n     * @param slippage The allowable price slippage percentage for the buy action.\r\n     * @param stableTokenAmount The amount of stable tokens bought.\r\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\r\n     */\r\n    event SellExecuted(\r\n        uint256 indexed strategyId,\r\n        uint256 price,\r\n        uint256 slippage,\r\n        uint256 stableTokenAmount,\r\n        uint256 exchangeRate\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a Time-Weighted Average Price (TWAP) sell action is executed for a trading strategy using a specific DEX and call data.\r\n     * @param strategyId The unique ID of the strategy where the TWAP sell action was executed.\r\n     * @param price The price at which the TWAP sell action was executed.\r\n     * @param slippage The allowable price slippage percentage for the buy action.\r\n     * @param stableTokenAmount The amount of stable tokens bought.\r\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\r\n     * @param time The time at which it was executed.\r\n     */\r\n    event SellTwapExecuted(\r\n        uint256 indexed strategyId,\r\n        uint256 price,\r\n        uint256 slippage,\r\n        uint256 stableTokenAmount,\r\n        uint256 exchangeRate,\r\n        uint256 time\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a Spike Trigger (STR) event is executed for a trading strategy using a specific DEX and call data.\r\n     * @param strategyId The unique ID of the strategy where the STR event was executed.\r\n     * @param price The price at which the STR event was executed.\r\n     * @param slippage The allowable price slippage percentage for the buy action.\r\n     * @param stableTokenAmount The amount of stable tokens bought.\r\n     * @param exchangeRate The exchange rate at which the tokens were acquired.\r\n     */\r\n    event STRExecuted(\r\n        uint256 indexed strategyId,\r\n        uint256 price,\r\n        uint256 slippage,\r\n        uint256 stableTokenAmount,\r\n        uint256 exchangeRate\r\n    );\r\n\r\n    /**\r\n     * @notice Execute a sell action for a trading strategy.\r\n     * @dev This function performs a sell action based on the specified strategy parameters and market conditions.\r\n     *      It verifies whether the strategy's parameters meet the required conditions for executing a sell.\r\n     * @param strategyId The unique ID of the strategy to execute the sell action for.\r\n     * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n     */\r\n    function executeSell(uint256 strategyId, Swap calldata swap) external {\r\n        // Retrieve the strategy details.\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        if (strategy.status != Status.ACTIVE) {\r\n            revert StrategyIsNotActive();\r\n        }\r\n\r\n        // Ensure that selling is selected in the strategy parameters.\r\n        if (!strategy.parameters._sell) {\r\n            revert SellNotSelected();\r\n        }\r\n\r\n        // Ensure that there is invest token available for selling.\r\n        if (strategy.parameters._investAmount == 0) {\r\n            revert NoSwapFromZeroBalance();\r\n        }\r\n\r\n        // Retrieve the latest price and round ID from Chainlink.\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        uint256 sellAt = strategy.parameters._sellValue;\r\n\r\n        if (strategy.parameters._sellType == SellLegType.INCREASE_BY) {\r\n            uint256 sellPercentage = LibTrade.MAX_PERCENTAGE + strategy.parameters._sellValue;\r\n            sellAt = (strategy.investPrice * sellPercentage) / LibTrade.MAX_PERCENTAGE;\r\n        }\r\n\r\n        updateCurrentPrice(strategyId, price);\r\n        if (sellAt > price) {\r\n            revert PriceLessThanSellValue();\r\n        }\r\n\r\n        if (strategy.parameters._highSellValue != 0) {\r\n            // If a high sell value is specified and \"strategy\" or \"sell TWAP\" is selected, use the high sell value.\r\n            sellAt = strategy.parameters._highSellValue;\r\n            if (price < sellAt) {\r\n                revert PriceLessThanHighSellValue();\r\n            }\r\n        } else if (strategy.parameters._str || strategy.parameters._sellTwap) {\r\n            // If neither high sell value nor \"sell the rally\" nor \"sell TWAP\" is selected, throw an error.\r\n            revert SellDCASelected();\r\n        }\r\n        uint256 value = executionSellAmount(true, strategyId);\r\n\r\n        // Perform the sell action, including transferring assets to the DEX.\r\n        transferSell(strategyId, value, swap, price, investRoundId, stableRoundId, sellAt);\r\n\r\n        // If there are no further buy actions in the strategy, mark it as completed.\r\n        if (!strategy.parameters._buy) {\r\n            strategy.status = Status.COMPLETED;\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @notice Execute a Time-Weighted Average Price (TWAP) sell action for a trading strategy.\r\n   * @dev This function performs a TWAP sell action based on the specified strategy parameters and market conditions.\r\n   *      It verifies whether the strategy's parameters meet the required conditions for executing a TWAP sell.\r\n   * @param strategyId The unique ID of the strategy to execute the TWAP sell action for.\r\n   * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n\r\n   */\r\n    function executeSellTwap(uint256 strategyId, Swap calldata swap) external {\r\n        // Retrieve the strategy details.\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        if (strategy.status != Status.ACTIVE) {\r\n            revert StrategyIsNotActive();\r\n        }\r\n\r\n        // Ensure that TWAP sell is selected in the strategy parameters.\r\n        if (!strategy.parameters._sellTwap) {\r\n            revert SellTwapNotSelected();\r\n        }\r\n\r\n        // Ensure that there is invest token available for selling.\r\n        if (strategy.parameters._investAmount == 0) {\r\n            revert NoSwapFromZeroBalance();\r\n        }\r\n\r\n        // Retrieve the latest price and round ID from Chainlink.\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        updateCurrentPrice(strategyId, price);\r\n        uint256 sellAt = strategy.parameters._sellValue;\r\n        if (strategy.parameters._sellType == SellLegType.INCREASE_BY) {\r\n            uint256 sellPercentage = LibTrade.MAX_PERCENTAGE + strategy.parameters._sellValue;\r\n            sellAt = (strategy.investPrice * sellPercentage) / LibTrade.MAX_PERCENTAGE;\r\n        }\r\n\r\n        if (\r\n            price < sellAt || (strategy.parameters._highSellValue != 0 && price >= strategy.parameters._highSellValue)\r\n        ) {\r\n            revert PriceIsNotInTheRange();\r\n        }\r\n\r\n        // Initialize value for the TWAP sell.\r\n        uint256 value = executionSellAmount(false, strategyId);\r\n\r\n        // Calculate the time interval for TWAP execution and check if it can be executed.\r\n        uint256 timeToExecute = LibTime.convertToSeconds(\r\n            strategy.parameters._sellTwapTime,\r\n            strategy.parameters._sellTwapTimeUnit\r\n        );\r\n        bool execute = LibTime.getTimeDifference(block.timestamp, strategy.sellTwapExecutedAt, timeToExecute);\r\n\r\n        if (!execute) {\r\n            revert TWAPTimeDifferenceIsLess();\r\n        }\r\n\r\n        // Update the TWAP execution timestamp and perform the TWAP sell action.\r\n        strategy.sellTwapExecutedAt = block.timestamp;\r\n        transferSell(strategyId, value, swap, price, investRoundId, stableRoundId, sellAt);\r\n\r\n        // Mark the strategy as completed if there are no further buy actions and no assets left to invest.\r\n        if (!strategy.parameters._buy && strategy.parameters._investAmount == 0) {\r\n            strategy.status = Status.COMPLETED;\r\n        }\r\n    }\r\n\r\n    /**\r\n   * @notice Execute a strategy based on Spike Trigger (STR) conditions for a trading strategy.\r\n   * @dev This function performs actions based on the specified strategy parameters and market conditions to execute Sell The Rally (STR) events.\r\n   *      It verifies whether the strategy's parameters meet the required conditions for executing STR events.\r\n   * @param strategyId The unique ID of the strategy to execute the STR actions for.\r\n   * @param swap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n   * @param fromInvestRoundId The starting invest round ID for price data.\r\n   * @param toInvestRoundId The ending invest round ID for price data.\r\n   * @param fromStableRoundId The starting stable round ID for price data.\r\n   * @param toStableRoundId The ending stable round ID for price data.\r\n   \r\n   */\r\n    function executeSTR(\r\n        uint256 strategyId,\r\n        uint80 fromInvestRoundId,\r\n        uint80 fromStableRoundId,\r\n        uint80 toInvestRoundId,\r\n        uint80 toStableRoundId,\r\n        Swap calldata swap\r\n    ) public {\r\n        // Retrieve the strategy details.\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        if (strategy.status != Status.ACTIVE) {\r\n            revert StrategyIsNotActive();\r\n        }\r\n\r\n        // Ensure that STR events are selected in the strategy parameters.\r\n        if (!strategy.parameters._str) {\r\n            revert STRNotSelected();\r\n        }\r\n\r\n        // Ensure that there is invest token available for selling.\r\n        if (strategy.parameters._investAmount == 0) {\r\n            revert NoSwapFromZeroBalance();\r\n        }\r\n\r\n        // Retrieve the latest price and round ID from Chainlink.\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        uint256 sellAt = strategy.parameters._sellValue;\r\n        if (strategy.parameters._sellType == SellLegType.INCREASE_BY) {\r\n            uint256 sellPercentage = LibTrade.MAX_PERCENTAGE + strategy.parameters._sellValue;\r\n            sellAt = (strategy.investPrice * sellPercentage) / LibTrade.MAX_PERCENTAGE;\r\n        }\r\n\r\n        if (\r\n            price < sellAt || (strategy.parameters._highSellValue != 0 && price >= strategy.parameters._highSellValue)\r\n        ) {\r\n            revert PriceIsNotInTheRange();\r\n        }\r\n\r\n        checkRoundPrices(\r\n            strategyId,\r\n            fromInvestRoundId,\r\n            fromStableRoundId,\r\n            toInvestRoundId,\r\n            toStableRoundId,\r\n            investRoundId,\r\n            stableRoundId\r\n        );\r\n\r\n        uint256 value = executionSellAmount(false, strategyId);\r\n\r\n        transferSell(strategyId, value, swap, price, investRoundId, stableRoundId, sellAt);\r\n\r\n        // Mark the strategy as completed if there are no further buy actions and no assets left to invest.\r\n\r\n        if (!strategy.parameters._buy && strategy.parameters._investAmount == 0) {\r\n            strategy.status = Status.COMPLETED;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the value to be sold in a trading strategy based on provided parameters.\r\n     * @param investValue Boolean indicating whether the value is based on the investment amount.\r\n     * @param strategyId The unique ID of the strategy for which the sell value is calculated.\r\n     * @return The calculated value to be sold, which can be based on fixed or percentage units.\r\n     */\r\n\r\n    function executionSellAmount(bool investValue, uint256 strategyId) public view returns (uint256) {\r\n        uint256 amount;\r\n        Strategy memory strategy = s.strategies[strategyId];\r\n        if (investValue) {\r\n            amount = strategy.parameters._investAmount;\r\n        } else if (strategy.parameters._sellDCAUnit == DCA_UNIT.FIXED) {\r\n            amount = (strategy.parameters._investAmount > strategy.parameters._sellDCAValue)\r\n                ? strategy.parameters._sellDCAValue\r\n                : strategy.parameters._investAmount;\r\n        } else if (strategy.parameters._sellDCAUnit == DCA_UNIT.PERCENTAGE) {\r\n            uint256 sellPercentageAmount = (strategy.parameters._sellDCAValue * strategy.parameters._investAmount) /\r\n                LibTrade.MAX_PERCENTAGE;\r\n\r\n            amount = (strategy.parameters._investAmount > sellPercentageAmount)\r\n                ? sellPercentageAmount\r\n                : strategy.parameters._investAmount;\r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer assets from the trading strategy during a sell action.\r\n     * @dev This function swaps a specified amount of assets on a DEX (Decentralized Exchange) and updates the strategy's state accordingly.\r\n     * @param strategyId The unique ID of the trading strategy where the BTD action is executed.\r\n     * @param value The amount to be sold on the DEX.\r\n     * @param dexSwap The Swap struct containing address of the decentralized exchange (DEX) and calldata containing data for interacting with the DEX during the execution.\r\n     * @param price The current market price of the investment token.\r\n     * @param investRoundId The round ID for invest price data.\r\n     * @param stableRoundId The round ID for stable price data.\r\n     * @param sellValue The value at which the sell action was executed.\r\n     */\r\n    function transferSell(\r\n        uint256 strategyId,\r\n        uint256 value,\r\n        Swap calldata dexSwap,\r\n        uint256 price,\r\n        uint80 investRoundId,\r\n        uint80 stableRoundId,\r\n        uint256 sellValue\r\n    ) internal {\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        // Create a swap data structure for the DEX trade.\r\n        LibSwap.SwapData memory swap = LibSwap.SwapData(\r\n            dexSwap.dex,\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken,\r\n            value,\r\n            dexSwap.callData,\r\n            strategy.user\r\n        );\r\n\r\n        // Perform the asset swap on the DEX and calculate the exchange rate.\r\n        uint256 toTokenAmount = LibSwap.swap(swap);\r\n\r\n        uint256 rate = LibTrade.calculateExchangeRate(strategy.parameters._investToken, value, toTokenAmount);\r\n        // Check if the exchange rate meets the specified sell value.\r\n        if (rate < sellValue) {\r\n            revert InvalidExchangeRate(sellValue, rate);\r\n        }\r\n\r\n        // Validate slippage if the strategy is not an STR (Spike Trigger).\r\n        uint256 slippage = 0;\r\n        if (!strategy.parameters._str) {\r\n            slippage = LibTrade.validateSlippage(rate, price, strategy.parameters._slippage, false);\r\n        }\r\n\r\n        // Calculate the total investment amount and check if it exceeds the budget.\r\n\r\n        uint256 decimals = 10 ** IERC20Metadata(strategy.parameters._investToken).decimals();\r\n\r\n        strategy.parameters._investAmount = strategy.parameters._investAmount - value;\r\n        strategy.parameters._stableAmount = strategy.parameters._stableAmount + toTokenAmount;\r\n\r\n        uint256 totalInvestAmount = (strategy.parameters._investAmount * strategy.investPrice) / decimals;\r\n        uint256 sum = strategy.parameters._stableAmount + totalInvestAmount;\r\n\r\n        if (strategy.budget < sum) {\r\n            strategy.parameters._stableAmount = strategy.budget - totalInvestAmount;\r\n\r\n            strategy.profit = sum - strategy.budget + strategy.profit;\r\n        }\r\n\r\n        // Update the strategy's timestamp, buy percentage amount, and round ID if necessary.\r\n\r\n        strategy.investRoundId = investRoundId;\r\n        strategy.stableRoundId = stableRoundId;\r\n        // Calculate the buy percentage amount if buy actions are based on TWAP or BTD.\r\n\r\n        if (\r\n            (strategy.parameters._sell && !strategy.parameters._str && !strategy.parameters._sellTwap) ||\r\n            (strategy.parameters._sell && strategy.parameters._highSellValue > price)\r\n        ) {\r\n            emit SellExecuted(strategyId, sellValue, slippage, toTokenAmount, rate);\r\n        } else if (strategy.parameters._str) {\r\n            emit STRExecuted(strategyId, price, slippage, toTokenAmount, rate);\r\n        } else if (strategy.parameters._sellTwap) {\r\n            emit SellTwapExecuted(strategyId, price, slippage, toTokenAmount, rate, block.timestamp);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Update the current price of a trading strategy based on the given price.\r\n     * @param strategyId The unique ID of the strategy to update.\r\n     * @param price The new price to set as the current price.\r\n     */\r\n    function updateCurrentPrice(uint256 strategyId, uint256 price) internal {\r\n        Strategy storage strategy = s.strategies[strategyId];\r\n\r\n        // Check the current price source selected in the strategy parameters.\r\n        if (strategy.parameters._current_price == CURRENT_PRICE.SELL_CURRENT) {\r\n            strategy.parameters._sellValue = price;\r\n            strategy.parameters._current_price = CURRENT_PRICE.EXECUTED;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Internal function to check if there is a data mismatch between price rounds for a strategy.\r\n     * @dev This function ensures that the price fluctuations between specified rounds adhere to strategy parameters.\r\n     * @param strategyId The unique ID of the strategy to execute the STR actions for.\r\n     * @param fromInvestRoundId The round ID for the investment token's price data to start checking from.\r\n     * @param fromStableRoundId The round ID for the stable token's price data to start checking from.\r\n     * @param toInvestRoundId The round ID for the investment token's price data to check up to.\r\n     * @param toStableRoundId The round ID for the stable token's price data to check up to.\r\n     * @param presentInvestRound The present round ID for the invest token's price.\r\n     * @param presentStableRound The present round ID for the stable token's price.\r\n     */\r\n    function checkRoundPrices(\r\n        uint256 strategyId,\r\n        uint80 fromInvestRoundId,\r\n        uint80 fromStableRoundId,\r\n        uint80 toInvestRoundId,\r\n        uint80 toStableRoundId,\r\n        uint80 presentInvestRound,\r\n        uint80 presentStableRound\r\n    ) internal view {\r\n        Strategy memory strategy = s.strategies[strategyId];\r\n\r\n        if (presentInvestRound < toInvestRoundId || presentStableRound < toStableRoundId) {\r\n            revert WrongPreviousIDs();\r\n        }\r\n        if (toInvestRoundId < fromInvestRoundId || toStableRoundId < fromStableRoundId) {\r\n            revert WrongPreviousIDs();\r\n        }\r\n\r\n        if (\r\n            strategy.investRoundId >= fromInvestRoundId ||\r\n            strategy.investRoundId >= toInvestRoundId ||\r\n            strategy.stableRoundId >= fromStableRoundId ||\r\n            strategy.stableRoundId >= toStableRoundId\r\n        ) {\r\n            revert WrongPreviousIDs();\r\n        }\r\n\r\n        uint256 fromPrice = LibPrice.getRoundData(\r\n            fromInvestRoundId,\r\n            fromStableRoundId,\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n        uint256 toPrice = LibPrice.getRoundData(\r\n            toInvestRoundId,\r\n            toStableRoundId,\r\n            strategy.parameters._investToken,\r\n            strategy.parameters._stableToken\r\n        );\r\n\r\n        uint256 strValue = strategy.parameters._strValue;\r\n        uint256 fromToPriceDifference;\r\n        uint256 toFromPriceDifference;\r\n\r\n        if (\r\n            (strategy.parameters._strType == DIP_SPIKE.FIXED_INCREASE ||\r\n                strategy.parameters._strType == DIP_SPIKE.INCREASE_BY)\r\n        ) {\r\n            if (toPrice < fromPrice) {\r\n                revert RoundDataDoesNotMatch();\r\n            } else {\r\n                toFromPriceDifference = toPrice - fromPrice;\r\n            }\r\n        }\r\n        if (\r\n            (strategy.parameters._strType == DIP_SPIKE.FIXED_DECREASE ||\r\n                strategy.parameters._strType == DIP_SPIKE.DECREASE_BY)\r\n        ) {\r\n            if (toPrice > fromPrice) {\r\n                revert RoundDataDoesNotMatch();\r\n            } else {\r\n                fromToPriceDifference = fromPrice - toPrice;\r\n            }\r\n        }\r\n\r\n        if ((strategy.parameters._strType == DIP_SPIKE.FIXED_INCREASE) && (strValue > toFromPriceDifference)) {\r\n            revert RoundDataDoesNotMatch();\r\n        } else if ((strategy.parameters._strType == DIP_SPIKE.FIXED_DECREASE) && (strValue > fromToPriceDifference)) {\r\n            revert RoundDataDoesNotMatch();\r\n        } else if (\r\n            (strategy.parameters._strType == DIP_SPIKE.INCREASE_BY) &&\r\n            (strValue > ((toFromPriceDifference * 10000) / fromPrice))\r\n        ) {\r\n            revert RoundDataDoesNotMatch();\r\n        } else if (\r\n            (strategy.parameters._strType == DIP_SPIKE.DECREASE_BY) &&\r\n            (strValue > ((fromToPriceDifference * 10000) / fromPrice))\r\n        ) {\r\n            revert RoundDataDoesNotMatch();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/facets/StrategyFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { AppStorage, Strategy, StrategyParameters, SellLegType, BuyLegType, FloorLegType, DCA_UNIT, DIP_SPIKE, TimeUnit, Status, CURRENT_PRICE } from \"../AppStorage.sol\";\r\nimport { Modifiers } from \"../utils/Modifiers.sol\";\r\nimport { InvalidSlippage, InvalidInvestToken, InvalidStableToken, TokensMustDiffer, AtLeastOneOptionRequired, InvalidBuyValue, InvalidBuyType, InvalidFloorValue, InvalidFloorType, InvalidSellType, InvalidSellValue, InvalidStableAmount, BuyAndSellAtMisorder, InvalidInvestAmount, FloorValueGreaterThanBuyValue, FloorValueGreaterThanSellValue, SellPercentageWithDCA, FloorPercentageWithDCA, BothBuyTwapAndBTD, BuyDCAWithoutBuy, BuyTwapTimeInvalid, BuyTwapTimeUnitNotSelected, BothSellTwapAndSTR, SellDCAWithoutSell, SellTwapTimeUnitNotSelected, SellTwapTimeInvalid, SellTwapOrStrWithoutSellDCAUnit, SellDCAUnitWithoutSellDCAValue, StrWithoutStrValueOrType, BTDWithoutBTDType, BTDTypeWithoutBTDValue, BuyDCAWithoutBuyDCAUnit, BuyDCAUnitWithoutBuyDCAValue, InvalidHighSellValue, SellDCAValueRangeIsNotValid, BuyDCAValueRangeIsNotValid, DCAValueShouldBeLessThanIntitialAmount, OrphandStrategy, BuyNeverExecute } from \"../utils/GenericErrors.sol\";\r\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\r\nimport { LibTrade } from \"../libraries/LibTrade.sol\";\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\nerror BothStableAndInvestAmountProvided();\r\nerror OnlyOwnerCanCancelStrategies();\r\nerror NoAmountProvided();\r\nerror HighSellValueIsChosenWithoutSeLLDCA();\r\n\r\n/**\r\n * @title StrategyFacet\r\n * @notice This contract handles the creation, retrieval, and cancellation of strategies.\r\n * Strategies define specific trade execution conditions and actions.\r\n * @dev StrategyFacet is one of the facets of the system, dedicated to strategy management.\r\n */\r\ncontract StrategyFacet is Modifiers {\r\n    /**\r\n     * @notice The `AppStorage` state variable serves as the central data repository for this contract. Please\r\n     * please look at AppStorage.sol for more detail\r\n     */\r\n    AppStorage internal s;\r\n\r\n    /**\r\n     * @notice Emitted when a new trading strategy is created.\r\n     * @param investToken The address of the invest token used in the strategy.\r\n     * @param stableToken The address of the stable token used in the strategy.\r\n     * @param parameter The strategy parameter including settings for buying and selling.\r\n     * @param timestamp Timestamp when the strategy is created.\r\n     * @param investRoundId Round ID for the invest token price when the strategy is created.\r\n     * @param stableRoundId Round ID for the stable token price when the strategy is created.\r\n     * @param price The price of the invest token at the time of strategy creation.\r\n     */\r\n\r\n    event StrategyCreated(\r\n        address indexed investToken,\r\n        address indexed stableToken,\r\n        StrategyParameters parameter,\r\n        uint256 timestamp,\r\n        uint256 investRoundId,\r\n        uint256 stableRoundId,\r\n        uint256 price\r\n    );\r\n\r\n    /**\r\n     * @notice Emitted when a trade execution strategy is cancelled.\r\n     * @param strategyId The unique ID of the cancelled strategy.\r\n     */\r\n    event StrategyCancelled(uint256 indexed strategyId);\r\n\r\n    /**\r\n     * @notice Create a new trade execution strategy based on the provided parameters.\r\n     * @dev This function validates the input parameters to ensure they satisfy the criteria for creating a strategy.\r\n     *      If the parameters are valid, a new strategy is created and an event is emitted to indicate the successful creation.\r\n     *      If the parameters do not meet the criteria, an error is thrown.\r\n     * @param _parameter The strategy parameters defining the behavior and conditions of the strategy.\r\n     */\r\n    function createStrategy(StrategyParameters memory _parameter) external {\r\n        if (_parameter._investToken == address(0)) {\r\n            revert InvalidInvestToken();\r\n        }\r\n\r\n        if (_parameter._stableToken == address(0)) {\r\n            revert InvalidStableToken();\r\n        }\r\n\r\n        if (_parameter._investToken == _parameter._stableToken) {\r\n            revert TokensMustDiffer();\r\n        }\r\n\r\n        if (!(_parameter._floor || _parameter._sell || _parameter._buy)) {\r\n            revert AtLeastOneOptionRequired();\r\n        }\r\n\r\n        if (_parameter._sellType == SellLegType.INCREASE_BY && (_parameter._str || _parameter._sellTwap)) {\r\n            revert SellPercentageWithDCA();\r\n        }\r\n\r\n        if (_parameter._floorType == FloorLegType.DECREASE_BY && (_parameter._buyTwap || _parameter._btd)) {\r\n            revert FloorPercentageWithDCA();\r\n        }\r\n\r\n        if (_parameter._buy && _parameter._buyTwap && _parameter._btd) {\r\n            revert BothBuyTwapAndBTD();\r\n        }\r\n\r\n        if ((_parameter._buyTwap || _parameter._btd) && !_parameter._buy) {\r\n            revert BuyDCAWithoutBuy();\r\n        }\r\n\r\n        if (_parameter._buyTwap && _parameter._buyTwapTime <= 0) {\r\n            revert BuyTwapTimeInvalid();\r\n        }\r\n        if (_parameter._buyTwap && _parameter._buyTwapTimeUnit == TimeUnit.NO_UNIT) {\r\n            revert BuyTwapTimeUnitNotSelected();\r\n        }\r\n\r\n        if (_parameter._sellTwap && _parameter._str) {\r\n            revert BothSellTwapAndSTR();\r\n        }\r\n\r\n        if ((_parameter._sellTwap || _parameter._str) && !_parameter._sell) {\r\n            revert SellDCAWithoutSell();\r\n        }\r\n        if (_parameter._sellTwap && _parameter._sellTwapTimeUnit == TimeUnit.NO_UNIT) {\r\n            revert SellTwapTimeUnitNotSelected();\r\n        }\r\n\r\n        if (_parameter._sellTwap && _parameter._sellTwapTime <= 0) {\r\n            revert SellTwapTimeInvalid();\r\n        }\r\n\r\n        if ((_parameter._sellTwap || _parameter._str) && _parameter._sellDCAUnit == DCA_UNIT.NO_UNIT) {\r\n            revert SellTwapOrStrWithoutSellDCAUnit();\r\n        }\r\n\r\n        if (_parameter._sellDCAUnit != DCA_UNIT.NO_UNIT && _parameter._sellDCAValue == 0) {\r\n            revert SellDCAUnitWithoutSellDCAValue();\r\n        }\r\n\r\n        if (_parameter._str && (_parameter._strValue == 0 || _parameter._strType == DIP_SPIKE.NO_SPIKE)) {\r\n            revert StrWithoutStrValueOrType();\r\n        }\r\n\r\n        if (_parameter._btd && _parameter._btdType == DIP_SPIKE.NO_SPIKE) {\r\n            revert BTDWithoutBTDType();\r\n        }\r\n\r\n        if (_parameter._btdType != DIP_SPIKE.NO_SPIKE && _parameter._btdValue == 0) {\r\n            revert BTDTypeWithoutBTDValue();\r\n        }\r\n\r\n        if ((_parameter._btd || _parameter._buyTwap) && _parameter._buyDCAUnit == DCA_UNIT.NO_UNIT) {\r\n            revert BuyDCAWithoutBuyDCAUnit();\r\n        }\r\n\r\n        if (_parameter._buyDCAUnit != DCA_UNIT.NO_UNIT && _parameter._buyDCAValue == 0) {\r\n            revert BuyDCAUnitWithoutBuyDCAValue();\r\n        }\r\n\r\n        (uint256 price, uint80 investRoundId, uint80 stableRoundId) = LibPrice.getPrice(\r\n            _parameter._investToken,\r\n            _parameter._stableToken\r\n        );\r\n\r\n        uint256 buyValue = _parameter._buyValue;\r\n        if (_parameter._current_price == CURRENT_PRICE.BUY_CURRENT) {\r\n            buyValue = price;\r\n            _parameter._buyType = BuyLegType.LIMIT_PRICE;\r\n            if (_parameter._btd) {\r\n                _parameter._buyValue = price;\r\n                _parameter._current_price = CURRENT_PRICE.EXECUTED;\r\n            }\r\n        }\r\n        uint256 sellValue = _parameter._sellValue;\r\n        if (_parameter._current_price == CURRENT_PRICE.SELL_CURRENT) {\r\n            sellValue = price;\r\n            _parameter._sellType = SellLegType.LIMIT_PRICE;\r\n            if (_parameter._str) {\r\n                _parameter._sellValue = price;\r\n                _parameter._current_price = CURRENT_PRICE.EXECUTED;\r\n            }\r\n        }\r\n\r\n        if (_parameter._buy) {\r\n            if (buyValue == 0) {\r\n                revert InvalidBuyValue();\r\n            }\r\n            if (_parameter._buyType == BuyLegType.NO_TYPE) {\r\n                revert InvalidBuyType();\r\n            }\r\n        }\r\n\r\n        // Check if floor is chosen\r\n        if (_parameter._floor) {\r\n            if (_parameter._floorValue == 0) {\r\n                revert InvalidFloorValue();\r\n            }\r\n            if (_parameter._floorType == FloorLegType.NO_TYPE) {\r\n                revert InvalidFloorType();\r\n            }\r\n        }\r\n\r\n        if (_parameter._highSellValue != 0) {\r\n            if (!(_parameter._str || _parameter._sellTwap)) {\r\n                revert HighSellValueIsChosenWithoutSeLLDCA();\r\n            }\r\n        }\r\n\r\n        if (_parameter._sell || _parameter._str || _parameter._sellTwap) {\r\n            if (_parameter._sellType == SellLegType.NO_TYPE) {\r\n                revert InvalidSellType();\r\n            }\r\n            if (sellValue == 0) {\r\n                revert InvalidSellValue();\r\n            }\r\n            if (_parameter._highSellValue != 0 && sellValue > _parameter._highSellValue) {\r\n                revert InvalidHighSellValue();\r\n            }\r\n        }\r\n\r\n        // Check if both buy and sell are chosen\r\n        if (_parameter._buy && _parameter._sell) {\r\n            if (!(_parameter._stableAmount > 0 || _parameter._investAmount > 0)) {\r\n                revert NoAmountProvided();\r\n            }\r\n            if (buyValue >= sellValue && _parameter._sellType == SellLegType.LIMIT_PRICE) {\r\n                revert BuyAndSellAtMisorder();\r\n            }\r\n        }\r\n        // Check if only buy is chosen\r\n        if (_parameter._buy && !_parameter._sell && !_parameter._floor) {\r\n            if (!(_parameter._stableAmount > 0)) {\r\n                revert InvalidStableAmount();\r\n            }\r\n        }\r\n\r\n        if (_parameter._buy && !_parameter._sell && !_parameter._floor) {\r\n            if (_parameter._investAmount > 0) {\r\n                revert OrphandStrategy();\r\n            }\r\n        }\r\n        if (!_parameter._buy && _parameter._sell && _parameter._floor) {\r\n            if (_parameter._stableAmount > 0) {\r\n                revert OrphandStrategy();\r\n            }\r\n        }\r\n\r\n        // Check if only sell is chosen\r\n        if (\r\n            (_parameter._sell || _parameter._floor) &&\r\n            _parameter._investAmount > 0 &&\r\n            (_parameter._completeOnSell || _parameter._cancelOnFloor) &&\r\n            _parameter._buy\r\n        ) {\r\n            revert BuyNeverExecute();\r\n        }\r\n\r\n        // Check if floor and sell are chosen\r\n        if (\r\n            _parameter._floor &&\r\n            _parameter._sell &&\r\n            _parameter._sellType == SellLegType.LIMIT_PRICE &&\r\n            _parameter._floorType == FloorLegType.LIMIT_PRICE\r\n        ) {\r\n            if (_parameter._floorValue >= sellValue) {\r\n                revert FloorValueGreaterThanSellValue();\r\n            }\r\n        }\r\n\r\n        // Check if floor and buy are chosen\r\n        if (_parameter._floor && _parameter._buy && _parameter._floorType == FloorLegType.LIMIT_PRICE) {\r\n            if (_parameter._floorValue >= buyValue) {\r\n                revert FloorValueGreaterThanBuyValue();\r\n            }\r\n        }\r\n\r\n        if (_parameter._slippage > LibTrade.MAX_PERCENTAGE) {\r\n            revert InvalidSlippage();\r\n        }\r\n\r\n        if ((_parameter._sellTwap || _parameter._str) && _parameter._sellDCAUnit == DCA_UNIT.PERCENTAGE) {\r\n            if (_parameter._sellDCAValue < 0 || _parameter._sellDCAValue > LibTrade.MAX_PERCENTAGE) {\r\n                revert SellDCAValueRangeIsNotValid();\r\n            }\r\n        }\r\n\r\n        if (\r\n            ((_parameter._sellTwap || _parameter._str) && _parameter._sellDCAUnit == DCA_UNIT.FIXED) &&\r\n            _parameter._investAmount > 0 &&\r\n            (_parameter._sellDCAValue > _parameter._investAmount)\r\n        ) {\r\n            revert DCAValueShouldBeLessThanIntitialAmount();\r\n        }\r\n\r\n        if (\r\n            (_parameter._buyTwap || _parameter._btd) &&\r\n            (_parameter._buyDCAUnit == DCA_UNIT.FIXED) &&\r\n            _parameter._stableAmount > 0 &&\r\n            (_parameter._buyDCAValue > _parameter._stableAmount)\r\n        ) {\r\n            revert DCAValueShouldBeLessThanIntitialAmount();\r\n        }\r\n\r\n        if ((_parameter._buyTwap || _parameter._btd) && _parameter._buyDCAUnit == DCA_UNIT.PERCENTAGE) {\r\n            if (_parameter._buyDCAValue < 0 || _parameter._buyDCAValue > LibTrade.MAX_PERCENTAGE) {\r\n                revert BuyDCAValueRangeIsNotValid();\r\n            }\r\n        }\r\n\r\n        uint256 decimals = 10 ** IERC20Metadata(_parameter._investToken).decimals();\r\n\r\n        if (_parameter._investAmount > 0 && _parameter._stableAmount > 0) {\r\n            revert BothStableAndInvestAmountProvided();\r\n        }\r\n        uint256 budget = 0;\r\n\r\n        if (_parameter._investAmount > 0) {\r\n            budget = ((_parameter._investAmount * price) / decimals);\r\n        }\r\n\r\n        if (_parameter._stableAmount > 0) {\r\n            budget = _parameter._stableAmount;\r\n        }\r\n        uint256 investPrice = 0;\r\n        if (_parameter._investAmount > 0) {\r\n            investPrice = price;\r\n        }\r\n        s.strategies[s.nextStrategyId] = Strategy({\r\n            user: msg.sender,\r\n            sellTwapExecutedAt: 0,\r\n            buyTwapExecutedAt: 0,\r\n            investRoundId: investRoundId,\r\n            stableRoundId: stableRoundId,\r\n            parameters: _parameter,\r\n            investPrice: investPrice,\r\n            profit: 0,\r\n            budget: budget,\r\n            status: Status.ACTIVE\r\n        });\r\n\r\n        s.nextStrategyId++;\r\n\r\n        emit StrategyCreated(\r\n            _parameter._investToken,\r\n            _parameter._stableToken,\r\n            _parameter,\r\n            block.timestamp,\r\n            investRoundId,\r\n            stableRoundId,\r\n            price\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel a trade execution strategy.\r\n     * @dev This function allows users to cancel a trade execution strategy based on its unique ID.\r\n     *      When cancelled, the strategy's status is updated to \"CANCELLED.\"\r\n     * @param id The unique ID of the strategy to cancel.\r\n     */\r\n    function cancelStrategy(uint256 id) external {\r\n        Strategy storage strategy = s.strategies[id];\r\n        if (msg.sender != strategy.user) {\r\n            revert OnlyOwnerCanCancelStrategies();\r\n        }\r\n        strategy.status = Status.CANCELLED;\r\n        emit StrategyCancelled(id);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the next available strategy ID.\r\n     * @dev This function returns the unique ID that will be assigned to the next created strategy.\r\n     * @return The next available strategy ID.\r\n     */\r\n    function nextStartegyId() external view returns (uint256) {\r\n        return s.nextStrategyId;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieve the details of a trade execution strategy.\r\n     * @dev This function allows users to query and retrieve information about a trade execution strategy\r\n     *      based on its unique ID.\r\n     * @param id The unique ID of the strategy to retrieve.\r\n     * @return A `Strategy` struct containing details of the specified strategy.\r\n     */\r\n    function getStrategy(uint256 id) external view returns (Strategy memory) {\r\n        return s.strategies[id];\r\n    }\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ninterface IDiamondCut {\r\n    enum FacetCutAction {\r\n        Add,\r\n        Replace,\r\n        Remove\r\n    }\r\n    // Add=0, Replace=1, Remove=2\r\n\r\n    struct FacetCut {\r\n        address facetAddress;\r\n        FacetCutAction action;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Add/replace/remove any number of functions and optionally execute\r\n    ///         a function with delegatecall\r\n    /// @param _diamondCut Contains the facet addresses and function selectors\r\n    /// @param _init The address of the contract or facet to execute _calldata\r\n    /// @param _calldata A function call, including function selector and arguments\r\n    ///                  _calldata is executed with delegatecall on _init\r\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\r\n\r\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n}\r\n"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n// A loupe is a small magnifying glass used to look at diamonds.\r\n// These functions look at diamonds\r\ninterface IDiamondLoupe {\r\n    /// These functions are expected to be called frequently\r\n    /// by tools.\r\n\r\n    struct Facet {\r\n        address facetAddress;\r\n        bytes4[] functionSelectors;\r\n    }\r\n\r\n    /// @notice Gets all facet addresses and their four byte function selectors.\r\n    /// @return facets_ Facet\r\n    function facets() external view returns (Facet[] memory facets_);\r\n\r\n    /// @notice Gets all the function selectors supported by a specific facet.\r\n    /// @param _facet The facet address.\r\n    /// @return facetFunctionSelectors_\r\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\r\n\r\n    /// @notice Get all the facet addresses used by a diamond.\r\n    /// @return facetAddresses_\r\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\r\n\r\n    /// @notice Gets the facet that supports the given selector.\r\n    /// @dev If facet is not found return address(0).\r\n    /// @param _functionSelector The function selector.\r\n    /// @return facetAddress_ The facet address.\r\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\r\n}\r\n"
    },
    "contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IERC165 {\n    /// @notice Query if a contract implements an interface\n    /// @param interfaceId The interface identifier, as specified in ERC-165\n    /// @dev Interface identification is specified in ERC-165. This function\n    ///  uses less than 30,000 gas.\n    /// @return `true` if the contract implements `interfaceID` and\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\n/// @title ERC-173 Contract Ownership Standard\r\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\r\n/* is ERC165 */\r\ninterface IERC173 {\r\n    /// @dev This emits when ownership of a contract changes.\r\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /// @notice Get the address of the owner\r\n    /// @return owner_ The address of the owner.\r\n    function owner() external view returns (address owner_);\r\n\r\n    /// @notice Set the address of the new owner of the contract\r\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\r\n    /// @param _newOwner The address of the new owner of the contract\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n"
    },
    "contracts/libraries/LibAsset.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { SafeERC20 } from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport { TransferFailed } from \"../utils/GenericErrors.sol\";\r\n\r\n/**\r\n * @title LibAsset\r\n * @dev This library provides functions for interacting with ERC20 assets.\r\n */\r\nlibrary LibAsset {\r\n    uint256 private constant MAX_UINT = type(uint256).max;\r\n\r\n    /**\r\n     * @notice Approves a specified amount of an asset for a spender if the current allowance is insufficient.\r\n     * @param asset The address of the asset.\r\n     * @param spender The address of the spender.\r\n     * @param amount The amount to approve.\r\n     */\r\n    function maxApprove(address asset, address spender, uint256 amount) internal {\r\n        if (IERC20(asset).allowance(address(this), spender) < amount) {\r\n            SafeERC20.safeApprove(IERC20(asset), spender, 0);\r\n            SafeERC20.safeApprove(IERC20(asset), spender, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers a specified amount of an asset from one address to another.\r\n     * @param asset The address of the asset.\r\n     * @param from The sender's address.\r\n     * @param to The recipient's address.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function transferFrom(address asset, address from, address to, uint256 amount) internal {\r\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\r\n        SafeERC20.safeTransferFrom(IERC20(asset), from, to, amount);\r\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\r\n            revert TransferFailed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers a specified amount of an asset to a recipient.\r\n     * @param asset The address of the asset.\r\n     * @param to The recipient's address.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function transfer(address asset, address to, uint256 amount) internal {\r\n        uint256 prevBalance = IERC20(asset).balanceOf(to);\r\n        SafeERC20.safeTransfer(IERC20(asset), to, amount);\r\n        if (IERC20(asset).balanceOf(to) - prevBalance != amount) {\r\n            revert TransferFailed();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the balance of a specified asset for a given account.\r\n     * @param asset The address of the asset.\r\n     * @param account The account for which to check the balance.\r\n     * @return The balance of the asset for the specified account.\r\n     */\r\n    function balanceOf(address asset, address account) internal view returns (uint256) {\r\n        return IERC20(asset).balanceOf(account);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibBytes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nlibrary LibBytes {\r\n    // solhint-disable no-inline-assembly\r\n\r\n    // LibBytes specific errors\r\n    error SliceOverflow();\r\n    error SliceOutOfBounds();\r\n    error AddressOutOfBounds();\r\n\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n\r\n    // -------------------------\r\n    /**\r\n     * @notice Slice a portion of a bytes array.\r\n     * @param _bytes The input bytes array.\r\n     * @param _start The starting index of the slice.\r\n     * @param _length The length of the slice.\r\n     * @return tempBytes A new bytes array containing the sliced data.\r\n     */\r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\r\n        if (_length + 31 < _length) revert SliceOverflow();\r\n        if (_bytes.length < _start + _length) revert SliceOutOfBounds();\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    /**\r\n     * @notice Convert a portion of a bytes array to an address.\r\n     * @param _bytes The input bytes array.\r\n     * @param _start The starting index of the address data.\r\n     * @return tempAddress The address extracted from the bytes array.\r\n     */\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        if (_bytes.length < _start + 20) {\r\n            revert AddressOutOfBounds();\r\n        }\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    /// Copied from OpenZeppelin's `Strings.sol` utility library.\r\n    /// https://github.com/OpenZeppelin/openzeppelin-contracts/blob/8335676b0e99944eef6a742e16dcd9ff6e68e609/contracts/utils/Strings.sol\r\n    /**\r\n     * @notice Convert a uint256 to its hexadecimal representation as a string.\r\n     * @param value The uint256 value to convert.\r\n     * @param length The desired length of the hexadecimal string.\r\n     * @return A string containing the hexadecimal representation of the uint256 value.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\nimport { AppStorage } from \"../AppStorage.sol\";\r\n\r\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\r\n// The loupe functions are required by the EIP2535 Diamonds standard\r\n\r\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\r\n\r\nlibrary LibDiamond {\r\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\r\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\r\n\r\n    function diamondStorage() internal pure returns (AppStorage storage s) {\r\n        assembly {\r\n            s.slot := 0\r\n        }\r\n    }\r\n\r\n    function setContractOwner(address _newOwner) internal {\r\n        AppStorage storage s = diamondStorage();\r\n        address previousOwner = s.owner;\r\n        s.owner = _newOwner;\r\n        emit OwnershipTransferred(previousOwner, _newOwner);\r\n    }\r\n\r\n    // Internal function version of diamondCut\r\n    // This code is almost the same as the external diamondCut,\r\n    // except it is using 'Facet[] memory _diamondCut' instead of\r\n    // 'Facet[] calldata _diamondCut'.\r\n    // The code is duplicated to prevent copying calldata to memory which\r\n    // causes an error for a two dimensional array.\r\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\r\n        AppStorage storage s = diamondStorage();\r\n        uint256 originalSelectorCount = s.selectorCount;\r\n        uint256 selectorCount = originalSelectorCount;\r\n        bytes32 selectorSlot;\r\n        // Check if last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\r\n        if (selectorCount & 7 > 0) {\r\n            // get last selectorSlot\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\r\n        }\r\n        // loop through diamond cut\r\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\r\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\r\n                selectorCount,\r\n                selectorSlot,\r\n                _diamondCut[facetIndex].facetAddress,\r\n                _diamondCut[facetIndex].action,\r\n                _diamondCut[facetIndex].functionSelectors\r\n            );\r\n\r\n            unchecked {\r\n                facetIndex++;\r\n            }\r\n        }\r\n        if (selectorCount != originalSelectorCount) {\r\n            s.selectorCount = uint16(selectorCount);\r\n        }\r\n        // If last selector slot is not full\r\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\r\n        if (selectorCount & 7 > 0) {\r\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\r\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\r\n        }\r\n        emit DiamondCut(_diamondCut, _init, _calldata);\r\n        initializeDiamondCut(_init, _calldata);\r\n    }\r\n\r\n    function addReplaceRemoveFacetSelectors(\r\n        uint256 _selectorCount,\r\n        bytes32 _selectorSlot,\r\n        address _newFacetAddress,\r\n        IDiamondCut.FacetCutAction _action,\r\n        bytes4[] memory _selectors\r\n    ) internal returns (uint256, bytes32) {\r\n        AppStorage storage s = diamondStorage();\r\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\r\n        if (_action == IDiamondCut.FacetCutAction.Add) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = s.facets[selector];\r\n                require(\r\n                    address(bytes20(oldFacet)) == address(0),\r\n                    \"LibDiamondCut: Can't add function that already exists\"\r\n                );\r\n                // add facet for selector\r\n                s.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\r\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\r\n                // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\r\n                // clear selector position in slot and add selector\r\n                _selectorSlot =\r\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\r\n                    (bytes32(selector) >> selectorInSlotPosition);\r\n                // if slot is full then write it to storage\r\n                if (selectorInSlotPosition == 224) {\r\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\r\n                    s.selectorSlots[_selectorCount >> 3] = _selectorSlot;\r\n                    _selectorSlot = 0;\r\n                }\r\n                _selectorCount++;\r\n\r\n                unchecked {\r\n                    selectorIndex++;\r\n                }\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\r\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\r\n                bytes4 selector = _selectors[selectorIndex];\r\n                bytes32 oldFacet = s.facets[selector];\r\n                address oldFacetAddress = address(bytes20(oldFacet));\r\n                // only useful if immutable functions exist\r\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\r\n                require(\r\n                    oldFacetAddress != _newFacetAddress,\r\n                    \"LibDiamondCut: Can't replace function with same function\"\r\n                );\r\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\r\n                // replace old facet address\r\n                s.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\r\n\r\n                unchecked {\r\n                    selectorIndex++;\r\n                }\r\n            }\r\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\r\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\r\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\r\n            uint256 selectorSlotCount = _selectorCount >> 3;\r\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\r\n            uint256 selectorInSlotIndex = _selectorCount & 7;\r\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\r\n                if (_selectorSlot == 0) {\r\n                    // get last selectorSlot\r\n                    selectorSlotCount--;\r\n                    _selectorSlot = s.selectorSlots[selectorSlotCount];\r\n                    selectorInSlotIndex = 7;\r\n                } else {\r\n                    selectorInSlotIndex--;\r\n                }\r\n                bytes4 lastSelector;\r\n                uint256 oldSelectorsSlotCount;\r\n                uint256 oldSelectorInSlotPosition;\r\n                // adding a block here prevents stack too deep error\r\n                {\r\n                    bytes4 selector = _selectors[selectorIndex];\r\n                    bytes32 oldFacet = s.facets[selector];\r\n                    require(\r\n                        address(bytes20(oldFacet)) != address(0),\r\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\r\n                    );\r\n                    // only useful if immutable functions exist\r\n                    require(\r\n                        address(bytes20(oldFacet)) != address(this),\r\n                        \"LibDiamondCut: Can't remove immutable function\"\r\n                    );\r\n                    // replace selector with last selector in s.facets\r\n                    // gets the last selector\r\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\r\n                    if (lastSelector != selector) {\r\n                        // update last selector slot position info\r\n                        s.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.facets[lastSelector]);\r\n                    }\r\n                    delete s.facets[selector];\r\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\r\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\r\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\r\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\r\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\r\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\r\n                }\r\n                if (oldSelectorsSlotCount != selectorSlotCount) {\r\n                    bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    oldSelectorSlot =\r\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                    // update storage with the modified slot\r\n                    s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\r\n                } else {\r\n                    // clears the selector we are deleting and puts the last selector in its place.\r\n                    _selectorSlot =\r\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\r\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\r\n                }\r\n                if (selectorInSlotIndex == 0) {\r\n                    delete s.selectorSlots[selectorSlotCount];\r\n                    _selectorSlot = 0;\r\n                }\r\n\r\n                unchecked {\r\n                    selectorIndex++;\r\n                }\r\n            }\r\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\r\n        } else {\r\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\r\n        }\r\n        return (_selectorCount, _selectorSlot);\r\n    }\r\n\r\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\r\n        if (_init == address(0)) {\r\n            return;\r\n        }\r\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\r\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\r\n        if (!success) {\r\n            if (error.length > 0) {\r\n                // bubble up error\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    let returndata_size := mload(error)\r\n                    revert(add(32, error), returndata_size)\r\n                }\r\n            } else {\r\n                revert InitializationFunctionReverted(_init, _calldata);\r\n            }\r\n        }\r\n    }\r\n\r\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\r\n        uint256 contractSize;\r\n        assembly {\r\n            contractSize := extcodesize(_contract)\r\n        }\r\n        require(contractSize > 0, _errorMessage);\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@chainlink/contracts/src/v0.8/Denominations.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\r\n\r\nimport { LibDiamond } from \"./LibDiamond.sol\";\r\nimport { InvalidPrice, FeedNotFound } from \"../utils/GenericErrors.sol\";\r\nimport { AppStorage } from \"../AppStorage.sol\";\r\n\r\n/**\r\n * @title LibPrice\r\n * @dev This library provides functions for fetching and manipulating asset prices.\r\n */\r\nlibrary LibPrice {\r\n    address constant USD_QUOTE = 0x0000000000000000000000000000000000000348;\r\n\r\n    /**\r\n     * @notice Get the current price and round IDs of an asset relative to a unit.\r\n     * @param asset The address of the asset.\r\n     * @param unit The address of the unit (e.g., USD).\r\n     * @return price The current price of the asset in terms of the unit.\r\n     * @return investRoundId The round ID of the asset's price feed.\r\n     * @return stableRoundId The round ID of the unit's price feed.\r\n     */\r\n    function getPrice(address asset, address unit) internal view returns (uint256 price, uint80, uint80) {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n\r\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\r\n            revert FeedNotFound();\r\n        }\r\n\r\n        (uint80 investRoundId, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\r\n        (uint80 stableRoundId, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).latestRoundData();\r\n\r\n        if (assetPrice == 0 || unitPrice == 0) {\r\n            revert InvalidPrice();\r\n        }\r\n\r\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\r\n        price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\r\n\r\n        return (price, investRoundId, stableRoundId);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\r\n     * @param investRoundId The round ID of the asset's price feed.\r\n     * @param stableRoundId The round ID of the unit's price feed.\r\n     * @param asset The address of the asset.\r\n     * @param unit The address of the unit (e.g., USD).\r\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\r\n     */\r\n    function getRoundData(\r\n        uint80 investRoundId,\r\n        uint80 stableRoundId,\r\n        address asset,\r\n        address unit\r\n    ) internal view returns (uint256) {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n\r\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\r\n            revert FeedNotFound();\r\n        }\r\n\r\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(investRoundId);\r\n        (, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).getRoundData(stableRoundId);\r\n\r\n        if (assetPrice == 0 || unitPrice == 0) {\r\n            revert InvalidPrice();\r\n        }\r\n\r\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\r\n        uint256 price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\r\n\r\n        return price;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibSwap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { LibAsset } from \"./LibAsset.sol\";\r\nimport { LibUtil } from \"./LibUtil.sol\";\r\nimport { NoSwapFromZeroBalance, InsufficientBalance, SwapFailed } from \"../utils/GenericErrors.sol\";\r\nimport { IERC20 } from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/**\r\n * @title LibSwap\r\n * @dev This library provides functions for executing asset swaps.\r\n */\r\nlibrary LibSwap {\r\n    struct SwapData {\r\n        address callTo; // The address of the contract or dex to execute the swap on.\r\n        address fromAsset; // The address of the asset to swap from.\r\n        address toAsset; // The address of the asset to receive.\r\n        uint256 fromAmount; // The amount of the 'fromAsset' to swap.\r\n        bytes callData; // The call data for the swap.\r\n        address user; // The user initiating the swap.\r\n    }\r\n\r\n    /**\r\n     * @notice Emitted when an asset swap has been executed successfully.\r\n     * @param dex The address of the contract or dex used for the swap.\r\n     * @param fromAsset The address of the asset swapped from.\r\n     * @param toAsset The address of the asset received in the swap.\r\n     * @param fromAmount The amount of 'fromAsset' that was swapped.\r\n     * @param receivedAmount The amount of 'toAsset' received in the swap.\r\n     * @param account The address of the user account that initiated the swap.\r\n     */\r\n\r\n    event AssetSwapped(\r\n        address dex,\r\n        address fromAsset,\r\n        address toAsset,\r\n        uint256 fromAmount,\r\n        uint256 receivedAmount,\r\n        address account\r\n    );\r\n\r\n    /**\r\n     * @notice Execute an asset swap from one asset to another using the provided swap data.\r\n     * @param _swap The swap data containing all necessary information for the swap.\r\n     * @return The amount of 'toAsset' received in the swap.\r\n     * @dev This function transfers 'fromAsset' from the user to this contract, executes the swap,\r\n     * and transfers the received 'toAsset' back to the user.\r\n     */\r\n    function swap(SwapData memory _swap) internal returns (uint256) {\r\n        uint256 fromAmount = _swap.fromAmount;\r\n        if (fromAmount == 0) revert NoSwapFromZeroBalance();\r\n\r\n        LibAsset.transferFrom(_swap.fromAsset, _swap.user, address(this), fromAmount);\r\n\r\n        uint256 initialReceivingAssetBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\r\n\r\n        LibAsset.maxApprove(_swap.fromAsset, _swap.callTo, _swap.fromAmount);\r\n\r\n        // solhint-disable-next-line avoid-low-level-calls\r\n        (bool success, bytes memory res) = _swap.callTo.call(_swap.callData);\r\n        if (!success) {\r\n            string memory reason = LibUtil.getRevertMsg(res);\r\n            revert(reason);\r\n        }\r\n\r\n        uint256 newBalance = LibAsset.balanceOf(_swap.toAsset, address(this));\r\n        uint256 receivedAmount = newBalance - initialReceivingAssetBalance;\r\n\r\n        if (receivedAmount == 0) {\r\n            revert SwapFailed();\r\n        }\r\n\r\n        LibAsset.transfer(_swap.toAsset, _swap.user, receivedAmount);\r\n\r\n        emit AssetSwapped(_swap.callTo, _swap.fromAsset, _swap.toAsset, _swap.fromAmount, receivedAmount, _swap.user);\r\n\r\n        return receivedAmount;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { TimeUnit } from \"../AppStorage.sol\";\r\n\r\nerror InvalidUnit();\r\n\r\n/**\r\n * @title LibTime\r\n * @dev This library provides functions for time-related calculations.\r\n */\r\nlibrary LibTime {\r\n    /**\r\n     * @notice Convert a given time value to seconds based on the specified time unit.\r\n     * @param time The time value to convert.\r\n     * @param unit The time unit (e.g., TimeUnit.HOURS, TimeUnit.DAYS).\r\n     * @return The time value converted to seconds.\r\n     * @dev Reverts with `InvalidUnit` error if an unsupported time unit is provided.\r\n     */\r\n    function convertToSeconds(uint256 time, TimeUnit unit) internal pure returns (uint256) {\r\n        if (unit == TimeUnit.HOURS) {\r\n            return time * 3600;\r\n        } else if (unit == TimeUnit.DAYS) {\r\n            return time * 86400;\r\n        } else {\r\n            revert InvalidUnit();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a time difference condition is met.\r\n     * @param presentTime The current time.\r\n     * @param executionTime The execution time to consider (0 for immediate execution).\r\n     * @param targetTime The target time for comparison.\r\n     * @return A boolean indicating whether the time difference condition is met.\r\n     */\r\n\r\n    function getTimeDifference(\r\n        uint256 presentTime,\r\n        uint256 executionTime,\r\n        uint256 targetTime\r\n    ) internal pure returns (bool) {\r\n        if (executionTime == 0) {\r\n            return true;\r\n        }\r\n        bool timeDifference = targetTime <= presentTime - executionTime ? true : false;\r\n        return timeDifference;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibTrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { IERC20Metadata } from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport { HighSlippage } from \"../utils/GenericErrors.sol\";\r\n\r\n/**\r\n * @title LibTrade\r\n * @dev This library provides functions for calculating exchange rates and validating slippage.\r\n */\r\nlibrary LibTrade {\r\n    uint256 public constant MAX_PERCENTAGE = 10000;\r\n\r\n    /**\r\n    @dev Calculate exchange rate given input and output amounts\r\n    @param fromAsset Address of the asset that was used to swap\r\n    @param fromAmount Amount of the asset that was used to swap\r\n    @param toAmount Amount of the asset that was received from swap\r\n    @return uint256 Returns the exchange rate in toAsset unit\r\n     */\r\n    function calculateExchangeRate(\r\n        address fromAsset,\r\n        uint256 fromAmount,\r\n        uint256 toAmount\r\n    ) internal view returns (uint256) {\r\n        IERC20Metadata _fromToken = IERC20Metadata(fromAsset);\r\n        uint256 fromDecimals = _fromToken.decimals();\r\n        return ((toAmount * (10 ** fromDecimals)) / fromAmount);\r\n    }\r\n\r\n    /**\r\n     * @notice Validate the slippage of a swap.\r\n     * @param exchangeRate The calculated exchange rate for the swap.\r\n     * @param price The reference price for the swap.\r\n     * @param maxSlippage The maximum allowed slippage percentage.\r\n     * @param isBuy A flag indicating if it's a buy operation (true) or not (false).\r\n     * @return uint256 Returns the calculated slippage percentage.\r\n     */\r\n    function validateSlippage(\r\n        uint256 exchangeRate,\r\n        uint256 price,\r\n        uint256 maxSlippage,\r\n        bool isBuy\r\n    ) internal pure returns (uint256) {\r\n        uint256 slippage = (price * MAX_PERCENTAGE) / exchangeRate;\r\n\r\n        if (isBuy && slippage < MAX_PERCENTAGE && MAX_PERCENTAGE - slippage > maxSlippage) revert HighSlippage();\r\n        if (!isBuy && slippage > MAX_PERCENTAGE && slippage - MAX_PERCENTAGE > maxSlippage) revert HighSlippage();\r\n        return slippage;\r\n    }\r\n}\r\n"
    },
    "contracts/libraries/LibUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nimport \"./LibBytes.sol\";\r\n\r\n/**\r\n * @title LibUtil\r\n * @dev This library provides utility functions for working with revert messages.\r\n */\r\nlibrary LibUtil {\r\n    using LibBytes for bytes;\r\n\r\n    /**\r\n     * @notice Get a revert message from transaction result data.\r\n     * @param _res The transaction result data to extract the revert message from.\r\n     * @return string The revert message or a \"Transaction reverted silently\" message if none is found.\r\n     */\r\n    function getRevertMsg(bytes memory _res) internal pure returns (string memory) {\r\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\r\n        if (_res.length < 68) return \"Transaction reverted silently\";\r\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\r\n        return abi.decode(revertData, (string)); // All that remains is the revert string\r\n    }\r\n}\r\n"
    },
    "contracts/test/ScenarioDEX.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { ScenarioERC20 } from \"./ScenarioERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\r\n\r\ncontract ScenarioDEX {\r\n    // total decimals for USD price\r\n    uint256 public constant USD_DECIMALS = 8;\r\n\r\n    uint256 public constant MAX_SLIPPAGE = 10000;\r\n\r\n    // asset => exchangeRate in USD\r\n    mapping(address => uint256) public exchangeRate;\r\n\r\n    // asset => feed in USD\r\n    mapping(address => address) public feeds;\r\n\r\n    // MAX_SLIPPAGE = 100% = 10000\r\n    uint256 public slippage = 0;\r\n\r\n    function updateExchangeRate(address asset, uint256 rate) external {\r\n        exchangeRate[asset] = rate;\r\n    }\r\n\r\n    function updateFeed(address asset, address feed) external {\r\n        feeds[asset] = feed;\r\n    }\r\n\r\n    function updateSlippage(uint256 _slippage) external {\r\n        require(_slippage <= MAX_SLIPPAGE, \"ScenarioDEX: slippage must be less than 100%\");\r\n        slippage = _slippage;\r\n    }\r\n\r\n    function getPrice(address asset) public view returns (uint256) {\r\n        require(feeds[asset] != address(0) || exchangeRate[asset] > 0, \"ScenarioDEX: price not set\");\r\n\r\n        if (feeds[asset] != address(0)) {\r\n            return uint256(AggregatorV2V3Interface(feeds[asset]).latestAnswer());\r\n        } else {\r\n            return exchangeRate[asset];\r\n        }\r\n    }\r\n\r\n    function swap(address fromAsset, address toAsset, uint256 fromAmount) external {\r\n        require(fromAmount > 0, \"ScenarioDEX: fromAmount must be greater than 0\");\r\n\r\n        IERC20Metadata _fromToken = IERC20Metadata(fromAsset);\r\n        IERC20Metadata _toToken = IERC20Metadata(toAsset);\r\n\r\n        uint256 fromAmountInUSD = (fromAmount * getPrice(fromAsset)) / (10 ** _fromToken.decimals());\r\n        uint256 toAmount = (fromAmountInUSD * 10 ** _toToken.decimals()) / getPrice(toAsset);\r\n\r\n        uint256 slippageAmount = (toAmount * slippage) / MAX_SLIPPAGE;\r\n\r\n        ScenarioERC20(toAsset).mint(address(this), toAmount - slippageAmount);\r\n        SafeERC20.safeTransfer(IERC20(toAsset), msg.sender, toAmount - slippageAmount);\r\n        SafeERC20.safeTransferFrom(IERC20(fromAsset), msg.sender, address(this), fromAmount);\r\n    }\r\n}\r\n"
    },
    "contracts/test/ScenarioERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract ScenarioERC20 is ERC20 {\r\n    uint8 private _decimals;\r\n\r\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function mint(address to, uint256 amount) external {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}\r\n"
    },
    "contracts/test/ScenarioFeedAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract ScenarioFeedAggregator {\r\n    // price in USD -> 8 decimals\r\n    int256 public price;\r\n    uint80 public roundId;\r\n    mapping(uint80 => uint256) public roundPrice;\r\n\r\n    function setPrice(int256 _price, uint80 _roundId) external {\r\n        price = _price;\r\n        roundId = _roundId;\r\n    }\r\n\r\n    function setRoundPrice(uint80 _roundId, uint256 _price) external {\r\n        roundPrice[_roundId] = _price;\r\n    }\r\n\r\n    function getRoundData(\r\n        uint80 _roundId\r\n    ) external view returns (uint80, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound) {\r\n        if (roundPrice[_roundId] != 0) {\r\n            return (_roundId, int256(roundPrice[_roundId]), 0, 0, 0);\r\n        } else {\r\n            return (_roundId, int256(0), 0, 0, 0);\r\n        }\r\n    }\r\n\r\n    function latestRoundData()\r\n        external\r\n        view\r\n        returns (uint80, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)\r\n    {\r\n        return (roundId, price, 0, 0, 0);\r\n    }\r\n}\r\n"
    },
    "contracts/test/Test1Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract Test1Facet {\r\n    event TestEvent(address something);\r\n\r\n    function test1Func1() external {}\r\n\r\n    function test1Func2() external {}\r\n\r\n    function test1Func3() external {}\r\n\r\n    function test1Func4() external {}\r\n\r\n    function test1Func5() external {}\r\n\r\n    function test1Func6() external {}\r\n\r\n    function test1Func7() external {}\r\n\r\n    function test1Func8() external {}\r\n\r\n    function test1Func9() external {}\r\n\r\n    function test1Func10() external {}\r\n\r\n    function test1Func11() external {}\r\n\r\n    function test1Func12() external {}\r\n\r\n    function test1Func13() external {}\r\n\r\n    function test1Func14() external {}\r\n\r\n    function test1Func15() external {}\r\n\r\n    function test1Func16() external {}\r\n\r\n    function test1Func17() external {}\r\n\r\n    function test1Func18() external {}\r\n\r\n    function test1Func19() external {}\r\n\r\n    function test1Func20() external {}\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {}\r\n}\r\n"
    },
    "contracts/test/Test2Facet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract Test2Facet {\r\n    function test2Func1() external {}\r\n\r\n    function test2Func2() external {}\r\n\r\n    function test2Func3() external {}\r\n\r\n    function test2Func4() external {}\r\n\r\n    function test2Func5() external {}\r\n\r\n    function test2Func6() external {}\r\n\r\n    function test2Func7() external {}\r\n\r\n    function test2Func8() external {}\r\n\r\n    function test2Func9() external {}\r\n\r\n    function test2Func10() external {}\r\n\r\n    function test2Func11() external {}\r\n\r\n    function test2Func12() external {}\r\n\r\n    function test2Func13() external {}\r\n\r\n    function test2Func14() external {}\r\n\r\n    function test2Func15() external {}\r\n\r\n    function test2Func16() external {}\r\n\r\n    function test2Func17() external {}\r\n\r\n    function test2Func18() external {}\r\n\r\n    function test2Func19() external {}\r\n\r\n    function test2Func20() external {}\r\n}\r\n"
    },
    "contracts/upgradeInitializers/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\nimport { IDiamondLoupe } from \"../interfaces/IDiamondLoupe.sol\";\r\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\r\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\r\nimport { IERC165 } from \"../interfaces/IERC165.sol\";\r\nimport { AppStorage } from \"../AppStorage.sol\";\r\n\r\ncontract DiamondInit {\r\n    // You can add parameters to this function in order to pass in\r\n    // data to set your own state variables\r\n    function init() external {\r\n        // adding ERC165 data\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        s.supportedInterfaces[type(IERC165).interfaceId] = true;\r\n        s.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\r\n        s.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\r\n        s.supportedInterfaces[type(IERC173).interfaceId] = true;\r\n\r\n        // add your own state variables\r\n        // EIP-2535 specifies that the `diamondCut` function takes two optional\r\n        // arguments: address _init and bytes calldata _calldata\r\n        // These arguments are used to execute an arbitrary function using delegatecall\r\n        // in order to set state variables in the diamond during deployment or an upgrade\r\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface\r\n    }\r\n}\r\n"
    },
    "contracts/utils/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.20;\r\n\r\nerror NoSwapFromZeroBalance();\r\nerror InsufficientBalance(uint256 required, uint256 balance);\r\nerror SwapFailed();\r\nerror TransferFailed();\r\nerror InvalidExchangeRate(uint256 required, uint256 actual);\r\nerror InvalidPrice();\r\nerror InvalidSlippage();\r\nerror HighSlippage();\r\nerror InvalidInvestToken();\r\nerror InvalidStableToken();\r\nerror TokensMustDiffer();\r\nerror AtLeastOneOptionRequired();\r\nerror InvalidInvestAmount();\r\nerror FloorValueZero();\r\nerror InvalidSellType();\r\nerror InvalidSellValue();\r\nerror BuyAndSellAtMisorder();\r\nerror InvalidStableAmount();\r\nerror InvalidBuyType();\r\nerror InvalidBuyValue();\r\nerror InvalidFloorValue();\r\nerror InvalidFloorType();\r\nerror InvalidSellTypeDCA();\r\nerror FloorValueGreaterThanBuyValue();\r\nerror FloorValueGreaterThanSellValue();\r\nerror SellPercentageWithDCA();\r\nerror FloorPercentageWithDCA();\r\nerror BothBuyTwapAndBTD();\r\nerror BuyDCAWithoutBuy();\r\nerror BuyTwapTimeInvalid();\r\nerror BuyTwapTimeUnitNotSelected();\r\nerror BothSellTwapAndSTR();\r\nerror SellDCAWithoutSell();\r\nerror SellTwapTimeUnitNotSelected();\r\nerror SellTwapTimeInvalid();\r\nerror SellTwapOrStrWithoutSellDCAUnit();\r\nerror SellDCAUnitWithoutSellDCAValue();\r\nerror StrWithoutStrValueOrType();\r\nerror BTDWithoutBTDType();\r\nerror BTDTypeWithoutBTDValue();\r\nerror BuyDCAWithoutBuyDCAUnit();\r\nerror BuyDCAUnitWithoutBuyDCAValue();\r\nerror InvalidHighSellValue();\r\nerror SellDCAValueRangeIsNotValid();\r\nerror DCAValueShouldBeLessThanIntitialAmount();\r\nerror BuyDCAValueRangeIsNotValid();\r\nerror OrphandStrategy();\r\nerror BuyNeverExecute();\r\nerror FloorGreaterThanPrice();\r\nerror FeedNotFound();\r\nerror WrongPreviousIDs();\r\nerror RoundDataDoesNotMatch();\r\nerror StrategyIsNotActive();\r\n"
    },
    "contracts/utils/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport { AppStorage, FloorLegType, BuyLegType, SellLegType, TimeUnit, DIP_SPIKE, DCA_UNIT, CURRENT_PRICE } from \"../AppStorage.sol\";\r\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\r\n\r\nabstract contract Modifiers {\r\n    /// @notice 100% = 100000 -> 2 decimals\r\n\r\n    modifier onlyOwner() {\r\n        AppStorage storage s = LibDiamond.diamondStorage();\r\n        require(msg.sender == s.owner, \"Modifiers: Must be contract owner\");\r\n        _;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
