{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "contracts/AppStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nenum ReentrancyStatus {\n    NOT_ENTERED,\n    ENTERED\n}\n\n/**\n * @notice The `Status` enum represents the possible statuses of a trading strategy.\n * @dev This enum defines three status options that describe the state of a strategy:\n *      - ACTIVE: The strategy is currently active and operational.\n *      - CANCELLED: The strategy has been cancelled and is no longer in effect.\n *      - COMPLETED: The strategy has been successfully completed.\n */\nenum Status {\n    ACTIVE, // The strategy is currently active.\n    CANCELLED, // The strategy has been cancelled.\n    COMPLETED // The strategy has been successfully completed.\n}\n\n/**\n * @notice The `FloorLegType` enum defines the types of floor price legs for trading strategies.\n * @dev This enum enumerates three possible types of floor price legs that can be associated with a strategy:\n *      - NO_TYPE: No specific floor price leg is defined.\n *      - LIMIT_PRICE: The floor price is set as a specific limit price.\n *      - DECREASE_BY: The floor price is determined by decreasing the current price by a certain amount.\n */\nenum FloorLegType {\n    NO_TYPE, // No specific floor price leg is defined.\n    LIMIT_PRICE, // The floor price is set as a specific limit price.\n    DECREASE_BY // The floor price is determined by decreasing the current price by a certain amount.\n}\n/**\n * @notice The `BuyLegType` enum defines the types of buy legs for trading strategies.\n * @dev This enum enumerates two possible types of buy legs that can be associated with a strategy:\n *      - NO_TYPE: No specific buy leg is defined.\n *      - LIMIT_PRICE: The buy leg is set as a specific limit price.\n */\nenum BuyLegType {\n    NO_TYPE, // No specific buy leg is defined.\n    LIMIT_PRICE // The buy leg is set as a specific limit price.\n}\n\n/**\n * @notice The `SellLegType` enum defines the types of sell legs for trading strategies.\n * @dev This enum enumerates three possible types of sell legs that can be associated with a strategy:\n *      - NO_TYPE: No specific sell leg is defined.\n *      - LIMIT_PRICE: The sell leg is set as a specific limit price.\n *      - INCREASE_BY: The sell leg is determined by increasing the current price by a certain amount.\n */\nenum SellLegType {\n    NO_TYPE, // No specific sell leg is defined.\n    LIMIT_PRICE, // The sell leg is set as a specific limit price.\n    INCREASE_BY // The sell leg is determined by increasing the current price by a certain amount.\n}\n\n/**\n * @notice The `DIP_SPIKE` enum defines the types of dip and spike conditions for trading strategies.\n * @dev This enum enumerates five possible types of dip and spike conditions that can be associated with a strategy:\n *      - NO_SPIKE: No specific dip or spike condition is defined.\n *      - DECREASE_BY: The condition is based on a decrease in price by a certain percentage.\n *      - INCREASE_BY: The condition is based on an increase in price by a certain percentage.\n *      - FIXED_INCREASE: The condition is based on a fixed increase in price.\n *      - FIXED_DECREASE: The condition is based on a fixed decrease in price.\n */\nenum DIP_SPIKE {\n    NO_SPIKE, // No specific dip or spike condition is defined.\n    DECREASE_BY, // The condition is based on a decrease in price by a certain percentage.\n    INCREASE_BY, // The condition is based on an increase in price by a certain percentage.\n    FIXED_INCREASE, // The condition is based on a fixed increase in price.\n    FIXED_DECREASE // The condition is based on a fixed decrease in price.\n}\n\n/**\n * @notice The `DCA_UNIT` enum defines the units for Dollar-Cost Averaging (DCA) in trading strategies.\n * @dev This enum enumerates three possible units for DCA that can be associated with a strategy:\n *      - NO_UNIT: No specific DCA unit is defined.\n *      - PERCENTAGE: DCA is specified as a percentage of assets.\n *      - FIXED: DCA is specified as a fixed amount.\n */\nenum DCA_UNIT {\n    NO_UNIT, // No specific DCA unit is defined.\n    PERCENTAGE, // DCA is specified as a percentage of assets.\n    FIXED // DCA is specified as a fixed amount.\n}\n\n/**\n * @notice The `TimeUnit` enum defines the units of time for time-related settings in trading strategies.\n * @dev This enum enumerates three possible time units that can be used in trading strategies:\n *      - NO_UNIT: No specific time unit is defined.\n *      - HOURS: Time is measured in hours.\n *      - DAYS: Time is measured in days.\n */\nenum TimeUnit {\n    NO_UNIT, // No specific time unit is defined.\n    HOURS, // Time is measured in hours.\n    DAYS // Time is measured in days.\n}\n\n/**\n * @notice The `StrategyParameters` struct defines the parameters that configure a trading strategy.\n * @dev These parameters dictate the behavior of the strategy, including trading details, conditions, and actions.\n */\n\nstruct StrategyParameters {\n    // @param _investToken The address of the investment token.\n    address _investToken;\n    // @param _investAmount The amount of investment token to be used.\n    uint256 _investAmount;\n    // @param _stableToken The address of the stable token.\n    address _stableToken;\n    // @param _stableAmount The amount of stable token to be used.\n    uint256 _stableAmount;\n    // @param _impact The impact tolerance for the strategy.\n    uint256 _impact;\n    // @param _floorType The type of floor price (if floor is set).\n    FloorLegType _floorType;\n    // @param _floorValue The value of the floor price (if floor is set).\n    uint256 _floorValue;\n    // @param _liquidateOnFloor A flag to trigger liquidation when the floor price is reached (if floor is set)..\n    bool _liquidateOnFloor;\n    // @param _cancelOnFloor A flag to cancel the strategy when the floor price is reached (if floor is set).\n    bool _cancelOnFloor;\n    // @param _minimumLoss The minimum loss required for floor percentage to satisfy.\n    uint256 _minimumLoss;\n    // @param _buyType The type of buy action (if buy is set).\n    BuyLegType _buyType;\n    // @param _buyValue The value of the buy action (if buy is set).\n    uint256 _buyValue;\n    // @param _buyTwapTime The time interval for TWAP buying (if buy is set).\n    uint256 _buyTwapTime;\n    // @param _buyTwapTimeUnit The unit of time for TWAP buying .\n    TimeUnit _buyTwapTimeUnit;\n    // @param _btdValue The value for buying the dip (if buy is set).\n    uint256 _btdValue;\n    // @param _btdType The type of buy the dip action (if buy is set).\n    DIP_SPIKE _btdType;\n    // @param _buyDCAUnit The unit for buy DCA (Dollar-Cost Averaging) for stable amount (if buy is set).\n    DCA_UNIT _buyDCAUnit;\n    // @param _buyDCAValue The value for buy DCA.\n    uint256 _buyDCAValue;\n    // @param _sellType The type of sell action (if sell is set).\n    SellLegType _sellType;\n    // @param _sellValue The value of the sell action (if sell is set).\n    uint256 _sellValue;\n    // @param if sell DCA is selected, _highSellValue is used to trigger complete sell when the high sell value is reached (if sell is set).\n    uint256 _highSellValue;\n    // @param _minimumProfit The minimum profit to be generated during sell if sell profit percentage is set\n    uint256 _minimumProfit;\n    // @param _strValue The value of the str if it is set to true (if sell is set).\n    uint256 _strValue;\n    // @param _strType The type of str.\n    DIP_SPIKE _strType;\n    // @param _sellDCAUnit The unit for sell DCA (Dollar-Cost Averaging) for the invest amount (if sell is set).\n    DCA_UNIT _sellDCAUnit;\n    // @param _sellDCAValue The value for sell DCA.\n    uint256 _sellDCAValue;\n    // @param _sellTwapTime The time interval for TWAP selling (if sell is set).\n    uint256 _sellTwapTime;\n    //  @param _sellTwapTimeUnit The unit of time for TWAP selling (if sell is set).\n    TimeUnit _sellTwapTimeUnit;\n    // @param _completeOnSell A flag to complete the strategy on selling (if sell is set).\n    bool _completeOnSell;\n    // @param _current_price_sell The current price indicator is selected for sell\n    bool _current_price_sell;\n    // @param _current_price The current price indicator is selected for buy\n    bool _current_price_buy;\n}\n\n/**\n * @notice The `Strategy` struct defines the characteristics and status of a trading strategy.\n * @dev This struct encapsulates important data related to a trading strategy, including user ownership,\n *      strategy parameters, execution times, financial metrics, and its current status.\n * it is mostly used for internal computation\n */\n\nstruct Strategy {\n    //  @param user The address of the strategy owner.\n    address user;\n    // @param parameters The parameters that configure the behavior of the strategy\n    // as passed by the user and defined above\n    StrategyParameters parameters;\n    // to store invest amount to be sold when dca is chosen for percentage.\n    uint256 sellPercentageAmount;\n    // to store stable amount to be given when dca is chosen for percentage.\n    uint256 buyPercentageAmount;\n    // the invest amount based on which sellPercentageAmount is calculated\n    uint256 sellPercentageTotalAmount;\n    // the stable amount based on which buyPercentageAmount is calculated\n    uint256 buyPercentageTotalAmount;\n    //  @param sellTwapExecutedAt The timestamp of the last executed TWAP (Time-Weighted Average Price) sell.\n    //  if sell twap is set for the sell. Otherwise it remains 0\n    uint256 sellTwapExecutedAt;\n    //  @param buyTwapExecutedAt The timestamp of the last executed TWAP buy.\n    //  if buy Twap is set for btd. Otherwise it remains 0.\n    uint256 buyTwapExecutedAt;\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 investRoundIdForBTD;\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 stableRoundIdForBTD;\n    // @param invest roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 investRoundIdForSTR;\n    // @param stable roundId The Chainlink VRF (Verifiable Random Function) round ID.\n    uint80 stableRoundIdForSTR;\n    // @param investPrice The price at which investment is made.\n    //While creating strategy it is set to the current price\n    uint256 investPrice;\n    //  @param profit The current profit generated by the strategy.\n    uint256 profit;\n    //  @param budget The available budget for the strategy.\n    // it is set at the starting of the strategy\n    uint256 budget;\n    // @param status The current status of the strategy.\n    Status status;\n}\n/**\n * @notice AppStorage is the central storage structure for this contract, holding essential data.\n * @dev This struct contains critical information used by the contract for operation.\n * It stores data such as function selectors, supported interfaces, the contract owner, strategy details,\n * Chainlink feed information, and more.\n */\n\nstruct AppStorage {\n    // maps function selectors to the facets that execute the functions.\n    // and maps the selectors to their position in the selectorSlots array.\n    // func selector => address facet, selector position\n    mapping(bytes4 => bytes32) facets;\n    // array of slots of function selectors.\n    // each slot holds 8 function selectors.\n    mapping(uint256 => bytes32) selectorSlots;\n    // The number of function selectors in selectorSlots\n    uint16 selectorCount;\n    // Used to query if a contract implements an interface.\n    // Used to implement ERC-165.\n    mapping(bytes4 => bool) supportedInterfaces;\n    // owner of the contract\n    address owner;\n    // next id to use for strategies\n    uint256 nextStrategyId;\n    // array of strategies\n    mapping(uint256 => Strategy) strategies;\n    // chainlink feeds - asset => USD feed\n    mapping(address => address) feeds;\n    // account => nonce\n    mapping(address => uint256) nonces;\n    // reentrancy status\n    ReentrancyStatus reentrancyStatus;\n    // sequencer uptime feed\n    address sequencerUptimeFeed;\n    // max stale period\n    uint256 maxStalePeriod;\n}\n\n/**\n * @title Swap\n * @dev A struct representing a swap or trade operation on a decentralized exchange (DEX).\n *  @param dex: The address of the DEX where the swap is to be executed.\n *  @param callData: Encoded data containing instructions for the swap on the specified DEX.\n */\nstruct Swap {\n    address dex;\n    bytes callData;\n}\n\n// Struct representing the parameters to update in a strategy\nstruct UpdateStruct {\n    uint256 sellValue;\n    uint256 buyValue;\n    uint256 strValue;\n    uint256 btdValue;\n    uint256 floorValue;\n    uint256 highSellValue;\n    uint256 buyTwapTime;\n    TimeUnit buyTwapTimeUnit;\n    uint256 buyDCAValue;\n    uint256 sellDCAValue;\n    uint256 sellTwapTime;\n    TimeUnit sellTwapTimeUnit;\n    bool toggleCompleteOnSell;\n    bool toggleLiquidateOnFloor;\n    bool toggleCancelOnFloor;\n    uint256 impact;\n    bool current_price_sell;\n    bool current_price_buy;\n    uint256 minimumLoss;\n    uint256 minimumProfit;\n}\n\n// struct for information regarding which token is added in the strategy and which deleted\nstruct TokensTransaction {\n    uint256 tokenSubstracted;\n    uint256 tokenAdded;\n    uint256 stableAmount;\n    uint256 investAmount;\n}\n"
    },
    "contracts/facets/PriceOracleFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IERC173 } from \"../interfaces/IERC173.sol\";\nimport { Modifiers } from \"../utils/Modifiers.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\nimport { LibPrice } from \"../libraries/LibPrice.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\n/**\n * @title PriceOracleFacet\n * @dev This contract manages asset price feeds used by the diamond contract.\n */\ncontract PriceOracleFacet is Modifiers {\n    AppStorage internal s;\n\n    /**\n     * @notice Emitted when an asset price feed is configured.\n     * @param asset The address of the asset.\n     * @param feed The address of the price feed for the asset.\n     */\n    event AssetFeedConfigured(\n        address indexed asset,\n        address indexed feed\n    );\n\n    /**\n     * @notice Emitted when the sequencer uptime feed is configured.\n     * @param feed The address of the sequencer uptime feed.\n     */\n    event SequencerFeedUpdated(\n        address indexed feed\n    );\n\n    /**\n     * @notice Emitted when the max stale period for price feeds is updated.\n     * @param maxStalePeriod The max stale period for price feeds.\n     */\n    event MaxStalePricePeriodUpdated(\n        uint256 indexed maxStalePeriod\n    );\n\n    /**\n     * @notice Sets the asset price feed address for a specific asset.\n     * @param _asset The address of the asset.\n     * @param _feed The address of the price feed for the asset.\n     */\n    function setAssetFeed(address _asset, address _feed) external onlyOwner {\n        s.feeds[_asset] = _feed;\n        emit AssetFeedConfigured(_asset, _feed);\n    }\n\n    /**\n     * @notice Sets the asset price feed addresses for a list of assets.\n     * @param _assets The addresses of the assets.\n     * @param _feeds The addresses of the price feeds for the assets.\n     */\n    function setAssetFeeds(address[] calldata _assets, address[] calldata _feeds) external onlyOwner {\n        require(_assets.length == _feeds.length, \"length mismatch\");\n        for (uint256 i = 0; i < _assets.length; i++) {\n            s.feeds[_assets[i]] = _feeds[i];\n            emit AssetFeedConfigured(_assets[i], _feeds[i]);\n        }\n    }\n\n    /**\n     * @notice Sets the address of the sequencer uptime feed.\n     * @param _sequencerUptimeFeed The address of the sequencer uptime feed.\n     */\n    function setSequencerUptimeFeed(address _sequencerUptimeFeed) external onlyOwner {\n        s.sequencerUptimeFeed = _sequencerUptimeFeed;\n        emit SequencerFeedUpdated(_sequencerUptimeFeed);\n    }\n\n    /**\n     * @notice Sets the max stale period for price feeds.\n     * @param _maxStalePricePeriod The max stale period for price feeds.\n     */\n    function setMaxStalePricePeriod(uint256 _maxStalePricePeriod) external onlyOwner {\n        s.maxStalePeriod = _maxStalePricePeriod;\n        emit MaxStalePricePeriodUpdated(_maxStalePricePeriod);\n    }\n\n    /**\n     * @notice Get the current price and round IDs of an asset relative to a unit.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The current price of the asset in terms of the unit.\n     * @return investRoundId The round ID of the asset's price feed.\n     * @return stableRoundId The round ID of the unit's price feed.\n     */\n    function getPrice(address asset, address unit) external view returns (uint256 price, uint80, uint80) {\n        return LibPrice.getPrice(asset, unit);\n    }\n\n    /**\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\n     * @param investRoundId The round ID of the asset's price feed.\n     * @param stableRoundId The round ID of the unit's price feed.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\n     */\n    function getRoundData(\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        address asset,\n        address unit\n    ) external view returns (uint256) {\n        return LibPrice.getRoundData(investRoundId, stableRoundId, asset, unit);\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @return price The price of the asset in USD\n     */\n    function getUSDPrice(address asset) external view returns (uint80, int256) {\n        (uint80 roundId, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\n        return (roundId, assetPrice);\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @param roundId the round for which price is required.\n     * @return price The price of the asset based on round Id\n     */\n    function getPriceBasedOnRoundId(address asset, uint80 roundId) external view returns (uint256) {\n        return LibPrice.getPriceBasedOnRoundId(asset, roundId);\n    }\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IDiamondCut {\n    enum FacetCutAction {\n        Add,\n        Replace,\n        Remove\n    }\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(FacetCut[] calldata _diamondCut, address _init, bytes calldata _calldata) external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}\n"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    // event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}\n"
    },
    "contracts/libraries/LibDiamond.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { IDiamondCut } from \"../interfaces/IDiamondCut.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nerror InitializationFunctionReverted(address _initializationContractAddress, bytes _calldata);\n\nlibrary LibDiamond {\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    bytes32 constant CLEAR_ADDRESS_MASK = bytes32(uint256(0xffffffffffffffffffffffff));\n    bytes32 constant CLEAR_SELECTOR_MASK = bytes32(uint256(0xffffffff << 224));\n\n    function diamondStorage() internal pure returns (AppStorage storage s) {\n        assembly {\n            s.slot := 0\n        }\n    }\n\n    function setContractOwner(address _newOwner) internal {\n        AppStorage storage s = diamondStorage();\n        address previousOwner = s.owner;\n        s.owner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    // Internal function version of diamondCut\n    // This code is almost the same as the external diamondCut,\n    // except it is using 'Facet[] memory _diamondCut' instead of\n    // 'Facet[] calldata _diamondCut'.\n    // The code is duplicated to prevent copying calldata to memory which\n    // causes an error for a two dimensional array.\n    function diamondCut(IDiamondCut.FacetCut[] memory _diamondCut, address _init, bytes memory _calldata) internal {\n        AppStorage storage s = diamondStorage();\n        uint256 originalSelectorCount = s.selectorCount;\n        uint256 selectorCount = originalSelectorCount;\n        bytes32 selectorSlot;\n        // Check if last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // get last selectorSlot\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            selectorSlot = s.selectorSlots[selectorCount >> 3];\n        }\n        // loop through diamond cut\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; ) {\n            (selectorCount, selectorSlot) = addReplaceRemoveFacetSelectors(\n                selectorCount,\n                selectorSlot,\n                _diamondCut[facetIndex].facetAddress,\n                _diamondCut[facetIndex].action,\n                _diamondCut[facetIndex].functionSelectors\n            );\n\n            unchecked {\n                facetIndex++;\n            }\n        }\n        if (selectorCount != originalSelectorCount) {\n            s.selectorCount = uint16(selectorCount);\n        }\n        // If last selector slot is not full\n        // \"selectorCount & 7\" is a gas efficient modulo by eight \"selectorCount % 8\"\n        if (selectorCount & 7 > 0) {\n            // \"selectorSlot >> 3\" is a gas efficient division by 8 \"selectorSlot / 8\"\n            s.selectorSlots[selectorCount >> 3] = selectorSlot;\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addReplaceRemoveFacetSelectors(\n        uint256 _selectorCount,\n        bytes32 _selectorSlot,\n        address _newFacetAddress,\n        IDiamondCut.FacetCutAction _action,\n        bytes4[] memory _selectors\n    ) internal returns (uint256, bytes32) {\n        AppStorage storage s = diamondStorage();\n        require(_selectors.length > 0, \"LibDiamondCut: No selectors in facet to cut\");\n        if (_action == IDiamondCut.FacetCutAction.Add) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Add facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                require(\n                    address(bytes20(oldFacet)) == address(0),\n                    \"LibDiamondCut: Can't add function that already exists\"\n                );\n                // add facet for selector\n                s.facets[selector] = bytes20(_newFacetAddress) | bytes32(_selectorCount);\n                // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n                // \" << 5 is the same as multiplying by 32 ( * 32)\n                uint256 selectorInSlotPosition = (_selectorCount & 7) << 5;\n                // clear selector position in slot and add selector\n                _selectorSlot =\n                    (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> selectorInSlotPosition)) |\n                    (bytes32(selector) >> selectorInSlotPosition);\n                // if slot is full then write it to storage\n                if (selectorInSlotPosition == 224) {\n                    // \"_selectorSlot >> 3\" is a gas efficient division by 8 \"_selectorSlot / 8\"\n                    s.selectorSlots[_selectorCount >> 3] = _selectorSlot;\n                    _selectorSlot = 0;\n                }\n                _selectorCount++;\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Replace) {\n            enforceHasContractCode(_newFacetAddress, \"LibDiamondCut: Replace facet has no code\");\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                bytes4 selector = _selectors[selectorIndex];\n                bytes32 oldFacet = s.facets[selector];\n                address oldFacetAddress = address(bytes20(oldFacet));\n                // only useful if immutable functions exist\n                require(oldFacetAddress != address(this), \"LibDiamondCut: Can't replace immutable function\");\n                require(\n                    oldFacetAddress != _newFacetAddress,\n                    \"LibDiamondCut: Can't replace function with same function\"\n                );\n                require(oldFacetAddress != address(0), \"LibDiamondCut: Can't replace function that doesn't exist\");\n                // replace old facet address\n                s.facets[selector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(_newFacetAddress);\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n        } else if (_action == IDiamondCut.FacetCutAction.Remove) {\n            require(_newFacetAddress == address(0), \"LibDiamondCut: Remove facet address must be address(0)\");\n            // \"_selectorCount >> 3\" is a gas efficient division by 8 \"_selectorCount / 8\"\n            uint256 selectorSlotCount = _selectorCount >> 3;\n            // \"_selectorCount & 7\" is a gas efficient modulo by eight \"_selectorCount % 8\"\n            uint256 selectorInSlotIndex = _selectorCount & 7;\n            for (uint256 selectorIndex; selectorIndex < _selectors.length; ) {\n                if (_selectorSlot == 0) {\n                    // get last selectorSlot\n                    selectorSlotCount--;\n                    _selectorSlot = s.selectorSlots[selectorSlotCount];\n                    selectorInSlotIndex = 7;\n                } else {\n                    selectorInSlotIndex--;\n                }\n                bytes4 lastSelector;\n                uint256 oldSelectorsSlotCount;\n                uint256 oldSelectorInSlotPosition;\n                // adding a block here prevents stack too deep error\n                {\n                    bytes4 selector = _selectors[selectorIndex];\n                    bytes32 oldFacet = s.facets[selector];\n                    require(\n                        address(bytes20(oldFacet)) != address(0),\n                        \"LibDiamondCut: Can't remove function that doesn't exist\"\n                    );\n                    // only useful if immutable functions exist\n                    require(\n                        address(bytes20(oldFacet)) != address(this),\n                        \"LibDiamondCut: Can't remove immutable function\"\n                    );\n                    // replace selector with last selector in s.facets\n                    // gets the last selector\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    lastSelector = bytes4(_selectorSlot << (selectorInSlotIndex << 5));\n                    if (lastSelector != selector) {\n                        // update last selector slot position info\n                        s.facets[lastSelector] = (oldFacet & CLEAR_ADDRESS_MASK) | bytes20(s.facets[lastSelector]);\n                    }\n                    delete s.facets[selector];\n                    uint256 oldSelectorCount = uint16(uint256(oldFacet));\n                    // \"oldSelectorCount >> 3\" is a gas efficient division by 8 \"oldSelectorCount / 8\"\n                    oldSelectorsSlotCount = oldSelectorCount >> 3;\n                    // \"oldSelectorCount & 7\" is a gas efficient modulo by eight \"oldSelectorCount % 8\"\n                    // \" << 5 is the same as multiplying by 32 ( * 32)\n                    oldSelectorInSlotPosition = (oldSelectorCount & 7) << 5;\n                }\n                if (oldSelectorsSlotCount != selectorSlotCount) {\n                    bytes32 oldSelectorSlot = s.selectorSlots[oldSelectorsSlotCount];\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    oldSelectorSlot =\n                        (oldSelectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                    // update storage with the modified slot\n                    s.selectorSlots[oldSelectorsSlotCount] = oldSelectorSlot;\n                } else {\n                    // clears the selector we are deleting and puts the last selector in its place.\n                    _selectorSlot =\n                        (_selectorSlot & ~(CLEAR_SELECTOR_MASK >> oldSelectorInSlotPosition)) |\n                        (bytes32(lastSelector) >> oldSelectorInSlotPosition);\n                }\n                if (selectorInSlotIndex == 0) {\n                    delete s.selectorSlots[selectorSlotCount];\n                    _selectorSlot = 0;\n                }\n\n                unchecked {\n                    selectorIndex++;\n                }\n            }\n            _selectorCount = selectorSlotCount * 8 + selectorInSlotIndex;\n        } else {\n            revert(\"LibDiamondCut: Incorrect FacetCutAction\");\n        }\n        return (_selectorCount, _selectorSlot);\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            return;\n        }\n        enforceHasContractCode(_init, \"LibDiamondCut: _init address has no code\");\n        (bool success, bytes memory error) = _init.delegatecall(_calldata);\n        if (!success) {\n            if (error.length > 0) {\n                // bubble up error\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(error)\n                    revert(add(32, error), returndata_size)\n                }\n            } else {\n                revert InitializationFunctionReverted(_init, _calldata);\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n}\n"
    },
    "contracts/libraries/LibPrice.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol\";\n\nimport { LibDiamond } from \"./LibDiamond.sol\";\nimport { InvalidPrice, FeedNotFound } from \"../utils/GenericErrors.sol\";\nimport { AppStorage } from \"../AppStorage.sol\";\n\nerror SequencerDown();\nerror GracePeriodNotOver();\nerror PriceExpired();\n\n/**\n * @title LibPrice\n * @dev This library provides functions for fetching and manipulating asset prices.\n */\nlibrary LibPrice {\n    address constant USD_QUOTE = 0x0000000000000000000000000000000000000348;\n    uint256 private constant GRACE_PERIOD_TIME = 3600;\n\n    /**\n     * @notice Get the current price and round IDs of an asset relative to a unit.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The current price of the asset in terms of the unit.\n     * @return investRoundId The round ID of the asset's price feed.\n     * @return stableRoundId The round ID of the unit's price feed.\n     */\n    function getPrice(address asset, address unit) internal view returns (uint256 price, uint80, uint80) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        AggregatorV2V3Interface sequencerUptimeFeed = AggregatorV2V3Interface(s.sequencerUptimeFeed);\n\n        if (address(sequencerUptimeFeed) != address(0)) {\n            (\n                ,\n                /*uint80 roundID*/ int256 answer,\n                uint256 startedAt /*uint256 updatedAt*/ /*uint80 answeredInRound*/,\n                ,\n\n            ) = sequencerUptimeFeed.latestRoundData();\n\n            // Answer == 0: Sequencer is up\n            // Answer == 1: Sequencer is down\n            bool isSequencerUp = answer == 0;\n            if (!isSequencerUp) {\n                revert SequencerDown();\n            }\n\n            // Make sure the grace period has passed after the\n            // sequencer is back up.\n            uint256 timeSinceUp = block.timestamp - startedAt;\n            if (timeSinceUp <= GRACE_PERIOD_TIME) {\n                revert GracePeriodNotOver();\n            }\n        }\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (uint80 investRoundId, int256 assetPrice, , uint256 investUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[asset])\n            .latestRoundData();\n        (uint80 stableRoundId, int256 unitPrice, , uint256 stableUpdatedAt, ) = AggregatorV2V3Interface(s.feeds[unit])\n            .latestRoundData();\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        if (\n            block.timestamp - investUpdatedAt > s.maxStalePeriod || block.timestamp - stableUpdatedAt > s.maxStalePeriod\n        ) {\n            revert PriceExpired();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return (price, investRoundId, stableRoundId);\n    }\n\n    /**\n     * @notice Get the historical price of an asset relative to a unit at specific round IDs.\n     * @param investRoundId The round ID of the asset's price feed.\n     * @param stableRoundId The round ID of the unit's price feed.\n     * @param asset The address of the asset.\n     * @param unit The address of the unit (e.g., USD).\n     * @return price The price of the asset in terms of the unit at the specified round IDs.\n     */\n    function getRoundData(\n        uint80 investRoundId,\n        uint80 stableRoundId,\n        address asset,\n        address unit\n    ) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0) || s.feeds[unit] == address(0)) {\n            revert FeedNotFound();\n        }\n\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(investRoundId);\n        (, int256 unitPrice, , , ) = AggregatorV2V3Interface(s.feeds[unit]).getRoundData(stableRoundId);\n\n        if (assetPrice == 0 || unitPrice == 0) {\n            revert InvalidPrice();\n        }\n\n        uint256 unitDecimals = IERC20Metadata(unit).decimals();\n        uint256 price = (uint256(assetPrice) * (10 ** unitDecimals)) / uint256(unitPrice);\n\n        return price;\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @return price The price of the asset in USD\n     */\n    function getUSDPrice(address asset) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0)) {\n            revert FeedNotFound();\n        }\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).latestRoundData();\n        if (assetPrice == 0) {\n            revert InvalidPrice();\n        }\n        return uint256(assetPrice);\n    }\n\n    /**\n     * @notice Get the price of an asset in USD.\n     * @param asset The address of the asset.\n     * @param roundId the round for which price is required.\n     * @return price The price of the asset based on round Id\n     */\n    function getPriceBasedOnRoundId(address asset, uint80 roundId) internal view returns (uint256) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n\n        if (s.feeds[asset] == address(0)) {\n            revert FeedNotFound();\n        }\n        (, int256 assetPrice, , , ) = AggregatorV2V3Interface(s.feeds[asset]).getRoundData(roundId);\n        if (assetPrice == 0) {\n            revert InvalidPrice();\n        }\n        return uint256(assetPrice);\n    }\n}\n"
    },
    "contracts/utils/GenericErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.20;\n\nerror NoSwapFromZeroBalance();\nerror InsufficientBalance(uint256 required, uint256 balance);\nerror SwapFailed();\nerror TransferFailed();\nerror InvalidExchangeRate(uint256 required, uint256 actual);\nerror InvalidPrice();\nerror InvalidImpact();\nerror HighImpact();\nerror InvalidInvestToken();\nerror InvalidStableToken();\nerror TokensMustDiffer();\nerror AtLeastOneOptionRequired();\nerror InvalidInvestAmount();\nerror FloorValueZero();\nerror InvalidSellType();\nerror InvalidSellValue();\nerror BuyAndSellAtMisorder();\nerror InvalidStableAmount();\nerror InvalidBuyType();\nerror InvalidBuyValue();\nerror InvalidFloorValue();\nerror InvalidFloorType();\nerror InvalidSellTypeDCA();\nerror FloorValueGreaterThanBuyValue();\nerror FloorValueGreaterThanSellValue();\nerror BothBuyTwapAndBTD();\nerror BuyDCAWithoutBuy();\nerror BuyTwapTimeInvalid();\nerror BuyTwapTimeUnitNotSelected();\nerror BothSellTwapAndSTR();\nerror SellDCAWithoutSell();\nerror SellTwapTimeUnitNotSelected();\nerror SellTwapTimeInvalid();\nerror SellTwapOrStrWithoutSellDCAUnit();\nerror SellDCAUnitWithoutSellDCAValue();\nerror StrWithoutStrType();\nerror BTDWithoutBTDType();\nerror BuyDCAWithoutBuyDCAUnit();\nerror BuyDCAUnitWithoutBuyDCAValue();\nerror InvalidHighSellValue();\nerror SellDCAValueRangeIsNotValid();\nerror DCAValueShouldBeLessThanIntitialAmount();\nerror BuyDCAValueRangeIsNotValid();\nerror OrphandStrategy();\nerror BuyNeverExecute();\nerror FloorGreaterThanPrice();\nerror FeedNotFound();\nerror WrongPreviousIDs();\nerror RoundDataDoesNotMatch();\nerror StrategyIsNotActive();\nerror InvalidNonce();\nerror InvalidSigner();\nerror AlreadyCancelled();\nerror BuyNotSet();\nerror SellNotSelected();\nerror PercentageNotInRange();\nerror BuyTwapNotSelected();\nerror SellTwapNotSelected();\nerror FloorNotSet();\nerror ReentrancyGuardReentrantCall();\nerror PriceNotInRange();\n"
    },
    "contracts/utils/Modifiers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport { AppStorage, FloorLegType, BuyLegType, SellLegType, TimeUnit, DIP_SPIKE, DCA_UNIT, ReentrancyStatus } from \"../AppStorage.sol\";\nimport { ReentrancyGuardReentrantCall } from \"./GenericErrors.sol\";\nimport { LibDiamond } from \"../libraries/LibDiamond.sol\";\n\nabstract contract Modifiers {\n    /// @notice 100% = 100000 -> 2 decimals\n\n    modifier onlyOwner() {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        require(msg.sender == s.owner, \"Modifiers: Must be contract owner\");\n        _;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        // On the first call to nonReentrant, s.reentrancyStatus will be ReentrancyStatus.NOT_ENTERED\n        if (s.reentrancyStatus == ReentrancyStatus.ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        s.reentrancyStatus = ReentrancyStatus.ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        s.reentrancyStatus = ReentrancyStatus.NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        AppStorage storage s = LibDiamond.diamondStorage();\n        return s.reentrancyStatus == ReentrancyStatus.ENTERED;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
